<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Frontier - An advanced real-time strategic territory simulation featuring AI nations, diplomatic relations, special artifacts, and tactical warfare">
    <meta name="author" content="WardCommand">
    <meta name="keywords" content="strategy game, RTS, territorial control, AI simulation, browser game">
    <meta property="og:title" content="Frontier - Strategic Simulation">
    <meta property="og:description" content="Real-time strategy simulation with AI nations, diplomacy, and tactical warfare">
    <meta property="og:type" content="website">
    <title>Frontier - Strategic Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0a0a0a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-content {
            text-align: center;
            color: #00ff88;
        }
        
        .loading-title {
            font-size: 48px;
            font-weight: bold;
            letter-spacing: 8px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
            margin-bottom: 20px;
        }
        
        .loading-subtitle {
            font-size: 14px;
            letter-spacing: 2px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-title">FRONTIER</div>
            <div class="loading-subtitle">INITIALIZING STRATEGIC SIMULATION</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        'use strict';
        
        // ============================================================================
        // FRONTIER - Advanced Strategic Territory Simulation
        // A real-time strategy game featuring AI nations, territorial control,
        // special artifacts, superweapons, and complex tactical gameplay
        // ============================================================================
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        
        // ============================================================================
        // AUDIO SYSTEM - Advanced spatial audio with synthesis and TTS
        // ============================================================================
        
        let audioCtx = null;
        let masterGain = null;
        let audioChannels = {};
        let cachedVoices = [];
        let qualityVoices = [];
        
        /**
         * Load and cache available speech synthesis voices
         * Prioritizes high-quality voices (Google, Microsoft, Neural, etc.)
         */
        function loadVoices() {
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                cachedVoices = voices;
                
                qualityVoices = voices.filter(v => 
                    v.name.includes('Google') || 
                    v.name.includes('Microsoft') ||
                    v.name.includes('Enhanced') ||
                    v.name.includes('Premium') ||
                    v.name.includes('Neural')
                );
                
                if (qualityVoices.length === 0) qualityVoices = voices;
                
                console.log(`✓ Loaded ${voices.length} voices (${qualityVoices.length} high-quality)`);
            }
        }
        
        if (window.speechSynthesis) {
            loadVoices();
            window.speechSynthesis.onvoiceschanged = loadVoices;
            window.addEventListener('load', loadVoices);
            setTimeout(loadVoices, 100);
        }
        
        /**
         * Initialize Web Audio API context and channel routing
         * Creates separate gain nodes for combat, ambient, UI, events, and announcer sounds
         */
        function initAudioContext() {
            if (audioCtx) return;

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.7;
            masterGain.connect(audioCtx.destination);

            audioChannels = {
                combat: audioCtx.createGain(),
                ambient: audioCtx.createGain(),
                ui: audioCtx.createGain(),
                events: audioCtx.createGain(),
                announcer: audioCtx.createGain()
            };

            audioChannels.combat.gain.value = 0.8;
            audioChannels.ambient.gain.value = 0.3;
            audioChannels.ui.gain.value = 0.7;
            audioChannels.events.gain.value = 0.9;
            audioChannels.announcer.gain.value = 1.0;

            Object.values(audioChannels).forEach(ch => ch.connect(masterGain));
            
            console.log('✓ Audio system initialized');
        }

        /**
         * Create stereo panner for spatial sound positioning
         * @param {number} x - World X coordinate
         * @param {number} y - World Y coordinate  
         * @param {GainNode} channel - Audio channel to connect to
         * @returns {StereoPannerNode|null} Configured panner or null if audio not ready
         */
        function createSpatialSound(x, y, channel) {
            if (!audioCtx) return null;
            const panner = audioCtx.createStereoPanner();
            const worldWidth = canvas ? canvas.width * WORLD_SCALE : window.innerWidth;
            const pan = ((x / worldWidth) - 0.5) * 2;
            panner.pan.value = Math.max(-1, Math.min(1, pan));
            panner.connect(channel);
            return panner;
        }

        /**
         * Audio cooldown tracking to prevent sound spam
         */
        const audioCooldowns = {
            lastHit: 0,
            lastCapture: 0,
            lastDeath: 0,
            lastVictory: 0,
            lastAlert: 0,
            lastMissile: 0,
            lastEvacuationAlert: 0
        };

        // Procedural sound generators (simplified rebuild after corruption)
        const Audio = {
            playImpactEvent(x, y) {
                if (!audioCtx || !masterGain) return;
                try {
                    // Deep rumbling bass explosion
                    const bass = audioCtx.createOscillator();
                    const bassGain = audioCtx.createGain();
                    bass.type = 'sine';
                    bass.frequency.setValueAtTime(40, audioCtx.currentTime);
                    bass.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 3.0);
                    bassGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    bassGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3.0);
                    bass.connect(bassGain).connect(masterGain);
                    bass.start();
                    bass.stop(audioCtx.currentTime + 3.0);
                    
                    // High frequency crack
                    const crack = audioCtx.createOscillator();
                    const crackGain = audioCtx.createGain();
                    crack.type = 'square';
                    crack.frequency.setValueAtTime(8000, audioCtx.currentTime);
                    crack.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                    crackGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    crackGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                    crack.connect(crackGain).connect(masterGain);
                    crack.start();
                    crack.stop(audioCtx.currentTime + 0.3);
                } catch (err) {
                    console.warn('Impact sound failed:', err);
                }
            },
            enabled: true,
            battleAmbience: null,
            battleIntensity: 0,

            playHit(x, y, intensity = 1.0) {
                if (!audioCtx) {
                    console.warn('[AUDIO] playHit: audioCtx not initialized');
                    return;
                }
                if (audioCtx.state !== 'running') {
                    console.warn('[AUDIO] playHit: audioCtx state is', audioCtx.state);
                    return;
                }
                if (!this.enabled) {
                    console.warn('[AUDIO] playHit: Audio.enabled is false');
                    return;
                }
                const now = audioCtx.currentTime;
                if (now - audioCooldowns.lastHit < 0.08) return; // Increased cooldown to prevent overlap
                audioCooldowns.lastHit = now;

                const panner = createSpatialSound(x ?? canvas.width / 2, y ?? canvas.height / 2, audioChannels.combat);
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle'; // Softer than square wave
                osc.frequency.value = 280 * intensity; // Slightly lower pitch
                
                // Fade in/out to prevent clicks
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.06 * intensity, now + 0.01); // Fast fade-in
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12); // Fade out
                
                osc.connect(gain);
                gain.connect(panner);
                osc.start(now);
                osc.stop(now + 0.13);
            },

            playArtillery(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                
                const panner = createSpatialSound(x, y, audioChannels.combat);
                
                // Deep thump explosion with added mid-range punch for audibility
                const boom = audioCtx.createOscillator();
                const rumble = audioCtx.createOscillator();
                const crack = audioCtx.createOscillator(); // Add mid-range crack
                const gainNode = audioCtx.createGain();
                
                boom.type = 'sine';
                rumble.type = 'sine';
                crack.type = 'triangle';
                
                // Deep bass punch
                boom.frequency.setValueAtTime(120, now);
                boom.frequency.exponentialRampToValueAtTime(30, now + 0.25);
                
                // Low rumble layer
                rumble.frequency.setValueAtTime(60, now);
                rumble.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                
                // Mid-range crack for audibility (especially on smaller speakers)
                crack.frequency.setValueAtTime(400, now);
                crack.frequency.exponentialRampToValueAtTime(150, now + 0.15);
                
                // Sharp attack, quick decay
                gainNode.gain.setValueAtTime(0.4, now); // Increased from 0.35
                gainNode.gain.exponentialRampToValueAtTime(0.1, now + 0.15); // Increased from 0.08
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                
                boom.connect(gainNode);
                rumble.connect(gainNode);
                crack.connect(gainNode);
                gainNode.connect(panner);
                
                boom.start(now);
                rumble.start(now);
                crack.start(now);
                boom.stop(now + 0.4);
                rumble.stop(now + 0.4);
                crack.stop(now + 0.2);
            },

            playSelfDestruct(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.combat);
                
                // CATASTROPHIC CAPITAL DETONATION
                // Deep subsonic rumble (building destruction)
                const subRumble = audioCtx.createOscillator();
                subRumble.type = 'sawtooth';
                subRumble.frequency.setValueAtTime(40, now);
                subRumble.frequency.exponentialRampToValueAtTime(15, now + 1.0);
                
                // Primary explosion blast
                const blast = audioCtx.createOscillator();
                blast.type = 'triangle';
                blast.frequency.setValueAtTime(200, now);
                blast.frequency.exponentialRampToValueAtTime(60, now + 0.5);
                
                // High-frequency screech (energy discharge)
                const screech = audioCtx.createOscillator();
                screech.type = 'square';
                screech.frequency.setValueAtTime(1800, now);
                screech.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                // Crackling debris
                const crackle = audioCtx.createOscillator();
                crackle.type = 'sawtooth';
                crackle.frequency.setValueAtTime(400, now + 0.2);
                crackle.frequency.exponentialRampToValueAtTime(150, now + 0.8);
                
                const gainNode = audioCtx.createGain();
                
                // MASSIVE initial blast, long rumbling decay
                gainNode.gain.setValueAtTime(0.45, now); // LOUD
                gainNode.gain.exponentialRampToValueAtTime(0.25, now + 0.3); // Sustained
                gainNode.gain.exponentialRampToValueAtTime(0.08, now + 0.7); // Rumble
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.2); // Fade
                
                subRumble.connect(gainNode);
                blast.connect(gainNode);
                screech.connect(gainNode);
                crackle.connect(gainNode);
                gainNode.connect(panner);
                
                subRumble.start(now);
                subRumble.stop(now + 1.2);
                blast.start(now);
                blast.stop(now + 0.6);
                screech.start(now);
                screech.stop(now + 0.4);
                crackle.start(now + 0.2);
                crackle.stop(now + 1.0);
            },

            playMissileLaunch(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                // Prevent orchestra tuning effect - cooldown between missile sounds
                if (now - audioCooldowns.lastMissile < 0.15) return;
                audioCooldowns.lastMissile = now;
                
                const panner = createSpatialSound(x, y, audioChannels.combat);
                
                // Deep rumbling launch - low frequency bass
                const rumble = audioCtx.createOscillator();
                const rumbleGain = audioCtx.createGain();
                rumble.type = 'sine';
                rumble.frequency.setValueAtTime(80, now); // Low bass rumble
                rumble.frequency.linearRampToValueAtTime(60, now + 0.2); // Slight drop
                
                // Fade in/out to prevent clicks
                rumbleGain.gain.setValueAtTime(0, now);
                rumbleGain.gain.linearRampToValueAtTime(0.08, now + 0.02); // Quick fade in
                rumbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); // Fade out
                
                rumble.connect(rumbleGain);
                rumbleGain.connect(panner);
                rumble.start(now);
                rumble.stop(now + 0.21);
            },

            playMissileImpact(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                
                const panner = createSpatialSound(x, y, audioChannels.combat);
                
                // Soft falling sound (barely audible drop)
                const fall = audioCtx.createOscillator();
                const fallGain = audioCtx.createGain();
                fall.type = 'triangle';
                fall.frequency.setValueAtTime(900, now);
                fall.frequency.exponentialRampToValueAtTime(400, now + 0.25);
                
                // Fade in/out to prevent clicks
                fallGain.gain.setValueAtTime(0, now);
                fallGain.gain.linearRampToValueAtTime(0.03, now + 0.01);
                fallGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                
                fall.connect(fallGain);
                fallGain.connect(panner);
                fall.start(now);
                fall.stop(now + 0.26);
                
                // Muffled "thump" impact
                const thud = audioCtx.createOscillator();
                const thudGain = audioCtx.createGain();
                thud.type = 'sine';
                thud.frequency.setValueAtTime(120, now + 0.25);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.35);
                
                // Fade in/out to prevent clicks
                thudGain.gain.setValueAtTime(0, now + 0.25);
                thudGain.gain.linearRampToValueAtTime(0.08, now + 0.26);
                thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                thud.connect(thudGain);
                thudGain.connect(panner);
                thud.start(now + 0.25);
                thud.stop(now + 0.41);
                
                // Very subtle ground rumble (optional)
                const boom = audioCtx.createOscillator();
                const boomGain = audioCtx.createGain();
                boom.type = 'sine';
                boom.frequency.setValueAtTime(60, now + 0.3);
                boom.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                boomGain.gain.setValueAtTime(0.04, now + 0.3);
                boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                boom.connect(boomGain);
                boomGain.connect(panner);
                boom.start(now + 0.3);
                boom.stop(now + 0.5);
            },

            playAlertTone(x = canvas.width / 2, y = canvas.height / 2) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                if (now - audioCooldowns.lastAlert < 0.25) return;
                audioCooldowns.lastAlert = now;

                const panner = createSpatialSound(x, y, audioChannels.events);
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.value = 800;
                osc2.frequency.value = 600;
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(panner);
                osc1.start(now);
                osc2.start(now + 0.15);
                osc1.stop(now + 0.4);
                osc2.stop(now + 0.35);
            },

            playKeyTurnSequence(x = canvas.width / 2, y = canvas.height / 2) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Analog key turning: two low tones (check check) then one high tone (trigger)
                // Low tone 1 - CHECK
                const check1 = audioCtx.createOscillator();
                const check1Gain = audioCtx.createGain();
                check1.type = 'sine';
                check1.frequency.value = 300;
                check1Gain.gain.setValueAtTime(0.15, now);
                check1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                check1.connect(check1Gain);
                check1Gain.connect(panner);
                check1.start(now);
                check1.stop(now + 0.15);
                
                // Low tone 2 - CHECK
                const check2 = audioCtx.createOscillator();
                const check2Gain = audioCtx.createGain();
                check2.type = 'sine';
                check2.frequency.value = 300;
                check2Gain.gain.setValueAtTime(0.15, now + 0.2);
                check2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                check2.connect(check2Gain);
                check2Gain.connect(panner);
                check2.start(now + 0.2);
                check2.stop(now + 0.35);
                
                // High tone - TRIGGER
                const trigger = audioCtx.createOscillator();
                const triggerGain = audioCtx.createGain();
                trigger.type = 'sine';
                trigger.frequency.value = 800;
                triggerGain.gain.setValueAtTime(0.2, now + 0.5);
                triggerGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                trigger.connect(triggerGain);
                triggerGain.connect(panner);
                trigger.start(now + 0.5);
                trigger.stop(now + 0.8);
            },

            playCountdownBeep(x, y, pitch = 600, volume = 0.2) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                const beep = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                beep.type = 'sine';
                beep.frequency.value = pitch;
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                beep.connect(gain);
                gain.connect(panner);
                beep.start(now);
                beep.stop(now + 0.1);
            },

            playHeartbeat(x, y, rate = 1.0, intensity = 1.0) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Double thump (lub-dub)
                const beat1 = audioCtx.createOscillator();
                const beat2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                beat1.type = 'sine';
                beat2.type = 'sine';
                beat1.frequency.value = 60 + (intensity * 40); // 60-100Hz based on intensity
                beat2.frequency.value = 50 + (intensity * 30);
                
                // First thump (lub)
                gain.gain.setValueAtTime(0.15 * intensity, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                
                beat1.connect(gain);
                gain.connect(panner);
                beat1.start(now);
                beat1.stop(now + 0.08);
                
                // Second thump (dub)
                const gain2 = audioCtx.createGain();
                gain2.gain.setValueAtTime(0.12 * intensity, now + 0.12);
                gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                
                beat2.connect(gain2);
                gain2.connect(panner);
                beat2.start(now + 0.12);
                beat2.stop(now + 0.18);
            },

            playAngelScream(x, y, intensity = 1.0) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // RAMIEL-STYLE GEOMETRIC LASER SCREAM - sharp, electronic, otherworldly
                const duration = 0.18 + (intensity * 0.12); // 0.18-0.3 seconds
                
                // Primary laser tone - pure sine wave that warbles
                const laser1 = audioCtx.createOscillator();
                const laser2 = audioCtx.createOscillator();
                const laser3 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                laser1.type = 'sine'; // Pure geometric tone
                laser2.type = 'sine';
                laser3.type = 'square'; // Add slight metallic edge
                
                // RAMIEL FREQUENCY: High-pitched geometric warble (2500-3500Hz range)
                const baseFreq = 2500 + (intensity * 1000);
                
                // Main laser frequency - rapid warble up and down
                laser1.frequency.setValueAtTime(baseFreq, now);
                laser1.frequency.linearRampToValueAtTime(baseFreq * 1.15, now + duration * 0.3);
                laser1.frequency.linearRampToValueAtTime(baseFreq * 0.95, now + duration * 0.6);
                laser1.frequency.linearRampToValueAtTime(baseFreq * 1.08, now + duration);
                
                // Harmonics for geometric quality
                laser2.frequency.setValueAtTime(baseFreq * 1.5, now); // Perfect fifth
                laser2.frequency.linearRampToValueAtTime(baseFreq * 1.65, now + duration * 0.5);
                laser2.frequency.linearRampToValueAtTime(baseFreq * 1.55, now + duration);
                
                laser3.frequency.setValueAtTime(baseFreq * 2.0, now); // Octave
                laser3.frequency.linearRampToValueAtTime(baseFreq * 2.2, now + duration);
                
                // Sharp attack, quick decay - laser-like
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.11 * intensity, now + 0.01); // Instant attack to peak
                gain.gain.linearRampToValueAtTime(0.08 * intensity, now + duration * 0.15); // Quick drop after peak
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration); // Fade out
                
                laser1.connect(gain);
                laser2.connect(gain);
                laser3.connect(gain);
                gain.connect(panner);
                
                laser1.start(now);
                laser2.start(now);
                laser3.start(now);
                laser1.stop(now + duration);
                laser2.stop(now + duration);
                laser3.stop(now + duration);
            },

            playEVARoar(x, y, intensity = 1.0) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // BERSERK EVA ROAR - feral but brief, dramatic without being overwhelming
                const duration = 0.35; // Shorter, punchier roar
                
                const roar1 = audioCtx.createOscillator();
                const roar2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                roar1.type = 'sawtooth'; // Harsh, aggressive
                roar2.type = 'triangle'; // Body
                
                // FERAL FREQUENCIES: Primal roar (180-350Hz range)
                const baseFreq = 180 + (intensity * 100);
                
                // Main roar - quick rise and fall
                roar1.frequency.setValueAtTime(baseFreq, now);
                roar1.frequency.exponentialRampToValueAtTime(baseFreq * 1.8, now + duration * 0.3);
                roar1.frequency.exponentialRampToValueAtTime(baseFreq * 1.1, now + duration);
                
                // Harmonic body - smoother
                roar2.frequency.setValueAtTime(baseFreq * 1.3, now);
                roar2.frequency.exponentialRampToValueAtTime(baseFreq * 2.0, now + duration * 0.4);
                roar2.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, now + duration);
                
                // Quick dramatic punch without sustained intensity
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.08 * intensity, now + 0.02); // Fast attack to peak
                gain.gain.linearRampToValueAtTime(0.06 * intensity, now + 0.10); // Brief sustain
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration); // Quick fade
                
                roar1.connect(gain);
                roar2.connect(gain);
                gain.connect(panner);
                
                roar1.start(now);
                roar2.start(now);
                roar1.stop(now + duration);
                roar2.stop(now + duration);
            },

            playTensionSiren(x = canvas.width / 2, y = canvas.height / 2) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // NERV-style pulsing alarm that builds tension
                const pulse = audioCtx.createOscillator();
                const pulseGain = audioCtx.createGain();

                pulse.type = 'sine';
                // Constant mid-frequency alarm tone
                pulse.frequency.setValueAtTime(520, now);
                
                // Fade in
                pulseGain.gain.setValueAtTime(0, now);
                pulseGain.gain.linearRampToValueAtTime(0.05, now + 0.05);
                
                // Pulsing pattern that builds in intensity (NERV-style)
                // First pulse
                pulseGain.gain.setValueAtTime(0.05, now + 0.05);
                pulseGain.gain.linearRampToValueAtTime(0.09, now + 0.15);
                pulseGain.gain.linearRampToValueAtTime(0.03, now + 0.3);
                
                // Second pulse - stronger
                pulseGain.gain.linearRampToValueAtTime(0.11, now + 0.45);
                pulseGain.gain.linearRampToValueAtTime(0.03, now + 0.6);
                
                // Third pulse - strongest
                pulseGain.gain.linearRampToValueAtTime(0.13, now + 0.75);
                pulseGain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

                pulse.connect(pulseGain);
                pulseGain.connect(panner);
                pulse.start(now);
                pulse.stop(now + 1.01);
            },

            playSuperweaponDeploy(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Ascending power-up with harmonic layers
                const fundamental = audioCtx.createOscillator();
                const harmonic = audioCtx.createOscillator();
                const deployGain = audioCtx.createGain();

                fundamental.type = 'sine';
                harmonic.type = 'sine';
                
                // Rising power chord (C3 -> C4, octave)
                fundamental.frequency.setValueAtTime(130, now);
                fundamental.frequency.exponentialRampToValueAtTime(260, now + 1.5);
                
                // Fifth above (G3 -> G4)
                harmonic.frequency.setValueAtTime(196, now);
                harmonic.frequency.exponentialRampToValueAtTime(392, now + 1.5);
                
                // Build intensity then fade
                deployGain.gain.setValueAtTime(0, now);
                deployGain.gain.linearRampToValueAtTime(0.08, now + 0.3);
                deployGain.gain.linearRampToValueAtTime(0.12, now + 1.0);
                deployGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

                fundamental.connect(deployGain);
                harmonic.connect(deployGain);
                deployGain.connect(panner);
                fundamental.start(now);
                harmonic.start(now);
                fundamental.stop(now + 1.51);
                harmonic.stop(now + 1.51);
            },

            playCapture(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                if (now - audioCooldowns.lastCapture < 1.5) return; // 1.5s cooldown - allows hearing captures without spam
                audioCooldowns.lastCapture = now;
                
                // Distinctive capture sound - rising chime
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Two-tone chime (major third interval)
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain1 = audioCtx.createGain();
                const gain2 = audioCtx.createGain();
                
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.value = 520; // C5
                osc2.frequency.value = 659; // E5 (major third up)
                
                // First tone
                gain1.gain.setValueAtTime(0, now);
                gain1.gain.linearRampToValueAtTime(0.15, now + 0.02);
                gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                
                // Second tone (slightly delayed)
                gain2.gain.setValueAtTime(0, now);
                gain2.gain.setValueAtTime(0, now + 0.08);
                gain2.gain.linearRampToValueAtTime(0.12, now + 0.1);
                gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc1.connect(gain1);
                osc2.connect(gain2);
                gain1.connect(panner);
                gain2.connect(panner);
                
                osc1.start(now);
                osc2.start(now + 0.08);
                osc1.stop(now + 0.26);
                osc2.stop(now + 0.31);
            },

            playCapitalMove(x, y, isUpgrade = false) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                
                // Prevent spam - only play once every 5 seconds
                if (now - audioCooldowns.lastEvacuationAlert < 5.0) return;
                audioCooldowns.lastEvacuationAlert = now;
                
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Deep horn/bell tone - ceremonial and weighty
                const horn = audioCtx.createOscillator();
                const hornGain = audioCtx.createGain();
                
                horn.type = 'sine';
                
                if (isUpgrade) {
                    // Rising tone for promotion (110Hz -> 130Hz, minor third)
                    horn.frequency.setValueAtTime(110, now);
                    horn.frequency.linearRampToValueAtTime(130, now + 0.8);
                } else {
                    // Falling tone for retreat (130Hz -> 110Hz)
                    horn.frequency.setValueAtTime(130, now);
                    horn.frequency.linearRampToValueAtTime(110, now + 0.8);
                }
                
                // Smooth fade in/out to prevent clicks
                hornGain.gain.setValueAtTime(0, now);
                hornGain.gain.linearRampToValueAtTime(0.12, now + 0.1);
                hornGain.gain.setValueAtTime(0.12, now + 0.6);
                hornGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                horn.connect(hornGain);
                hornGain.connect(panner);
                horn.start(now);
                horn.stop(now + 0.81);
            },

            playVictory(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                
                // Prevent spam - only play once every 2 seconds
                if (now - audioCooldowns.lastVictory < 2.0) return;
                audioCooldowns.lastVictory = now;
                
                const panner = createSpatialSound(x, y, audioChannels.events);
                
                // Triumphant fanfare - rising chord (major triad)
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.type = 'sine';
                bass.frequency.setValueAtTime(220, now); // A3
                bassGain.gain.setValueAtTime(0, now);
                bassGain.gain.linearRampToValueAtTime(0.08, now + 0.05);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                bass.connect(bassGain);
                bassGain.connect(panner);
                
                const third = audioCtx.createOscillator();
                const thirdGain = audioCtx.createGain();
                third.type = 'sine';
                third.frequency.setValueAtTime(277, now); // C#4 (major third)
                thirdGain.gain.setValueAtTime(0, now);
                thirdGain.gain.linearRampToValueAtTime(0.06, now + 0.05);
                thirdGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                third.connect(thirdGain);
                thirdGain.connect(panner);
                
                const fifth = audioCtx.createOscillator();
                const fifthGain = audioCtx.createGain();
                fifth.type = 'sine';
                fifth.frequency.setValueAtTime(330, now); // E4 (perfect fifth)
                fifthGain.gain.setValueAtTime(0, now);
                fifthGain.gain.linearRampToValueAtTime(0.06, now + 0.05);
                fifthGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                fifth.connect(fifthGain);
                fifthGain.connect(panner);
                
                bass.start(now);
                bass.stop(now + 0.61);
                third.start(now);
                third.stop(now + 0.61);
                fifth.start(now);
                fifth.stop(now + 0.61);
            },

            playClick() {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.value = 600;
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.connect(gain);
                gain.connect(audioChannels.ui);
                osc.start(now);
                osc.stop(now + 0.05);
            },

            playDeath(x, y) {
                if (!audioCtx || audioCtx.state !== 'running' || !this.enabled) return;
                const now = audioCtx.currentTime;
                
                const panner = createSpatialSound(x, y, audioChannels.combat);
                
                // Death sound - downward sweep with noise
                const death = audioCtx.createOscillator();
                const deathGain = audioCtx.createGain();
                death.type = 'triangle';
                death.frequency.setValueAtTime(400, now);
                death.frequency.exponentialRampToValueAtTime(80, now + 0.25);
                deathGain.gain.setValueAtTime(0.15, now);
                deathGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                death.connect(deathGain);
                deathGain.connect(panner);
                death.start(now);
                death.stop(now + 0.25);
            },

            updateAmbience(intensity) {
                this.battleIntensity = intensity;
            },

            announce(text, priority = 'normal', nationId = null) {
                if (!window.speechSynthesis) return;
                if (!audioCtx) initAudioContext();
                if (audioCtx && !this.enabled) return;

                // Filter out announcements from nations not in this game or dead nations
                if (typeof nationId === 'number' && nationId >= 0) {
                    // Check if nation is actually playing (in the spawned nations array)
                    if (nationId >= nations.length || !nations[nationId]) {
                        console.log(`[SPEECH SKIP] Nation ${nationId} not in this game: "${text}"`);
                        return; // Nation not spawned in this game
                    }
                    // Check if nation is dead
                    if (nations[nationId].capitulated) {
                        console.log(`[SPEECH SKIP] Dead nation ${nationId}: "${text}"`);
                        return; // Dead nations can't speak
                    }
                }

                // Enhanced text preprocessing with pronunciation and pacing
                let spokenText = text
                    // Nation name pronunciations
                    .replace(/NERVAR/gi, 'Nervar')
                    .replace(/ZELUS/gi, 'Zeelus')
                    .replace(/VALKYRY/gi, 'Valkeery')
                    .replace(/PRAXEN/gi, 'Praxen')
                    .replace(/SOLARIS/gi, 'Solaris')
                    .replace(/BARONIX/gi, 'Baronix')
                    .replace(/ATRION/gi, 'Atreeon')
                    .replace(/TORGUILD/gi, 'Tor-guild')
                    .replace(/BENEDICTA/gi, 'Benedicta')
                    .replace(/VYRAX/gi, 'Vyrax')
                    .replace(/LANGWAYS/gi, 'Langways')
                    .replace(/OMNISCENE/gi, 'Omni-seen')
                    .replace(/CYBRYNE/gi, 'Sigh-brine')
                    .replace(/VOLUX/gi, 'Volux')
                    .replace(/TYRANEL/gi, 'Teeranel')
                    .replace(/HEGEMYR/gi, 'Hegemyr');

                // Check for duplicates in all queues
                const isDuplicate = announcerState.priorityQueue.some(item => item.text === spokenText) ||
                                   announcerState.normalQueue.some(item => item.text === spokenText) ||
                                   announcerState.currentSpeaking === spokenText;
                if (isDuplicate) return;

                // Determine if this is a superweapon announcement
                const isSuperweapon = text.includes('deploys') || 
                                     text.includes('engaging') || 
                                     text.includes('detonated') ||
                                     text.includes('Pattern ') ||
                                     text.includes('destroys') && text.includes('capital core');

                // ANTI-SPAM: Per-nation cooldown (prevent same nation announcing too frequently)
                // Longer cooldown to reduce spam
                if (!isSuperweapon && typeof nationId === 'number' && nationId >= 0) {
                    if (!announcerState.nationCooldowns) announcerState.nationCooldowns = {};
                    
                    const now = performance.now();
                    const lastAnnounceTime = announcerState.nationCooldowns[nationId] || 0;
                    const timeSinceLastAnnounce = now - lastAnnounceTime;
                    
                    if (timeSinceLastAnnounce < 8000) { // 8 second cooldown (increased from 3)
                        console.log(`[SPEECH COOLDOWN] Skipping "${spokenText}" (nation ${nationId} on cooldown)`);
                        return;
                    }
                    
                    // Update cooldown timer
                    announcerState.nationCooldowns[nationId] = now;
                }
                
                // GLOBAL RATE LIMITING: Minimum 1 second between ANY announcements
                if (!announcerState.lastGlobalAnnounce) announcerState.lastGlobalAnnounce = 0;
                const timeSinceLastGlobal = performance.now() - announcerState.lastGlobalAnnounce;
                if (!isSuperweapon && timeSinceLastGlobal < 1000) {
                    console.log(`[SPEECH COOLDOWN] Skipping "${spokenText}" (global rate limit)`);
                    return;
                }
                announcerState.lastGlobalAnnounce = performance.now();

                // Create announcement object with voice info
                const announcement = {
                    text: spokenText,
                    nationId: nationId,
                    voice: nationId !== null && nations[nationId] ? nations[nationId].voice : null
                };

                // Add to appropriate queue
                if (isSuperweapon) {
                    announcerState.priorityQueue.push(announcement);
                    console.log(`[SPEECH PRIORITY] ${spokenText}`);
                } else {
                    // Limit normal queue to 3 items to prevent outdated announcements
                    if (announcerState.normalQueue.length < 3) {
                        announcerState.normalQueue.push(announcement);
                        console.log(`[SPEECH NORMAL] ${spokenText}`);
                    }
                }

                // Process queue if not currently speaking
                this.processAnnouncementQueue();
            },

            processAnnouncementQueue() {
                if (window.speechSynthesis.speaking || announcerState.currentSpeaking) return;

                // Priority queue first, then normal queue
                let nextAnnouncement = null;
                if (announcerState.priorityQueue.length > 0) {
                    nextAnnouncement = announcerState.priorityQueue.shift();
                } else if (announcerState.normalQueue.length > 0) {
                    nextAnnouncement = announcerState.normalQueue.shift();
                }

                if (!nextAnnouncement) return;

                // Handle both old string format and new object format
                const announcementText = typeof nextAnnouncement === 'string' ? nextAnnouncement : nextAnnouncement.text;
                const nationId = typeof nextAnnouncement === 'object' ? nextAnnouncement.nationId : null;
                const voiceSettings = typeof nextAnnouncement === 'object' ? nextAnnouncement.voice : null;

                // Re-check capitulation status - skip if nation died while announcement was queued
                if (typeof nationId === 'number' && nationId >= 0) {
                    // Check if nation is actually in this game
                    if (nationId >= nations.length || !nations[nationId]) {
                        console.log(`[SPEECH SKIP] Nation ${nationId} not playing in this game: "${announcementText}"`);
                        // Process next item in queue
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                        return;
                    }
                    // Check if nation died
                    if (nations[nationId].capitulated) {
                        console.log(`[SPEECH SKIP] Dead nation ${nationId} announcement filtered: "${announcementText}"`);
                        // Process next item in queue
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                        return;
                    }
                }

                announcerState.currentSpeaking = announcementText;
                announcerState.lastAnnouncement = Date.now();

                // Get available voices (use quality voices first)
                const voices = qualityVoices.length > 0 ? qualityVoices : 
                              (cachedVoices.length > 0 ? cachedVoices : window.speechSynthesis.getVoices());

                // All speech uses nation voice directly (no announcer intro)
                // Extra safety check: nation must be in this game and not capitulated
                if (nationId !== null && voiceSettings && nationId < nations.length && nations[nationId] && !nations[nationId].capitulated) {
                    const utterance = new SpeechSynthesisUtterance(announcementText);
                    
                    // Enhanced voice characteristics based on nation
                    const nation = nations[nationId];
                    const templateIdx = nation.templateIndex || nationId;
                    const isSuperweaponAnnouncement = announcementText.includes('...') || 
                                                     announcementText.includes('!');
                    
                    // Dynamic voice modulation
                    utterance.rate = isSuperweaponAnnouncement ? 
                                    voiceSettings.rate * 0.85 : voiceSettings.rate; // Slower for drama
                    utterance.pitch = voiceSettings.pitch;
                    utterance.volume = 1.0;
                    
                    // Select best available voice for this nation
                    if (voices.length > 1) {
                        // Try to get diverse voices for different nations
                        let voiceIndex = (templateIdx * 3) % voices.length; // Better distribution
                        
                        // Prefer certain voice types for character
                        const maleVoices = voices.filter(v => v.name.includes('Male') || v.name.includes('David') || v.name.includes('Mark'));
                        const femaleVoices = voices.filter(v => v.name.includes('Female') || v.name.includes('Zira') || v.name.includes('Susan'));
                        
                        if (templateIdx % 2 === 0 && maleVoices.length > 0) {
                            utterance.voice = maleVoices[Math.floor(templateIdx / 2) % maleVoices.length];
                        } else if (femaleVoices.length > 0) {
                            utterance.voice = femaleVoices[Math.floor(templateIdx / 2) % femaleVoices.length];
                        } else {
                            utterance.voice = voices[voiceIndex];
                        }
                    }
                    
                    utterance.onend = () => {
                        announcerState.currentSpeaking = null;
                        announcerState.lastSpeaker = nationId;
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                    };
                    
                    utterance.onerror = () => {
                        announcerState.currentSpeaking = null;
                        announcerState.lastSpeaker = nationId;
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                    };
                    
                    setTimeout(() => {
                        window.speechSynthesis.speak(utterance);
                    }, 50);
                } else {
                    // Generic announcer voice - use best quality available
                    const utterance = new SpeechSynthesisUtterance(announcementText);
                    utterance.rate = 0.95; // Slightly slower for clarity
                    utterance.pitch = 0.85; // Lower pitch for authority
                    utterance.volume = 1.0;
                    
                    if (voices.length > 0) {
                        // Prefer deep male voice for generic announcer
                        const deepVoice = voices.find(v => 
                            v.name.includes('David') || 
                            v.name.includes('Mark') ||
                            (v.name.includes('Male') && v.lang.includes('en'))
                        );
                        utterance.voice = deepVoice || voices[0];
                    }

                    utterance.onend = () => {
                        announcerState.currentSpeaking = null;
                        announcerState.lastSpeaker = null;
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                    };

                    utterance.onerror = () => {
                        announcerState.currentSpeaking = null;
                        announcerState.lastSpeaker = null;
                        setTimeout(() => this.processAnnouncementQueue(), 50);
                    };

                    window.speechSynthesis.speak(utterance);
                }
            }
        };

        // Resume audio context on user interaction (browser requirement)
        let audioInitialized = false;
        
        // Announcer tracking to prevent spam
        const announcerState = {
            lastMassiveBattle: 0,
            lastDominanceAnnounce: 0,
            lastComeback: 0,
            lastStalemate: 0,
            lastAnnouncement: 0, // Track last announcement for flavor timing
            lastFlavor: 0, // Track last flavor announcement
            lastShitTalk: 0, // Track last trash talk
            lastCapitalCapture: 0, // Track capital capture announcements
            lastSuperweaponBattle: 0, // Track superweapon battle announcements
            lastSuperweaponDeploy: 0, // Track superweapon deployment announcements
            lastEstablishment: 0, // Track node establishment announcements
            gameStartTime: 0, // Track when game started for intro sequence
            pendingAnnouncements: [], // Track queued announcements to prevent duplicates
            priorityQueue: [], // Superweapon announcements that jump the queue
            normalQueue: [], // Normal announcements
            currentSpeaking: null, // What's currently being spoken
            lastSpeaker: null // Track last nation that spoke to avoid repeating intro
        };
        
        // GAME EVENT LOG - track major events for review
        const gameEventLog = [];
        let lastLogUpdate = 0;
        
        function logGameEvent(type, message, priority = 'normal') {
            const gameTime = game.startTime ? ((performance.now() - game.startTime) / 1000).toFixed(1) : '0.0';
            gameEventLog.push({
                time: gameTime,
                type: type,
                message: message,
                priority: priority,
                timestamp: Date.now()
            });
            
            // Keep only last 100 events
            if (gameEventLog.length > 100) {
                gameEventLog.shift();
            }
            
            // Print summary every 30 seconds
            const now = performance.now();
            if (now - lastLogUpdate > 30000) {
                lastLogUpdate = now;
                console.log('\n=== GAME LOG (Last 30s) ===');
                const recentEvents = gameEventLog.filter(e => now - e.timestamp < 30000);
                if (recentEvents.length === 0) {
                    console.log('No major events');
                } else {
                    recentEvents.forEach(e => {
                        console.log(`[${e.time}s] ${e.type.toUpperCase()}: ${e.message}`);
                    });
                }
                console.log('========================\n');
            }
        }
        
        const initAudio = () => {
            if (audioInitialized) return;
            
            initAudioContext(); // Create the context
            
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    Audio.enabled = true;
                    audioInitialized = true;
                    console.log('Audio enabled');
                });
            } else if (audioCtx) {
                Audio.enabled = true;
                audioInitialized = true;
                console.log('Audio enabled');
            }
        };
        
        // Handle game start on first click
        const startGame = () => {
            console.log('startGame called, hasStarted:', game.hasStarted, 'paused:', game.paused);
            if (!game.hasStarted) {
                initAudio(); // Enable audio
                game.hasStarted = true;
                game.paused = false;
                console.log('Game unpaused - paused is now:', game.paused);
                game.startTime = performance.now(); // Record actual start time for missile delay
                
                // Clear any pending announcements first
                announcerState.priorityQueue = [];
                announcerState.normalQueue = [];
                announcerState.gameStartTime = Date.now(); // Track game start for intro sequence
                
                // Announce welcome IMMEDIATELY before anything else
                const welcomeMessages = [
                    'Welcome to the Frontier',
                    'The battle begins',
                    'War has come to the Frontier',
                    'Nations clash for supremacy',
                    'Let the conquest begin'
                ];
                Audio.announce(welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)], 'high');
                
                // Queue introductory flavor announcements (20-40 seconds after start)
                setTimeout(() => {
                    const introFlavor = [
                        'Multiple factions vying for control',
                        'Strategic positions are being established',
                        'Skirmishes reported across the frontier',
                        'Nations meet on the field of battle',
                        'Control points are being contested',
                        'The balance of power remains uncertain'
                    ];
                    if (!game.over) {
                        Audio.announce(introFlavor[Math.floor(Math.random() * introFlavor.length)], 'low');
                    }
                }, 20000 + Math.random() * 20000);
            }
        };
        
        // Try to enable audio on any user interaction (once only)
        ['click', 'keydown', 'touchstart'].forEach(event => {
            document.addEventListener(event, startGame, { once: true });
        });
        
        // 5x larger world space that scales to fit
        const WORLD_SCALE = 1;
        const NODE_FLIP_LIMIT = 8; // Max flips before node destruction
        
        // Resize canvas to window size
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Node class for cities and economic centers
        // Cryptic node names with strategic abilities (unique per map)
        const crypticNames = [
            { name: 'Nexus', buff: 'Movement Hub', effect: 'Units move 30% faster through this node' },
            { name: 'Citadel', buff: 'Fortified', effect: '+40% defense, takes longer to capture' },
            { name: 'Bastion', buff: 'Stronghold', effect: '+60% defense, heavily fortified' },
            { name: 'Apex', buff: 'Production', effect: 'Spawns units 25% faster' },
            { name: 'Zenith', buff: 'Vision', effect: 'Units see 50% farther from this node' },
            { name: 'Haven', buff: 'Recovery', effect: 'Units heal and lose fatigue faster here' },
            { name: 'Forge', buff: 'Efficiency', effect: 'Units cost 20% less resources to produce' },
            { name: 'Vault', buff: 'Treasury', effect: '+30% resource income from this node' },
            { name: 'Sanctum', buff: 'Stability', effect: 'Immune to fatigue penalties' },
            { name: 'Pinnacle', buff: 'Elite Training', effect: 'Units spawn with +25% strength' },
            { name: 'Keep', buff: 'Resistance', effect: 'Capture progress decays 50% slower' },
            { name: 'Spire', buff: 'Watchtower', effect: 'Reveals enemy movements in wide radius' },
            { name: 'Redoubt', buff: 'Bulwark', effect: 'Cannot be captured while owner has 3+ units nearby' },
            { name: 'Archive', buff: 'Intelligence', effect: 'Owner sees enemy unit destinations' },
            { name: 'Monument', buff: 'Morale', effect: 'All friendly units within 300 units gain +15% strength' },
            { name: 'Crucible', buff: 'Veteran Training', effect: 'Units gain experience 40% faster' }
        ];
        let usedCrypticNames = []; // Track used names to prevent duplicates
        
        class Node {
            constructor(x, y, isCapital = false) {
                this.x = x;
                this.y = y;
                this.isCapital = isCapital;
                this.owner = -1; // -1 = neutral
                this.controlStrength = 0;
                this.productionTimer = 0;
                this.productionRate = isCapital ? 6.0 : 10.0; // seconds per unit (faster for more action)
                this.capturingNation = -1; // Only one nation can have progress
                this.captureProgress = 0; // Single progress value
                
                // Economic properties
                // Tier: 0=poor, 1=normal, 2=rich, 3=capital
                this.economicTier = isCapital ? 3 : Math.floor(Math.random() * 3);
                // Multiplier: Poor 0.5x, Normal 1.0x, Rich 1.5x, Capital 2.5x
                const tierMultipliers = [0.5, 1.0, 1.5, 2.5];
                this.resourceMultiplier = tierMultipliers[this.economicTier];
                
                // Cryptic identity for strategic/valuable nodes
                this.crypticName = null;
                this.crypticData = null; // Store the full name/buff/effect data
                this.crypticEligible = false; // Track if node qualifies for cryptic upgrade
                this.timeHeld = 0; // Time in seconds under stable ownership
                // Randomize threshold so nodes don't all upgrade at once (90-180 seconds)
                this.crypticUpgradeThreshold = 90 + Math.random() * 90;
                
                // INVENTORY SYSTEM: Store artifacts/items at this node
                this.inventory = []; // Array of artifact references or artifact IDs
                
                // Capitals get cryptic names immediately
                if (isCapital) {
                    // Assign unique name from available pool
                    const availableNames = crypticNames.filter(cn => !usedCrypticNames.includes(cn.name));
                    if (availableNames.length > 0) {
                        const nameData = availableNames[Math.floor(Math.random() * availableNames.length)];
                        this.crypticName = nameData.name;
                        this.crypticData = nameData;
                        usedCrypticNames.push(nameData.name);
                    }
                } else if (this.economicTier >= 2) {
                    // High-tier nodes are eligible but must earn it through stability
                    this.crypticEligible = true;
                }
                
                // Fatigue system - tracks how much the node has been contested/flipped
                this.fatigue = 0; // 0-100, at 100 node breaks
                this.lastOwner = -1; // Track previous owner for flip-flop detection
                this.flipCount = 0; // How many times control has changed
                
                // Construction system - for new spawned nodes
                this.isBuilding = false;
                this.buildTimer = 0;
                this.buildTime = 8.0; // Takes 8 seconds to build a new node
            }
            
            update(dt, nations, resistanceIntensityMap = {}) {
                // Check nearby units for capture
                const captureRadius = 40;
                const nationPresence = {};
                
                nations.forEach(nation => {
                    // Allow capitulated nations with units to capture (resistance fighters)
                    if (nation.units.length === 0) return;
                    
                    let count = 0;
                    nation.units.forEach(unit => {
                        const dx = unit.x - this.x;
                        const dy = unit.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        // COUNT ALL UNITS WITHIN RADIUS - terrain doesn't matter for capture
                        // Units on rough terrain or rivers can still capture nodes
                        if (dist < captureRadius) count++;
                    });
                    if (count > 0) nationPresence[nation.id] = count;
                });
                
                // Determine dominant nation
                let maxPresence = 0;
                let dominantNation = -1;
                for (let [nationId, presence] of Object.entries(nationPresence)) {
                    if (presence > maxPresence) {
                        maxPresence = presence;
                        dominantNation = parseInt(nationId);
                    }
                }
                
                // Capture logic - only one nation can have progress at a time
                // CHECK DIPLOMATIC RELATIONS - allies cannot capture each other's nodes
                const canCapture = (attackerNationId, defenderNationId) => {
                    if (attackerNationId === defenderNationId) return false;
                    if (defenderNationId < 0) return true; // Can always capture neutral nodes
                    
                    const attackerNation = nations[attackerNationId];
                    if (!attackerNation) return false; // Safety check
                    
                    // If no diplomacy system exists at all, default to allowing capture (early game)
                    if (!attackerNation.diplomaticRelations) return true;
                    
                    const stance = attackerNation.diplomaticRelations[defenderNationId];
                    
                    // If stance is undefined (nations haven't met), default to hostile
                    if (stance === undefined) return true;
                    
                    // Can ONLY capture if at WAR
                    // Cannot capture: NEUTRAL, ALLIED, TRADE, NON_AGGRESSION, TRIBUTARY
                    return stance === DIPLOMATIC_STANCE.WAR;
                };
                
                if (dominantNation >= 0 && dominantNation !== this.owner && canCapture(dominantNation, this.owner)) {
                    const captureThreshold = this.isCapital ? 36 : 30;
                    
                    // DEFENSIVE BUFFS: Citadel (+40% defense), Bastion (+60% defense)
                    let defensiveMultiplier = 1.0;
                    if (this.crypticName === 'Citadel') defensiveMultiplier = 1.4;
                    if (this.crypticName === 'Bastion') defensiveMultiplier = 1.6;
                    const adjustedThreshold = captureThreshold * defensiveMultiplier;
                    
                    // REDOUBT buff: Heavily fortified - deals damage to nearby enemies and resists capture
                    let redoubtProtected = false;
                    if (this.crypticName === 'Redoubt' && this.owner >= 0) {
                        const nearbyFriendlies = getNearbyUnits(this.x, this.y, 150)
                            .filter(u => u.nation === this.owner).length;
                        const nearbyEnemies = getNearbyUnits(this.x, this.y, 150)
                            .filter(u => u.nation !== this.owner);
                        
                        redoubtProtected = nearbyFriendlies >= 3;
                        
                        // REDOUBT DEFENSE: Deals heavy damage to all nearby enemy units (siege warfare)
                        // Fortifications kill attackers - they must overwhelm with numbers
                        nearbyEnemies.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < 150) {
                                // Damage scales with proximity - deadliest at the walls
                                const proximityFactor = 1.0 - (dist / 150);
                                const redoubtDamage = 25 * dt * proximityFactor; // Heavy continuous damage
                                enemy.health -= redoubtDamage;
                                
                                // Reduce morale - attacking fortifications is terrifying
                                if (enemy.morale !== undefined) {
                                    enemy.morale = Math.max(0, enemy.morale - dt * 0.2);
                                }
                            }
                        });
                    }
                    
                    // CONTESTED CAPTURE MECHANICS
                    if (this.capturingNation === -1 || this.capturingNation === dominantNation) {
                        // No one capturing or same nation - increase progress
                        // Redoubt prevents capture if protected
                        if (redoubtProtected && dominantNation !== this.owner) {
                            // Redoubt protection active - no capture progress
                        } else {
                            // Speed scales with number of units present (more units = faster capture)
                            this.capturingNation = dominantNation;
                            const bonuses = getArtifactBonuses(dominantNation);
                            this.captureProgress += dt * maxPresence * 1.5 * bonuses.nodeCapture; // Artifact bonus speeds capture
                        }
                    } else if (this.capturingNation !== dominantNation) {
                        // DIFFERENT NATION IS DOMINANT - Contest the capture!
                        // Degrade enemy progress based on unit superiority
                        const degradeRate = dt * maxPresence * 2.0; // Faster than capture rate - attackers have advantage
                        this.captureProgress = Math.max(0, this.captureProgress - degradeRate);
                        
                        // Once progress hits 0, reset and let new nation start capturing
                        if (this.captureProgress <= 0) {
                            this.capturingNation = -1;
                            this.captureProgress = 0;
                        }
                    }
                    
                    // Continue original self-destruct logic only if actually capturing
                    if (this.capturingNation === dominantNation) {
                        // Speed scales with number of units present (more units = faster capture)
                        if (false) { // Dummy condition to maintain structure
                            const bonuses = getArtifactBonuses(dominantNation);
                            this.captureProgress += dt * maxPresence * 1.5 * bonuses.nodeCapture; // Already done above
                            
                            // CAPITAL SELF-DESTRUCT: If nation has no units and capital is being captured, start countdown
                            if (this.isCapital && this.owner >= 0) {
                                const ownerNation = nations[this.owner];
                                const hasUnits = ownerNation.units && ownerNation.units.length > 0;
                                const isBeingCaptured = this.capturingNation >= 0 && this.capturingNation !== this.owner;
                                
                                // Don't self-destruct if just resurrected (resurrection immunity)
                                const isJustResurrected = ownerNation.resurrectionImmunity > 0;
                                
                                // Initialize cooldown tracking
                                if (!ownerNation.selfDestructCooldown) ownerNation.selfDestructCooldown = 0;
                                
                                // Decrement cooldown
                                if (ownerNation.selfDestructCooldown > 0) {
                                    ownerNation.selfDestructCooldown -= dt;
                                }
                                
                                // Track if we're in critical state (would trigger self-destruct)
                                const criticalState = !hasUnits && isBeingCaptured && !isJustResurrected && ownerNation.selfDestructCooldown <= 0;
                                
                                if (criticalState) {
                                    // Initialize self-destruct countdown - IRREVERSIBLE!
                                    if (!this.selfDestructTimer) {
                                        this.selfDestructTimer = 5.0; // 5 second countdown
                                        this.selfDestructAnnounced = false;
                                        this.selfDestructCommenced = false;
                                        this.wasCritical = true; // Mark that we entered critical state
                                        Audio.playSelfDestruct(this.x, this.y); // Distinctive alarm
                                    }
                                    
                                    this.selfDestructTimer -= dt;
                                    
                                    // Announce self-destruct initiation ONCE at start
                                    if (!this.selfDestructAnnounced && this.selfDestructTimer < 5.0) {
                                        if (!ownerNation.capitulated) {
                                            Audio.announce(`${ownerNation.name} capital self-destruct initiated - 5 seconds`, 'high', ownerNation.id);
                                        }
                                        this.selfDestructAnnounced = true;
                                    }
                                    
                                    // Point of no return warning
                                    if (!this.selfDestructCommenced && this.selfDestructTimer < 4.5) {
                                        if (!ownerNation.capitulated) {
                                            console.log(`[SELF-DESTRUCT] ${ownerNation.name} capital detonation sequence active - cannot be aborted`);
                                        }
                                        this.selfDestructCommenced = true;
                                    }
                                } else {
                                    // DRAMATIC: Announce if defenders arrived in time to prevent self-destruct
                                    if (this.wasCritical && hasUnits && !ownerNation.capitulated) {
                                        Audio.announce(`${ownerNation.name} defenders arrive - capital crisis averted!`, 'high', ownerNation.id);
                                        Audio.playVictory(this.x, this.y);
                                        this.wasCritical = false;
                                    } else if (this.wasCritical && !isBeingCaptured && !ownerNation.capitulated) {
                                        Audio.announce(`${ownerNation.name} capital threat neutralized!`, 'high', ownerNation.id);
                                        this.wasCritical = false;
                                    }
                                }
                                    
                                    // Countdown warnings - SOUND EFFECTS ONLY (no TTS - too slow)
                                    if (this.selfDestructTimer <= 4 && !this.selfDestructWarning20) {
                                        Audio.playCountdownBeep(this.x, this.y, 500, 0.15); // Initial warning - quieter
                                        this.selfDestructWarning20 = true;
                                    }
                                    if (this.selfDestructTimer <= 3 && !this.selfDestructWarning10) {
                                        Audio.playCountdownBeep(this.x, this.y, 700, 0.20); // Medium volume
                                        setTimeout(() => Audio.playCountdownBeep(this.x, this.y, 720, 0.20), 80); // Double beep
                                        this.selfDestructWarning10 = true;
                                    }
                                    if (this.selfDestructTimer <= 2 && !this.selfDestructWarning5) {
                                        Audio.playCountdownBeep(this.x, this.y, 900, 0.25); // LOUDEST - third phase peak
                                        setTimeout(() => Audio.playCountdownBeep(this.x, this.y, 920, 0.25), 80); // Double beep
                                        setTimeout(() => Audio.playCountdownBeep(this.x, this.y, 940, 0.25), 160); // Triple beep
                                        this.selfDestructWarning5 = true;
                                    }
                                    if (this.selfDestructTimer <= 1 && !this.selfDestructWarning1) {
                                        Audio.playTensionSiren(this.x, this.y); // Final warning siren
                                        this.selfDestructWarning1 = true;
                                    }
                                    if (this.selfDestructTimer <= 0.5 && !this.selfDestructWarningHalf) {
                                        // RAPID BEEPING - imminent detonation
                                        for (let i = 0; i < 5; i++) {
                                            setTimeout(() => Audio.playCountdownBeep(this.x, this.y, 1100 + i * 50), i * 60);
                                        }
                                        this.selfDestructWarningHalf = true;
                                    }
                                    
                                    // DETONATE
                                    if (this.selfDestructTimer <= 0) {
                                        if (!ownerNation.capitulated) {
                                            Audio.announce(`${ownerNation.name} detonates: eliminated`, 'high', ownerNation.id);
                                        }
                                        Audio.playSelfDestruct(this.x, this.y); // Catastrophic capital detonation
                                        // Create capital detonation effect (4x smaller than superweapons: 30 radius)
                                        const capitalDetonationRadius = 30;
                                        const capitalDetonationDamage = 150;
                                        
                                        // Damage nearby units from all nations
                                        nations.forEach(nation => {
                                            nation.units.forEach(u => {
                                                const dist = Math.hypot(u.x - this.x, u.y - this.y);
                                                if (dist < capitalDetonationRadius) {
                                                    const falloff = 1.0 - (dist / capitalDetonationRadius);
                                                    u.health -= capitalDetonationDamage * falloff;
                                                }
                                            });
                                        });
                                        
                                        // Create visual effect
                                        detonationEffects.push({
                                            x: this.x,
                                            y: this.y,
                                            radius: 0,
                                            maxRadius: capitalDetonationRadius * 2.0,
                                            alpha: 1.0,
                                            duration: 3.0,
                                            timer: 0,
                                            particles: Array.from({ length: 20 }, () => ({
                                                angle: Math.random() * Math.PI * 2,
                                                speed: 60 + Math.random() * 80,
                                                distance: 0,
                                                maxDistance: capitalDetonationRadius * (0.8 + Math.random() * 0.6),
                                                size: 1 + Math.random() * 3,
                                                rotation: Math.random() * Math.PI * 2,
                                                rotationSpeed: (Math.random() - 0.5) * 8
                                            }))
                                        });
                                        
                                        // Create crater
                                        craters.push({
                                            x: this.x,
                                            y: this.y,
                                            radius: capitalDetonationRadius * 1.2,
                                            createdAt: Date.now(),
                                            age: 0
                                        });
                                        
                                        // REASSIGN CAPITAL BEFORE DESTROYING (prevent headless state)
                                        const remainingNodes = nodes.filter(n => n.owner === this.owner && n !== this);
                                        
                                        if (remainingNodes.length > 0) {
                                            // Nation has other nodes - pick strongest as new capital
                                            let bestNode = remainingNodes[0];
                                            for (let node of remainingNodes) {
                                                if (node.economicTier > bestNode.economicTier) {
                                                    bestNode = node;
                                                }
                                            }
                                            
                                            // Transfer capital status BEFORE destroying this node
                                            this.isCapital = false;
                                            this.economicTier = Math.min(2, this.economicTier);
                                            this.resourceMultiplier = [0.5, 1.0, 1.5, 2.5][this.economicTier];
                                            
                                            bestNode.isCapital = true;
                                            bestNode.economicTier = 3;
                                            bestNode.resourceMultiplier = 2.5;
                                            ownerNation.capital = bestNode;
                                            
                                            // Announce capital transfer
                                            if (!ownerNation.capitulated) {
                                                const newCapitalName = bestNode.crypticName || 'node';
                                                Audio.announce(`${ownerNation.name} capital moves to ${newCapitalName}`, 'high', ownerNation.id);
                                                
                                                logAIEvent('capital', 'Capital reassigned before self-destruct', {
                                                    nationId: this.owner,
                                                    nationName: ownerNation.name,
                                                    newCapital: newCapitalName,
                                                    remainingNodes: remainingNodes.length
                                                });
                                            }
                                        } else {
                                            // No remaining nodes - full capitulation
                                            this.isCapital = false;
                                            ownerNation.capital = null;
                                            ownerNation.capitulated = true;
                                            ownerNation.capitulationTime = 0;
                                            ownerNation.rebellionTimer = 0;
                                            ownerNation.rebellionCooldown = 90.0;
                                            // Track elimination count for resurrection queue
                                            if (!ownerNation.eliminationCount) ownerNation.eliminationCount = 0;
                                            ownerNation.eliminationCount += 1;
                                            
                                            logAIEvent('capital', 'Nation capitulated via self-destruct', {
                                                nationId: this.owner,
                                                nationName: ownerNation.name,
                                                eliminationCount: ownerNation.eliminationCount
                                            });
                                        }
                                        
                                        // Destroy the self-destructed node
                                        this.owner = -1;
                                        this.capturingNation = -1;
                                        this.captureProgress = 0;
                                        
                                        // Clear self-destruct state
                                        this.selfDestructTimer = null;
                                        this.selfDestructAnnounced = false;
                                        this.selfDestructWarning20 = false;
                                        this.selfDestructWarning10 = false;
                                        this.selfDestructWarning5 = false;
                                        this.selfDestructWarning1 = false;
                                        this.selfDestructWarningHalf = false;
                                        
                                        // DESTROY THE NODE - detonation obliterates it completely
                                        return false;
                                    }
                            }
                            
                            // PROACTIVE CAPITAL RETREAT - relocate capital when heavily threatened
                            // Add cooldown to prevent endless evacuation loops
                            const now = Date.now();
                            if (this.isCapital && this.owner >= 0 && this.captureProgress > adjustedThreshold * 0.5) {
                                const ownerNation = nations[this.owner];
                                
                                // Check if recently evacuated (30 second cooldown)
                                if (!ownerNation.lastCapitalEvacuation) ownerNation.lastCapitalEvacuation = 0;
                                const timeSinceLastEvac = now - ownerNation.lastCapitalEvacuation;
                                
                                if (timeSinceLastEvac > 30000) { // 30 second cooldown
                                    const ownedNodes = nodes.filter(n => n.owner === this.owner && n !== this && !n.isCapital);
                                    
                                    if (ownedNodes.length > 0) {
                                        // Find safest node to retreat to
                                        let safestNode = null;
                                        let bestSafety = -Infinity;
                                        
                                        for (let node of ownedNodes) {
                                            // Score based on safety (low fatigue, no capture progress, few nearby enemies)
                                            const safetyScore = (100 - node.fatigue) + 
                                                              (node.capturingNation >= 0 ? -50 : 0) +
                                                              (node.economicTier * 10);
                                            
                                            if (safetyScore > bestSafety) {
                                                bestSafety = safetyScore;
                                                safestNode = node;
                                            }
                                        }
                                        
                                        if (safestNode && bestSafety > 0) {
                                            // Announce emergency retreat FIRST
                                            const locationName = safestNode.crypticName || 'safer location';
                                            const announcement = `${ownerNation.name} evacuates capital to ${locationName}!`;
                                            
                                            // Queue the announcement with a callback to execute the move when speech ends
                                            Audio.announce(announcement, 'high', ownerNation.id);
                                            
                                            // Schedule the actual capital move after a delay for dramatic effect
                                            setTimeout(() => {
                                                // Emergency retreat execution!
                                                this.isCapital = false;
                                                this.economicTier = Math.min(2, this.economicTier);
                                                this.resourceMultiplier = [0.5, 1.0, 1.5, 2.5][this.economicTier];
                                                
                                                safestNode.isCapital = true;
                                                safestNode.economicTier = 3;
                                                safestNode.resourceMultiplier = 2.5;
                                                ownerNation.capital = safestNode;
                                                ownerNation.lastCapitalEvacuation = now; // Record evacuation time
                                                
                                                Audio.playCapitalMove(safestNode.x, safestNode.y, false); // Retreat sound (descending)
                                            }, 2000); // 2 second delay allows announcement to play
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (this.captureProgress >= adjustedThreshold) {
                            // CAPITAL FALLBACK - if capital is captured, reassign to another node
                            const wasCapital = this.isCapital;
                            const previousOwner = this.owner;
                            
                            // Check if capturing nation prevented self-destruct
                            const preventedDetonation = this.isCapital && this.selfDestructTimer && this.selfDestructTimer > 0.5;
                            if (preventedDetonation) {
                                const capturingNation = nations[dominantNation];
                                const previousNation = nations[previousOwner];
                                if (!capturingNation.capitulated && !previousNation.capitulated) {
                                    Audio.announce(`${capturingNation.name} prevents ${previousNation.name} self-destruct`, 'high', dominantNation);
                                }
                                // Clear self-destruct state
                                this.selfDestructTimer = null;
                                this.selfDestructAnnounced = false;
                                this.selfDestructWarning20 = false;
                                this.selfDestructWarning10 = false;
                                this.selfDestructWarning5 = false;
                                this.selfDestructWarning1 = false;
                                this.selfDestructWarningHalf = false;
                            }
                            
                            // Node ownership is changing - ALL ownership changes cause fatigue
                            // Even initial capture from neutral adds stress to the node
                            this.flipCount++;
                            
                            // Exponentially increasing fatigue like bending a paperclip
                            // Each ownership change makes the node more fragile
                            const baseFatigue = 10; // Base damage per ownership change
                            const exponentialPenalty = Math.pow(1.4, this.flipCount);
                            const flipDamage = baseFatigue + exponentialPenalty * 6;
                            const oldFatigue = this.fatigue;
                            
                            // Cryptic nodes can accumulate more fatigue (up to 150) before breaking
                            const maxFatigue = this.crypticName && this.crypticName !== 'Sanctum' ? 150 : 100;
                            this.fatigue = Math.min(maxFatigue, this.fatigue + flipDamage);
                            
                            this.lastOwner = this.owner;
                            this.owner = dominantNation;
                            this.controlStrength = 1.0;
                            this.capturingNation = -1;
                            this.captureProgress = 0;
                            
                            // RESISTANCE CAPITAL CREATION - if a capitulated nation captures a node, it becomes their new capital
                            const capturingNation = nations[dominantNation];
                            if (capturingNation && capturingNation.capitulated && !capturingNation.capital) {
                                // First node captured by resistance - establish as capital!
                                this.isCapital = true;
                                this.economicTier = 3;
                                this.resourceMultiplier = 2.5;
                                capturingNation.capital = this;
                                capturingNation.capitulated = false;
                                capturingNation.resources = 50;
                                
                                // Check if this is post-IMPACT survivor or normal resistance
                                const isPostImpact = game.impactCount > 0 && !capturingNation.resurrectionCount;
                                if (isPostImpact) {
                                    Audio.announce(`${capturingNation.name} survivors establish new capital in cycle ${game.impactCount}!`, 'high', dominantNation);
                                    logGameEvent('resurrection', `${capturingNation.name} establishes post-impact capital`, 'high');
                                } else {
                                    Audio.announce(`${capturingNation.name} resistance establishes new capital!`, 'high', dominantNation);
                                    logGameEvent('resurrection', `${capturingNation.name} resistance establishes new capital`, 'high');
                                }
                                
                                // RESURRECTION ARMY - spawn 30 units quickly around the new capital
                                const capitalX = this.x;
                                const capitalY = this.y;
                                const capitalNode = this;
                                
                                for (let i = 0; i < 25; i++) {
                                    setTimeout(() => {
                                        const angle = Math.random() * Math.PI * 2;
                                        const dist = 25 + Math.random() * 35; // Spawn around capital
                                        const spawnX = capitalX + Math.cos(angle) * dist;
                                        const spawnY = capitalY + Math.sin(angle) * dist;
                                        
                                        const resurrectionUnit = new Unit(spawnX, spawnY, dominantNation);
                                        resurrectionUnit.jitterCooldown = 10.0;
                                        resurrectionUnit.capitalMissileCooldown = 10.0;
                                        resurrectionUnit.jitterPositions = [];
                                        resurrectionUnit.role = 'garrison';
                                        resurrectionUnit.targetNode = capitalNode;
                                        resurrectionUnit.targetCommitmentTime = 30.0; // Guard the capital
                                        capturingNation.units.push(resurrectionUnit);
                                    }, i * 100); // Spawn every 100ms for 3 seconds total
                                }
                            }
                            
                            // Play capture sound
                            const captureNation = nations[dominantNation];
                            Audio.playCapture(this.x, this.y, captureNation.id % 2 === 0);
                            
                            // Check if this node will break on next flip
                            let flipThreshold = 6;
                            if (this.crypticName) {
                                flipThreshold = this.crypticName === 'Sanctum' ? Infinity : 9;
                            }
                            const willBreakNextFlip = this.flipCount >= flipThreshold;
                            
                            // Announce capital captures (with cooldown to prevent spam)
                            if (wasCapital && previousOwner >= 0) {
                                const losingNation = nations[previousOwner];
                                const capitalName = this.crypticName ? this.crypticName : 'capital';
                                const now = Date.now();
                                if (now - announcerState.lastCapitalCapture > 15000) { // 15 second cooldown
                                    Audio.announce(`${captureNation.name} has seized ${losingNation.name} ${capitalName}`, 'high', captureNation.id);
                                    logGameEvent('capital', `${captureNation.name} seized ${losingNation.name} ${capitalName}`, 'high');
                                    announcerState.lastCapitalCapture = now;
                                }
                            } else if (this.crypticName && !willBreakNextFlip && previousOwner >= 0) {
                                // Check if capturing nation is reclaiming their own node
                                const isReclaim = this.lastOwner === dominantNation;
                                
                                if (isReclaim) {
                                    // Taking back what was theirs
                                    Audio.announce(`${captureNation.name} takes back ${this.crypticName}`, 'normal', captureNation.id);
                                } else {
                                    // Capturing from another nation - ARTIFACT THEFT via node capture
                                    const losingNation = nations[previousOwner];
                                    Audio.announce(`${captureNation.name} takes ${losingNation.name} ${this.crypticName}`, 'normal', captureNation.id);
                                    
                                    // Any artifacts stored here transfer to new owner (handled in artifact update)
                                }
                            } else if (this.crypticName && !willBreakNextFlip) {
                                // Neutral node capture (no previous owner)
                                const now = Date.now();
                                if (now - announcerState.lastEstablishment > 45000) { // 45 second cooldown
                                    Audio.announce(`${captureNation.name} establishes control at ${this.crypticName}`, 'normal', captureNation.id);
                                    announcerState.lastEstablishment = now;
                                }
                            }
                            
                            // Handle capital loss - reassign to another owned node
                            if (wasCapital && previousOwner >= 0) {
                                const losingNation = nations[previousOwner];
                                const remainingNodes = nodes.filter(n => n.owner === previousOwner && n !== this);
                                
                                if (remainingNodes.length > 0) {
                                    // Pick strongest remaining node as new capital
                                    let bestNode = remainingNodes[0];
                                    for (let node of remainingNodes) {
                                        if (node.economicTier > bestNode.economicTier) {
                                            bestNode = node;
                                        }
                                    }
                                    
                                    // Transfer capital status
                                    this.isCapital = false;
                                    this.economicTier = Math.min(2, this.economicTier); // Downgrade if was capital tier
                                    this.resourceMultiplier = [0.5, 1.0, 1.5, 2.5][this.economicTier];
                                    
                                    bestNode.isCapital = true;
                                    bestNode.economicTier = 3;
                                    bestNode.resourceMultiplier = 2.5;
                                    losingNation.capital = bestNode;
                                } else {
                                    // No remaining nodes - nation is capitulated
                                    this.isCapital = false;
                                    losingNation.capital = null;
                                    losingNation.capitulated = true;
                                    losingNation.capitulationTime = 0; // Track time since death (will increment)
                                    losingNation.rebellionTimer = 0;
                                    losingNation.rebellionCooldown = 90.0;
                                    // Track elimination count for resurrection queue
                                    if (!losingNation.eliminationCount) losingNation.eliminationCount = 0;
                                    losingNation.eliminationCount += 1;
                                    
                                    // Clear all artifact cracking progress for this dead nation
                                    artifacts.forEach(artifact => {
                                        if (artifact.crackingNation === losingNation.id) {
                                            artifact.crackingNation = undefined;
                                        }
                                        // Clear study/decrypt progress if they were doing it
                                        if (artifact.studyingNode && artifact.studyingNode.owner === losingNation.id) {
                                            artifact.studyProgress = 0;
                                            artifact.studyingNode = null;
                                        }
                                        if (artifact.decryptingNode && artifact.decryptingNode.owner === losingNation.id) {
                                            artifact.decryptProgress = 0;
                                            artifact.decryptingNode = null;
                                        }
                                    });
                                    
                                    // REBELLION TIMER - capitulated nations can attempt to re-establish
                                    losingNation.rebellionTimer = 0;
                                    losingNation.rebellionCooldown = 60.0; // 1 minute before first attempt
                                    
                                    // Announce elimination (no specific nation speaker - neutral announcement)
                                    Audio.announce(`${losingNation.name} has been eliminated`, 'high', -1);
                                    logGameEvent('elimination', `${losingNation.name} eliminated by ${captureNation.name}`, 'high');
                                }
                            }
                        }
                    }
                }
                
                if (dominantNation >= 0 && dominantNation === this.owner) {
                    // Friendly units at friendly node - clear any enemy progress
                    if (this.capturingNation >= 0 && this.capturingNation !== this.owner) {
                        // Degrade enemy progress when defending
                        this.captureProgress -= dt * maxPresence * 0.5;
                        
                        if (this.captureProgress <= 0) {
                            this.capturingNation = -1;
                            this.captureProgress = 0;
                        }
                    }
                }
                
                if (dominantNation === -1 && this.capturingNation >= 0) {
                    // No one present - decay based on how established progress is
                    const captureThreshold = this.isCapital ? 36 : 30;
                    let defensiveMultiplier = 1.0;
                    if (this.crypticName === 'Citadel') defensiveMultiplier = 1.4;
                    if (this.crypticName === 'Bastion') defensiveMultiplier = 1.6;
                    const adjustedThreshold = captureThreshold * defensiveMultiplier;
                    
                    const progressRatio = this.captureProgress / adjustedThreshold;
                    
                    // More established = slower decay (0.2 to 0.05 rate)
                    // KEEP buff: Capture progress decays 50% slower
                    let baseDecayRate = 0.2 * (1 - progressRatio * 0.75);
                    if (this.crypticName === 'Keep') baseDecayRate *= 0.5;
                    
                    this.captureProgress = Math.max(0, this.captureProgress - dt * baseDecayRate);
                    
                    if (this.captureProgress <= 0) {
                        this.capturingNation = -1;
                    }
                } else if (this.owner >= 0) {
                    this.controlStrength = Math.min(1.0, this.controlStrength + dt * 0.01);
                }
                
                // Fatigue recovery when node is stable (owned and not being captured)
                // Flip-flop fatigue recovers VERY slowly - like a bent paperclip, damage is permanent
                if (this.owner >= 0 && this.capturingNation === -1) {
                    // SANCTUM buff: Immune to fatigue penalties (sets to 0)
                    if (this.crypticName === 'Sanctum') {
                        this.fatigue = 0;
                    } else {
                        // Only recover fatigue that came from sources OTHER than flipping
                        // Flip count determines how much is permanent damage
                        const permanentFatigue = this.flipCount * 15; // 15 per flip is permanent
                    const recoverableThreshold = Math.max(0, this.fatigue - permanentFatigue);
                    
                    if (this.fatigue > permanentFatigue) {
                        // Can only recover down to permanent level
                        // HAVEN buff: 2x faster fatigue recovery
                        let recoveryRate = 0.5;
                        if (this.crypticName === 'Haven') recoveryRate *= 2.0;
                        
                        this.fatigue = Math.max(permanentFatigue, this.fatigue - dt * recoveryRate);
                    }
                    }
                }
                
                // Check for node death/breakdown from total flip count
                // Normal nodes break after 6 flips, cryptic nodes after 9 flips, Sanctum is immune
                let flipThreshold = 6;
                if (this.crypticName) {
                    flipThreshold = this.crypticName === 'Sanctum' ? Infinity : 9;
                }
                
                if (this.flipCount >= flipThreshold && !this.isBuilding) {
                    // console.log(`NODE BREAKING! Flips: ${this.flipCount}, Threshold: ${flipThreshold}, Cryptic: ${this.crypticName || 'none'}`);
                    
                    try {
                        // Store the current owner before destruction
                        const lastControllingNation = this.owner >= 0 && nations[this.owner] ? nations[this.owner] : null;
                        const wasSpecialNode = this.crypticName;
                        
                        // Node has been flipped too many times - destroy it
                        // Announce node destruction with attacker credit - alternate phrasing
                        if (lastControllingNation && this.capturingNation >= 0 && nations[this.capturingNation]) {
                            const attackerNation = nations[this.capturingNation];
                            
                            // Randomly choose between two announcement styles
                            const style = Math.random() < 0.5;
                            
                            if (wasSpecialNode && lastControllingNation.name && attackerNation.name) {
                                if (!attackerNation.capitulated) {
                                    if (style) {
                                        Audio.announce(`${attackerNation.name} destroyed ${lastControllingNation.name}'s ${wasSpecialNode}!`, 'high', attackerNation.id);
                                    } else {
                                        Audio.announce(`${lastControllingNation.name}'s ${wasSpecialNode} was destroyed by ${attackerNation.name}!`, 'high', attackerNation.id);
                                    }
                                }
                            } else if (lastControllingNation.name && attackerNation.name) {
                                if (!attackerNation.capitulated) {
                                    if (style) {
                                        Audio.announce(`${attackerNation.name} destroyed ${lastControllingNation.name}'s city`, 'normal', attackerNation.id);
                                    } else {
                                        Audio.announce(`${lastControllingNation.name}'s city was destroyed by ${attackerNation.name}`, 'normal', attackerNation.id);
                                    }
                                }
                            }
                        }
                        
                        return false; // Signal to remove this node
                    } catch (error) {
                        console.error('Error in node breaking logic:', error);
                        // Default to removing node to prevent stuck state
                        return false;
                    }
                }
                
                // Handle node construction phase
                if (this.isBuilding) {
                    this.buildTimer += dt;
                    if (this.buildTimer >= this.buildTime) {
                        // Construction complete - node comes online as neutral
                        this.isBuilding = false;
                        this.buildTimer = 0;
                        this.owner = -1;
                        this.fatigue = 0;
                        this.flipCount = 0;
                        this.capturingNation = -1;
                        this.captureProgress = 0;
                    }
                    // Allow capture during construction - don't return here
                    // Just skip production below
                }
                
                // Track stable ownership for cryptic name eligibility
                if (this.owner >= 0 && this.capturingNation === -1 && !this.isBuilding) {
                    this.timeHeld += dt;
                    
                    // Award cryptic name after prolonged stable ownership
                    if (this.crypticEligible && !this.crypticName && this.timeHeld >= this.crypticUpgradeThreshold) {
                        const availableNames = crypticNames.filter(cn => !usedCrypticNames.includes(cn.name));
                        if (availableNames.length > 0) {
                            const nameData = availableNames[Math.floor(Math.random() * availableNames.length)];
                            this.crypticName = nameData.name;
                            this.crypticData = nameData;
                            usedCrypticNames.push(nameData.name);
                            
                            // Announce the upgrade with cooldown
                            const ownerNation = nations[this.owner];
                            const now = Date.now();
                            if (now - announcerState.lastEstablishment > 45000) { // 45 second cooldown
                                if (!ownerNation.capitulated) {
                                    Audio.announce(`${ownerNation.name} establishes ${this.crypticName}`, 'normal', ownerNation.id);
                                }
                                announcerState.lastEstablishment = now;
                            }
                        }
                    }
                } else {
                    // Reset timer if being captured or changing hands
                    this.timeHeld = 0;
                }
                
                // Production - boosted by controlled territory, costs resources
                // Skip production while building
                if (this.owner >= 0 && !nations[this.owner].capitulated && !this.isBuilding) {
                    const ownerNation = nations[this.owner];
                    
                    // RESISTANCE SYSTEM - empires suffer internal strife as they expand
                    // Resistance intensity is pre-calculated and passed in from game loop
                    const resistance = resistanceIntensityMap[this.owner] || 0;
                    if (resistance > 0) {
                        // Apply resistance damage to units at this node
                        const unitsAtNode = ownerNation.units.filter(u => 
                            Math.hypot(u.x - this.x, u.y - this.y) < 50
                        );
                        unitsAtNode.forEach(unit => {
                            unit.health -= resistance * dt;
                        });
                    }
                    
                    // Check global unit cap
                    const totalUnits = nations.reduce((sum, n) => sum + n.units.length, 0);
                    
                    if (totalUnits < MAX_TOTAL_UNITS) {
                        // Territory bonus - DISABLED for performance (was scanning entire grid per node)
                        // Production now scales with node count only
                        const territoryBonus = 0;
                        
                        // SCALE PRODUCTION WITH NODE COUNT - diminishing returns to prevent exponential growth
                        const nodeCount = nodes.filter(n => n.owner === this.owner).length;
                        // 1 node = 1.0x, 2 = 1.15x, 3 = 1.30x, 5 = 1.60x, 10 = 2.35x (capped at 2.5x)
                        const nodeMultiplier = Math.min(2.5, 1 + (nodeCount - 1) * 0.15); // Reduced from 0.5 to 0.15
                        
                        // Apply territory bonus (can reduce production time up to 15%)
                        let productionMultiplier = nodeMultiplier * (1 + Math.min(territoryBonus, 0.15)); // Reduced from 0.2
                        
                        // RESURRECTION IMMUNITY: Start fast, slow down as immunity expires
                        // Ramps from 24x to 3x speed (0.25s → 2s per unit)
                        if (ownerNation.resurrectionImmunity > 0) {
                            const immunityRemaining = ownerNation.resurrectionImmunity / 45; // 1.0 to 0.0
                            const speedMultiplier = 3.0 + (immunityRemaining * 21.0); // 24x → 3x
                            productionMultiplier *= speedMultiplier;
                        }
                        
                        // APEX buff: +25% production speed
                        if (this.crypticName === 'Apex') productionMultiplier *= 1.25;
                        
                        // FORGE buff: Units cost 20% less (applied at spawn)
                        
                        this.productionTimer += dt * productionMultiplier;
                        if (this.productionTimer >= this.productionRate) {
                            this.productionTimer = 0;
                            
                            // Check if nation can afford unit production
                            // FORGE buff: -20% production cost
                            const productionCost = this.crypticName === 'Forge' ? UNIT_PRODUCTION_COST * 0.8 : UNIT_PRODUCTION_COST;
                            
                            // CAPITAL SUBSIDY: Capitals always produce at least 1 unit per production cycle even with insufficient resources
                            // This ensures nations always have basic defense and expansion capability
                            const canAfford = ownerNation.resources >= productionCost;
                            const isCapitalSubsidy = this.isCapital && !canAfford;
                            
                            if (canAfford || isCapitalSubsidy) {
                                // Check global population cap first (prevent spawning, don't kill alive units)
                                const allUnits = nations.flatMap(n => n.units);
                                if (allUnits.length >= MAX_TOTAL_UNITS) {
                                    // At max capacity - refund cost and skip spawn
                                    if (canAfford) ownerNation.resources += productionCost;
                                } else {
                                    // Deduct cost only if they can afford it (subsidized spawns are free)
                                    if (canAfford) {
                                        ownerNation.resources -= productionCost;
                                    }
                                    
                                    // Check population cap - if at max, add to queue instead
                                    if (ownerNation.units.length < MAX_UNIT_COUNT) {
                                        // Find valid spawn position (not on mountains/rivers)
                                        let spawnX, spawnY, attempts = 0;
                                        do {
                                            const angle = Math.random() * Math.PI * 2;
                                            const dist = 20 + Math.random() * 10;
                                            spawnX = this.x + Math.cos(angle) * dist;
                                            spawnY = this.y + Math.sin(angle) * dist;
                                            attempts++;
                                        } while (!isPassable(spawnX, spawnY) && attempts < 20);
                                        
                                        // Only spawn if we found valid position
                                        if (isPassable(spawnX, spawnY)) {
                                            const unit = new Unit(spawnX, spawnY, this.owner);
                                            // PINNACLE buff: +25% spawn strength
                                            if (this.crypticName === 'Pinnacle') {
                                                unit.strength *= 1.25;
                                            }
                                            nations[this.owner].units.push(unit);
                                        } else {
                                            // Can't spawn - add to queue instead
                                            ownerNation.unitQueue++;
                                        }
                                    } else {
                                        // At population cap - add to queue to spawn when room available
                                        ownerNation.unitQueue++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                return true; // Node survives
            }
            
            /**
             * Render the node on the canvas
             */
            draw() {
                // Skip drawing during construction - show build progress instead
                if (this.isBuilding) {
                    // Show construction indicator - pulsing circle
                    const buildProgress = this.buildTimer / this.buildTime;
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(this.buildTimer * 5); // Pulsing effect
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 5 + buildProgress * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner progress arc
                    ctx.strokeStyle = '#dddd00';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 5, -Math.PI/2, -Math.PI/2 + buildProgress * Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.globalAlpha = 1.0;
                    return; // Don't draw normal node design while building
                }
                
                // Tiered node types with distinct visuals
                const tierNames = ['Poor', 'Normal', 'Rich', 'Capital'];
                const tierSizes = [3, 5, 6, 8];  // Visual size by tier
                const tierSymbols = [1, 2, 3, 4]; // Number of inner dots
                
                const size = tierSizes[this.economicTier];
                const tierSymbol = tierSymbols[this.economicTier];
                
                // Outer ring - nation color or white for neutral
                ctx.strokeStyle = this.owner >= 0 && nations[this.owner] ? nations[this.owner].color : '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner symbols based on tier (visual richness indicator)
                if (this.owner >= 0 && nations[this.owner]) {
                    ctx.fillStyle = nations[this.owner].color;
                    
                    if (this.economicTier === 0) {
                        // Poor: single small dot
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (this.economicTier === 1) {
                        // Normal: small cross/plus
                        ctx.fillRect(this.x - 1, this.y - 2, 2, 4);
                        ctx.fillRect(this.x - 2, this.y - 1, 4, 2);
                    } else if (this.economicTier === 2) {
                        // Rich: triangle
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - 3);
                        ctx.lineTo(this.x + 3, this.y + 3);
                        ctx.lineTo(this.x - 3, this.y + 3);
                        ctx.fill();
                    } else if (this.economicTier === 3) {
                        // Capital: star/asterisk (most valuable)
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - 4);
                        ctx.lineTo(this.x + 2, this.y - 1);
                        ctx.lineTo(this.x + 4, this.y);
                        ctx.lineTo(this.x + 2, this.y + 2);
                        ctx.lineTo(this.x + 3, this.y + 4);
                        ctx.lineTo(this.x, this.y + 2);
                        ctx.lineTo(this.x - 3, this.y + 4);
                        ctx.lineTo(this.x - 2, this.y + 2);
                        ctx.lineTo(this.x - 4, this.y);
                        ctx.lineTo(this.x - 2, this.y - 1);
                        ctx.fill();
                    }
                }
                
                // Fatigue indicator - red ring if fatigued
                if (this.fatigue > 20) {
                    const fatigueRatio = this.fatigue / 100;
                    ctx.strokeStyle = `rgba(255, ${Math.floor(200 * (1 - fatigueRatio))}, 0, ${0.3 + fatigueRatio * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Capture progress ring
                if (this.capturingNation >= 0 && nations[this.capturingNation]) {
                    const threshold = this.isCapital ? 36 : 30;
                    const pct = this.captureProgress / threshold;
                    
                    ctx.strokeStyle = nations[this.capturingNation].color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 5, -Math.PI/2, -Math.PI/2 + pct * Math.PI * 2);
                    ctx.stroke();
                }
                
                // Display nation stats on capital nodes ONLY (not promoted tier 3 nodes)
                if (this.isCapital && this.owner >= 0 && nations[this.owner] && nations[this.owner].capital === this) {
                    const nation = nations[this.owner];
                    const nodeCount = nodes.filter(n => n.owner === this.owner).length;
                    const strengthMod = getUnitStrengthModifier(nation);
                    const modDisplay = strengthMod > 1.0 ? `↑${(strengthMod * 100).toFixed(0)}%` : 
                                       strengthMod < 1.0 ? `↓${(strengthMod * 100).toFixed(0)}%` : '=';
                    const balance = (nation.income || 0) - (nation.upkeep || 0);
                    const balanceSign = balance >= 0 ? '+' : '';
                    
                    // Count diplomatic relations for display
                    const atWar = Object.values(nation.diplomaticRelations || {}).filter(s => s === DIPLOMATIC_STANCE.WAR).length;
                    const allied = Object.values(nation.diplomaticRelations || {}).filter(s => s === DIPLOMATIC_STANCE.ALLIED).length;
                    const exhaustion = Math.floor(nation.warExhaustion || 0);
                    const recentCrimes = nation.recentWarCrimes.filter(wc => Date.now() - wc.time < 300000).length;
                    
                    // Semi-transparent background with better sizing
                    const hasCapitalName = this.crypticName ? 1 : 0;
                    const boxHeight = 50 + (hasCapitalName * 12);
                    const boxWidth = 105; // Slightly narrower
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; // Slightly darker for better contrast
                    ctx.fillRect(this.x + 16, this.y - 24, boxWidth, boxHeight);
                    
                    // Nation stats text with better spacing
                    ctx.fillStyle = nation.color;
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${nation.name}`, this.x + 19, this.y - 14);
                    
                    // Display cryptic name under nation name if capital has one
                    if (this.crypticName) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.95)'; // Brighter gold
                        ctx.font = 'bold 9px monospace';
                        ctx.fillText(`[${this.crypticName}]`, this.x + 19, this.y - 3);
                    }
                    
                    const statsY = hasCapitalName ? this.y + 9 : this.y - 1;
                    ctx.font = '9px monospace'; // Slightly smaller for cleaner look
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`${nation.units.length}u ${modDisplay} ${nodeCount}n`, this.x + 19, statsY);
                    ctx.fillText(`${Math.floor(nation.resources)}⚡ ${balanceSign}${balance.toFixed(1)}/s`, this.x + 19, statsY + 11);
                    
                    // Diplomatic status with improved positioning
                    const dipY = hasCapitalName ? this.y + 31 : this.y + 20;
                    let dipStatus = '';
                    if (atWar > 0) dipStatus += `⚔${atWar} `;
                    if (allied > 0) {
                        // Show alliance trust if low
                        const lowestTrust = Object.keys(nation.allianceTrust || {})
                            .filter(id => nation.diplomaticRelations[id] === DIPLOMATIC_STANCE.ALLIED)
                            .reduce((min, id) => Math.min(min, nation.allianceTrust[id] || 100), 100);
                        if (lowestTrust < 50) {
                            dipStatus += `🤝${allied}(${Math.floor(lowestTrust)}%) `;
                        } else {
                            dipStatus += `🤝${allied} `;
                        }
                    }
                    if (exhaustion > 50) dipStatus += `😰${exhaustion} `;
                    if (recentCrimes > 0) dipStatus += `⚠️${recentCrimes}`;
                    if (dipStatus) {
                        // Red if war criminal or high exhaustion, yellow if war crimes or low trust, gray otherwise
                        const lowTrust = allied > 0 && Object.values(nation.allianceTrust || {}).some(t => t < 30);
                        ctx.fillStyle = recentCrimes > 0 ? '#ff8800' : 
                                       (exhaustion > 70 || lowTrust ? '#ff5555' : '#aaaaaa');
                        ctx.font = '8px monospace'; // Smaller font for diplomatic info
                        ctx.fillText(dipStatus, this.x + 19, dipY);
                    }
                    
                    ctx.textAlign = 'left'; // Reset
                }
                
                // Display cryptic names on strategic/valuable nodes (non-capitals)
                if (!this.isCapital && this.crypticName && this.owner >= 0 && this.crypticData) {
                    const nation = nations[this.owner];
                    
                    // Calculate label dimensions
                    const nameWidth = this.crypticName.length * 5.2;
                    // Show specific buff names
                    let buffText = this.crypticData.buff || 'Special';
                    if (this.crypticName === 'Citadel') buffText = '+40% Def';
                    else if (this.crypticName === 'Bastion') buffText = '+60% Def';
                    else if (this.crypticName === 'Nexus') buffText = '+50% Spd';
                    else if (this.crypticName === 'Forge') buffText = '+100% Build';
                    else if (this.crypticName === 'Archive') buffText = 'Intel';
                    else if (this.crypticName === 'Monument') buffText = '+15% Aura';
                    else if (this.crypticName === 'Keep') buffText = 'Progress';
                    else if (this.crypticName === 'Sanctum') buffText = 'No Fatigue';
                    const buffWidth = buffText.length * 4.5;
                    const boxWidth = nameWidth + buffWidth + 12;
                    const boxHeight = 15;
                    
                    // SMART POSITIONING: Find optimal position to avoid overlap
                    // Try 8 positions around the node (right, top-right, top, top-left, left, etc.)
                    const positions = [
                        { x: this.x + 9, y: this.y - 19, priority: 1 },      // Right (preferred)
                        { x: this.x + 9, y: this.y - 35, priority: 2 },      // Top-right
                        { x: this.x - boxWidth/2, y: this.y - 35, priority: 3 }, // Top
                        { x: this.x - boxWidth - 9, y: this.y - 35, priority: 4 }, // Top-left
                        { x: this.x - boxWidth - 9, y: this.y - 19, priority: 5 }, // Left
                        { x: this.x - boxWidth - 9, y: this.y + 5, priority: 6 },  // Bottom-left
                        { x: this.x - boxWidth/2, y: this.y + 5, priority: 7 },    // Bottom
                        { x: this.x + 9, y: this.y + 5, priority: 8 }        // Bottom-right
                    ];
                    
                    // Check each position for overlap with other labels and capitals
                    let bestPosition = null;
                    for (const pos of positions) {
                        let hasOverlap = false;
                        
                        // Check against all other nodes with labels
                        for (const n of nodes) {
                            if (n === this) continue;
                            if (!n.crypticName && !n.isCapital) continue;
                            
                            // Get other label bounds (or capital info box bounds)
                            let otherX, otherY, otherWidth, otherHeight;
                            if (n.isCapital && n.owner >= 0) {
                                // Capital info box position
                                const hasCapitalName = n.crypticName ? 1 : 0;
                                otherX = n.x + 16;
                                otherY = n.y - 24;
                                otherWidth = 105;
                                otherHeight = 50 + (hasCapitalName * 12);
                            } else if (n.crypticName && !n.isCapital && n.owner >= 0) {
                                // Use cached position if available, otherwise assume right position
                                otherX = n.labelX !== undefined ? n.labelX : n.x + 9;
                                otherY = n.labelY !== undefined ? n.labelY : n.y - 19;
                                const nNameWidth = n.crypticName.length * 5.2;
                                const nBuffText = n.crypticData?.buff || 'Special';
                                const nBuffWidth = nBuffText.length * 4.5;
                                otherWidth = nNameWidth + nBuffWidth + 12;
                                otherHeight = 15;
                            } else {
                                continue;
                            }
                            
                            // Check for overlap with 5px padding
                            const padding = 5;
                            if (pos.x < otherX + otherWidth + padding &&
                                pos.x + boxWidth + padding > otherX &&
                                pos.y < otherY + otherHeight + padding &&
                                pos.y + boxHeight + padding > otherY) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        
                        if (!hasOverlap) {
                            bestPosition = pos;
                            break; // Found a good position
                        }
                    }
                    
                    // If all positions overlap, use the preferred position anyway (shouldn't happen often)
                    if (!bestPosition) bestPosition = positions[0];
                    
                    // Cache position for overlap checks by other nodes
                    this.labelX = bestPosition.x;
                    this.labelY = bestPosition.y;
                    
                    // Draw label at optimal position
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(bestPosition.x, bestPosition.y, boxWidth, boxHeight);
                
                    ctx.fillStyle = nation.color;
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.crypticName, bestPosition.x + 2, bestPosition.y + 9);
                    
                    // Buff type in brackets
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
                    ctx.font = '7px monospace';
                    ctx.fillText(`[${buffText}]`, bestPosition.x + 3 + nameWidth, bestPosition.y + 9);
                    
                    // Tier indicator star
                    if (this.economicTier >= 2) {
                        ctx.fillStyle = this.economicTier === 3 ? 'rgba(255, 100, 255, 0.8)' : 'rgba(255, 215, 0, 0.7)';
                        ctx.font = '9px monospace';
                        ctx.fillText('★', bestPosition.x + boxWidth - 10, bestPosition.y + 9);
                    }
                    
                    ctx.textAlign = 'left'; // Reset
                }
            }
        }
        
        // World Map - Procedural terrain generation
        const TERRAIN_SCALE = 0.003; // Frequency of terrain features
        const TERRAIN_OCTAVES = 4;   // Detail levels
        
        // Terrain types
        const TERRAIN_TYPES = {
            PASSABLE: 0,
            ROUGH: 1,      // Slow movement (0.5x speed)
            MOUNTAIN: 2,   // Impassable
            RIVER: 3       // Slow movement (0.3x speed)
        };
        
        let terrainGrid = [];
        
        // Perlin-like noise for terrain
        function terrainNoise(x, y, seed = 42) {
            let value = 0;
            let amplitude = 1;
            let frequency = TERRAIN_SCALE;
            
            for (let octave = 0; octave < TERRAIN_OCTAVES; octave++) {
                value += simpleNoise(x * frequency, y * frequency, seed + octave * 10) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / 2; // Normalize to roughly 0-1
        }
        
        // Generate terrain features
        function generateTerrain() {
            const worldWidth = canvas.width * WORLD_SCALE;
            const worldHeight = canvas.height * WORLD_SCALE;
            const cellSize = 20; // Match influence grid size
            const cols = Math.ceil(worldWidth / cellSize);
            const rows = Math.ceil(worldHeight / cellSize);
            
            terrainGrid = Array(rows).fill(null).map(() => 
                Array(cols).fill(TERRAIN_TYPES.PASSABLE)
            );
            
            // Generate mountain ranges (3-6 ranges for more variety)
            // Mountains ONLY in the interior - never touch edges to prevent enclaves
            const numMountainRanges = 3 + Math.floor(Math.random() * 4);
            const edgeMargin = 200; // Keep mountains well away from all edges
            
            for (let i = 0; i < numMountainRanges; i++) {
                // Random interior starting point (not near any edge)
                const startX = edgeMargin + Math.random() * (worldWidth - 2 * edgeMargin);
                const startY = edgeMargin + Math.random() * (worldHeight - 2 * edgeMargin);
                let angle = Math.random() * Math.PI * 2; // Any direction
                
                // Vary mountain sizes - longer ranges with variable density
                const sizeVariant = Math.random();
                let length, width, density;
                if (sizeVariant < 0.3) {
                    // Small ridges (30% chance) - longer than before
                    length = 180 + Math.random() * 220;
                    width = 20 + Math.random() * 15;
                    density = 0.7 + Math.random() * 0.2; // 70-90% density
                } else if (sizeVariant < 0.7) {
                    // Medium ranges (40% chance) - significantly longer
                    length = 300 + Math.random() * 300;
                    width = 25 + Math.random() * 20;
                    density = 0.6 + Math.random() * 0.3; // 60-90% density
                } else {
                    // Large ranges (30% chance) - much longer
                    length = 450 + Math.random() * 350;
                    width = 30 + Math.random() * 25;
                    density = 0.5 + Math.random() * 0.3; // 50-80% density
                }
                
                const steps = Math.floor(length / 5);
                let currentX = startX;
                let currentY = startY;
                
                for (let step = 0; step < steps; step++) {
                    // Natural angle drift
                    angle += (Math.random() - 0.5) * 0.15;
                    
                    // Move along the range
                    const stepSize = length / steps;
                    currentX += Math.cos(angle) * stepSize;
                    currentY += Math.sin(angle) * stepSize;
                    
                    // Stop if we get too close to ANY edge (prevents wall+mountain enclaves)
                    if (currentX < edgeMargin || currentX > worldWidth - edgeMargin ||
                        currentY < edgeMargin || currentY > worldHeight - edgeMargin) {
                        break;
                    }
                    
                    // Variable density - skip some sections for gaps
                    if (Math.random() > density) continue;
                    
                    // Mark cells as mountains
                    const gx = Math.floor(currentX / cellSize);
                    const gy = Math.floor(currentY / cellSize);
                    const radius = Math.floor(width / cellSize);
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = gx + dx;
                            const ny = gy + dy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && dist < radius) {
                                if (dist < radius * 0.6) {
                                    terrainGrid[ny][nx] = TERRAIN_TYPES.MOUNTAIN;
                                } else if (terrainGrid[ny][nx] === TERRAIN_TYPES.PASSABLE) {
                                    terrainGrid[ny][nx] = TERRAIN_TYPES.ROUGH;
                                }
                            }
                        }
                    }
                }
            }
            
            // Generate rough terrain patches (forests, hills, marshes)
            const numRoughPatches = 5 + Math.floor(Math.random() * 8);
            for (let i = 0; i < numRoughPatches; i++) {
                const centerX = edgeMargin + Math.random() * (worldWidth - 2 * edgeMargin);
                const centerY = edgeMargin + Math.random() * (worldHeight - 2 * edgeMargin);
                const patchRadius = 40 + Math.random() * 60;
                const density = 0.4 + Math.random() * 0.4; // 40-80% coverage
                
                const gx = Math.floor(centerX / cellSize);
                const gy = Math.floor(centerY / cellSize);
                const gridRadius = Math.ceil(patchRadius / cellSize);
                
                for (let dy = -gridRadius; dy <= gridRadius; dy++) {
                    for (let dx = -gridRadius; dx <= gridRadius; dx++) {
                        const nx = gx + dx;
                        const ny = gy + dy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && 
                            dist < gridRadius && Math.random() < density) {
                            // Don't override mountains
                            if (terrainGrid[ny][nx] === TERRAIN_TYPES.PASSABLE) {
                                terrainGrid[ny][nx] = TERRAIN_TYPES.ROUGH;
                            }
                        }
                    }
                }
            }
            
            // Generate rivers (2-4 rivers)
            const numRivers = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numRivers; i++) {
                const startEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, targetX, targetY;
                
                switch(startEdge) {
                    case 0: // Top to bottom
                        x = Math.random() * worldWidth;
                        y = 0;
                        targetX = Math.random() * worldWidth;
                        targetY = worldHeight;
                        break;
                    case 1: // Right to left
                        x = worldWidth;
                        y = Math.random() * worldHeight;
                        targetX = 0;
                        targetY = Math.random() * worldHeight;
                        break;
                    case 2: // Bottom to top
                        x = Math.random() * worldWidth;
                        y = worldHeight;
                        targetX = Math.random() * worldWidth;
                        targetY = 0;
                        break;
                    case 3: // Left to right
                        x = 0;
                        y = Math.random() * worldHeight;
                        targetX = worldWidth;
                        targetY = Math.random() * worldHeight;
                        break;
                }
                
                // Draw winding river with smoother, more contiguous path
                const steps = 200; // More steps for smoother river
                let currentX = x;
                let currentY = y;
                let angle = Math.atan2(targetY - y, targetX - x);
                
                for (let step = 0; step < steps; step++) {
                    const t = step / steps;
                    
                    // Smooth curve toward target with gentle meandering
                    const directX = x + (targetX - x) * t;
                    const directY = y + (targetY - y) * t;
                    
                    // Add smooth sine wave for natural winding
                    const meander = Math.sin(step * 0.2) * 40; // Reduced randomness for continuity
                    const perpAngle = angle + Math.PI / 2;
                    
                    currentX = directX + Math.cos(perpAngle) * meander;
                    currentY = directY + Math.sin(perpAngle) * meander;
                    
                    const gx = Math.floor(currentX / cellSize);
                    const gy = Math.floor(currentY / cellSize);
                    const width = 1; // Consistent width for continuous rivers
                    
                    for (let dy = -width; dy <= width; dy++) {
                        for (let dx = -width; dx <= width; dx++) {
                            const nx = gx + dx;
                            const ny = gy + dy;
                            
                            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                                // Rivers don't override mountains
                                if (terrainGrid[ny][nx] !== TERRAIN_TYPES.MOUNTAIN) {
                                    terrainGrid[ny][nx] = TERRAIN_TYPES.RIVER;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Check if position is passable for units
        function isPassable(x, y) {
            const cellSize = 20;
            const gx = Math.floor(x / cellSize);
            const gy = Math.floor(y / cellSize);
            
            if (gy < 0 || gy >= terrainGrid.length || gx < 0 || gx >= terrainGrid[0].length) {
                return true; // Out of bounds = passable
            }
            
            return terrainGrid[gy][gx] !== TERRAIN_TYPES.MOUNTAIN;
        }
        
        // Get terrain type at position
        function getTerrainType(x, y) {
            // Safety check for NaN or invalid positions
            if (!isFinite(x) || !isFinite(y)) {
                return TERRAIN_TYPES.PASSABLE; // Default to passable if invalid
            }
            
            const cellSize = 20;
            const gx = Math.floor(x / cellSize);
            const gy = Math.floor(y / cellSize);
            
            if (gy < 0 || gy >= terrainGrid.length || gx < 0 || gx >= terrainGrid[0].length) {
                return TERRAIN_TYPES.PASSABLE;
            }
            
            return terrainGrid[gy][gx];
        }
        
        // Get movement speed multiplier for terrain
        function getTerrainSpeedMultiplier(x, y, vx, vy) {
            const terrain = getTerrainType(x, y);
            
            if (terrain === TERRAIN_TYPES.RIVER) {
                // Detect river direction by sampling neighboring cells
                const cellSize = 20;
                const searchRadius = 40;
                let riverDirX = 0;
                let riverDirY = 0;
                let riverCount = 0;
                
                // Sample in 8 directions to find river flow
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    const checkX = x + Math.cos(angle) * searchRadius;
                    const checkY = y + Math.sin(angle) * searchRadius;
                    
                    if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.RIVER) {
                        riverDirX += Math.cos(angle);
                        riverDirY += Math.sin(angle);
                        riverCount++;
                    }
                }
                
                if (riverCount > 0 && (vx !== 0 || vy !== 0)) {
                    // Normalize river direction
                    const riverMag = Math.sqrt(riverDirX * riverDirX + riverDirY * riverDirY);
                    if (riverMag > 0) {
                        riverDirX /= riverMag;
                        riverDirY /= riverMag;
                    }
                    
                    // Normalize movement direction
                    const moveMag = Math.sqrt(vx * vx + vy * vy);
                    let moveX = 0, moveY = 0;
                    if (moveMag > 0) {
                        moveX = vx / moveMag;
                        moveY = vy / moveMag;
                    }
                    
                    // Calculate alignment (-1 = perpendicular/crossing, 1 = parallel/along)
                    const alignment = Math.abs(riverDirX * moveX + riverDirY * moveY);
                    
                    // Along river (aligned): normal speed (0.85)
                    // Across river (perpendicular): slowed (0.55)
                    // Gentler penalty - rivers slow but don't block
                    return 0.55 + alignment * 0.30; // 0.55 when crossing, 0.85 when along
                }
                
                return 0.6; // Default if can't determine direction
            }
            
            switch(terrain) {
                case TERRAIN_TYPES.PASSABLE: return 0.85;
                case TERRAIN_TYPES.ROUGH: return 0.45;
                case TERRAIN_TYPES.RIVER: return 0.3; // Slow crossing
                case TERRAIN_TYPES.MOUNTAIN: return 0.0; // Truly impassable
                default: return 0.85;
            }
        }
        
        // Check if position is valid for nodes (not on mountains or rivers)
        function isLand(x, y) {
            const terrain = getTerrainType(x, y);
            return terrain === TERRAIN_TYPES.PASSABLE || terrain === TERRAIN_TYPES.ROUGH;
        }
        
        // Check if path crosses a river (for continental preference)
        function pathCrossesRiver(fromX, fromY, toX, toY) {
            const steps = 10; // Sample along path
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = fromX + (toX - fromX) * t;
                const y = fromY + (toY - fromY) * t;
                if (getTerrainType(x, y) === TERRAIN_TYPES.RIVER) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if position is good for node placement (clear of mountains with buffer)
        function isGoodNodeLocation(x, y) {
            if (!isLand(x, y)) return false;
            
            // Check buffer around position to ensure nodes aren't placed near mountains
            const bufferRadius = 40; // Keep nodes well away from mountains
            const checkPoints = 8;
            
            for (let i = 0; i < checkPoints; i++) {
                const angle = (i / checkPoints) * Math.PI * 2;
                const checkX = x + Math.cos(angle) * bufferRadius;
                const checkY = y + Math.sin(angle) * bufferRadius;
                
                if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                    return false; // Too close to mountain
                }
            }
            
            return true;
        }
        
        // Check if there's a clear path to target (no mountains in the way)
        function hasPathTo(fromX, fromY, toX, toY, maxDist = 500) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > maxDist) return false; // Too far
            
            // Sample points along the path
            const steps = Math.ceil(dist / 15); // Check every 15 units
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const checkX = fromX + dx * t;
                const checkY = fromY + dy * t;
                
                if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                    return false; // Mountain blocking path
                }
            }
            
            return true; // Clear path
        }
        
        // Draw terrain
        function drawWorldMap() {
            const cellSize = 20;
            
            // Draw terrain features
            for (let y = 0; y < terrainGrid.length; y++) {
                for (let x = 0; x < terrainGrid[y].length; x++) {
                    const terrain = terrainGrid[y][x];
                    const cellX = x * cellSize;
                    const cellY = y * cellSize;
                    
                    // Check if this cell is in a crater zone
                    let craterIntensity = 0;
                    let craterAge = 0;
                    for (const crater of craters) {
                        const dist = Math.hypot(cellX + cellSize/2 - crater.x, cellY + cellSize/2 - crater.y);
                        if (dist < crater.radius) {
                            // Intensity based on distance from crater center
                            const normalizedDist = dist / crater.radius;
                            const intensity = 1.0 - normalizedDist;
                            if (intensity > craterIntensity) {
                                craterIntensity = intensity;
                                craterAge = crater.age; // Use age from the strongest crater at this location
                            }
                        }
                    }
                    
                    if (terrain === TERRAIN_TYPES.MOUNTAIN) {
                        // Count mountain neighbors to determine if peak or edge
                        let mountainNeighbors = 0;
                        let totalNeighbors = 0;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < terrainGrid.length && nx >= 0 && nx < terrainGrid[0].length) {
                                    totalNeighbors++;
                                    if (terrainGrid[ny][nx] === TERRAIN_TYPES.MOUNTAIN) {
                                        mountainNeighbors++;
                                    }
                                }
                            }
                        }
                        
                        // Determine mountain color based on position
                        let baseColor;
                        let baseAlpha;
                        if (mountainNeighbors >= 6) {
                            // Peak - surrounded by mountains
                            baseColor = '#cccccc'; // Light gray (white peaks)
                            baseAlpha = 0.9;
                        } else if (mountainNeighbors >= 3) {
                            // Mid-mountain
                            baseColor = '#666666'; // Medium gray
                            baseAlpha = 0.8;
                        } else {
                            // Edge mountain - transitioning to land
                            baseColor = '#333333'; // Dark gray
                            baseAlpha = 0.7;
                        }
                        
                        // Apply crater scarring if in blast zone
                        if (craterIntensity > 0) {
                            // Cooling effect: orange-red (0-30s) -> grey (30-120s) -> dark (120s+)
                            const coolingPhase = Math.min(craterAge / 120, 1.0); // 0-1 over 2 minutes
                            
                            if (coolingPhase < 0.25) {
                                // Fresh: Glowing orange-red
                                const r = Math.floor(200 + craterIntensity * 50); // 200-250 red
                                const g = Math.floor(80 + craterIntensity * 40);   // 80-120 green
                                const b = Math.floor(20);                          // 20 blue
                                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${baseAlpha * (0.7 + craterIntensity * 0.3)})`;
                            } else if (coolingPhase < 0.75) {
                                // Cooling: Grey-white ash
                                const grey = Math.floor(180 - (coolingPhase - 0.25) * 200); // 180->80
                                ctx.fillStyle = `rgba(${grey}, ${grey}, ${grey}, ${baseAlpha * 0.85})`;
                            } else {
                                // Cooled: Dark charred black
                                const dark = Math.floor(40 - (coolingPhase - 0.75) * 80); // 40->0
                                ctx.fillStyle = `rgba(${dark}, ${dark}, ${dark}, ${baseAlpha * 0.9})`;
                            }
                        } else {
                            ctx.fillStyle = baseColor;
                            ctx.globalAlpha = baseAlpha;
                        }
                        
                        ctx.fillRect(cellX, cellY, cellSize, cellSize);
                        ctx.globalAlpha = 1.0;
                    } else if (terrain === TERRAIN_TYPES.ROUGH) {
                        if (craterIntensity > 0) {
                            // Cooling effect for scorched vegetation
                            const coolingPhase = Math.min(craterAge / 120, 1.0);
                            
                            if (coolingPhase < 0.25) {
                                // Fresh: Bright orange-red flames
                                const r = Math.floor(200 + craterIntensity * 50);
                                const g = Math.floor(80 + craterIntensity * 40);
                                const b = Math.floor(20);
                                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.7 + craterIntensity * 0.3})`;
                            } else if (coolingPhase < 0.75) {
                                // Cooling: Grey ash
                                const grey = Math.floor(140 - (coolingPhase - 0.25) * 160);
                                ctx.fillStyle = `rgba(${grey}, ${grey}, ${grey}, 0.6)`;
                            } else {
                                // Cooled: Black charcoal
                                const dark = Math.floor(30 - (coolingPhase - 0.75) * 60);
                                ctx.fillStyle = `rgba(${dark}, ${dark}, ${dark}, 0.8)`;
                            }
                        } else {
                            ctx.fillStyle = '#1a1a1a';
                            ctx.globalAlpha = 0.4;
                        }
                        ctx.fillRect(cellX, cellY, cellSize, cellSize);
                        ctx.globalAlpha = 1.0;
                    } else if (terrain === TERRAIN_TYPES.RIVER) {
                        // Rivers clear quickly - brief steam effect only
                        if (craterIntensity > 0 && craterAge < 30) {
                            // Only show effect for first 30 seconds
                            const fadePhase = craterAge / 30; // 0-1 over 30 seconds
                            
                            if (fadePhase < 0.33) {
                                // Fresh: White-hot steam/boiling (0-10s)
                                const bright = Math.floor(220 - craterIntensity * 20);
                                const alpha = (0.7 + craterIntensity * 0.2) * (1.0 - fadePhase * 2);
                                ctx.fillStyle = `rgba(${bright}, ${bright}, ${bright}, ${alpha})`;
                                ctx.fillRect(cellX, cellY, cellSize, cellSize);
                            } else if (fadePhase < 0.67) {
                                // Cooling: Grey mist settling (10-20s)
                                const grey = Math.floor(160 - (fadePhase - 0.33) * 300);
                                const alpha = 0.5 * (1.0 - (fadePhase - 0.33) * 2);
                                ctx.fillStyle = `rgba(${grey}, ${grey}, ${grey}, ${alpha})`;
                                ctx.fillRect(cellX, cellY, cellSize, cellSize);
                            }
                            // After 20s, just show normal river (no dark contamination)
                        }
                        // Always draw the river underneath
                        ctx.fillStyle = '#0066cc';
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(cellX, cellY, cellSize, cellSize);
                        ctx.globalAlpha = 1.0;
                    } else if (craterIntensity > 0) {
                        // Plain ground in crater - cooling effect
                        const coolingPhase = Math.min(craterAge / 120, 1.0);
                        
                        if (coolingPhase < 0.25) {
                            // Fresh: Glowing orange-red
                            const r = Math.floor(200 + craterIntensity * 50);  // 200-250 red
                            const g = Math.floor(80 + craterIntensity * 40);   // 80-120 green  
                            const b = Math.floor(20);                           // 20 blue
                            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.7 + craterIntensity * 0.3})`;
                        } else if (coolingPhase < 0.75) {
                            // Cooling: Grey ash
                            const grey = Math.floor(150 - (coolingPhase - 0.25) * 180); // 150->60
                            ctx.fillStyle = `rgba(${grey}, ${grey}, ${grey}, 0.7)`;
                        } else {
                            // Cooled: Dark scorched earth
                            const dark = Math.floor(35 - (coolingPhase - 0.75) * 70); // 35->0
                            ctx.fillStyle = `rgba(${dark}, ${dark}, ${dark}, 0.8)`;
                        }
                        ctx.fillRect(cellX, cellY, cellSize, cellSize);
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }
        
        const nodes = [];
        
        // Artillery class for underdog support
        class Artillery {
            constructor(x, y, firingNation, targetNation, damageMultiplier = 1.0, inaccuracy = 0) {
                this.x = x;
                this.y = y;
                // Apply inaccuracy offset to target position
                this.targetX = x + (Math.random() - 0.5) * inaccuracy;
                this.targetY = y + (Math.random() - 0.5) * inaccuracy;
                this.firingNation = firingNation; // Nation receiving artillery support
                this.targetNation = targetNation; // Enemy being targeted
                this.age = 0;
                this.maxAge = 1.0; // 1 second until explosion
                this.exploded = false;
                this.soundPlayed = false; // Track if incoming sound has been played
                this.blastRadius = 25; // Blast radius for devastating effect
                this.damageMultiplier = damageMultiplier; // Scales damage based on population
            }
            
            update(dt, nations) {
                this.age += dt;
                
                // Play incoming sound early so whistle plays during descent and explosion at impact
                // Sound takes 0.8s total (0.4s whistle + 0.4s explosion)
                // Play at 0.6s so explosion hits at 1.0s impact
                if (!this.soundPlayed && this.age >= 0.6) {
                    this.soundPlayed = true;
                    Audio.playArtillery(this.targetX, this.targetY);
                }
                
                // Explode at end of lifetime
                if (!this.exploded && this.age >= this.maxAge) {
                    this.exploded = true;
                    
                    // Check if artillery hit a node - WAR CRIME (only if direct hit)
                    let hitNode = null;
                    nodes.forEach(node => {
                        const dist = Math.hypot(node.x - this.targetX, node.y - this.targetY);
                        // Only count as war crime if VERY close to node center (15 units vs 25 blast radius)
                        // AND don't hit your own nodes!
                        if (dist < 15 && node.owner !== this.firingNation) {
                            // Artillery hit a node - add significant fatigue
                            const artilleryFatigue = 18; // Reduced from 25 - still severe but not overwhelming
                            node.fatigue = Math.min(100, node.fatigue + artilleryFatigue);
                            hitNode = node;
                            
                        }
                    });
                    
                    // Record war crime for diplomatic consequences
                    if (hitNode) {
                        const firingNation = nations[this.firingNation];
                        firingNation.warCrimes++;
                        firingNation.recentWarCrimes.push({ time: Date.now(), targetNode: hitNode });
                        
                        // Announce war crime strikes on cryptic nodes (only if not your own)
                        if (hitNode.crypticName && hitNode.owner !== this.firingNation) {
                            const nodeName = hitNode.crypticName;
                            if (!firingNation.capitulated) {
                                Audio.announce(`Long range bombardment detected. ${firingNation.name} engaging ${nodeName}`, 'high', firingNation.id);
                            }
                        }
                        
                        // Clean old war crimes (older than 2 minutes - reduced from 5)
                        const twoMinutesAgo = Date.now() - 120000;
                        firingNation.recentWarCrimes = firingNation.recentWarCrimes.filter(wc => wc.time > twoMinutesAgo);
                    }
                    
                    // Damage nearby units of TARGET nation (enemies)
                    const nation = nations[this.targetNation];
                    if (nation && !nation.capitulated) {
                        nation.units.forEach(unit => {
                            const dist = Math.hypot(unit.x - this.targetX, unit.y - this.targetY);
                            if (dist < this.blastRadius) {
                                // Damage scales with population-based multiplier
                                const baseDamage = 150 * (1 - (dist / this.blastRadius) * 0.75);
                                const damage = baseDamage * this.damageMultiplier;
                                unit.health -= damage;
                            }
                        });
                    }
                }
                
                return this.age < this.maxAge + 0.5; // Longer linger for visual effect
            }
            
            draw() {
                const nation = nations[this.firingNation]; // Use firing nation's color
                if (!nation) return;
                
                if (!this.exploded) {
                    // Falling indicator - more visible
                    const progress = this.age / this.maxAge;
                    ctx.strokeStyle = nation.color;
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, 15 - progress * 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner glow
                    ctx.fillStyle = nation.color;
                    ctx.globalAlpha = 0.3 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                } else {
                    // Explosion effect - much more visible
                    const explosionAge = this.age - this.maxAge;
                    const explosionProgress = explosionAge / 0.5; // Longer explosion duration
                    const radius = this.blastRadius * explosionProgress;
                    
                    // Outer ring
                    ctx.strokeStyle = nation.color;
                    ctx.lineWidth = 5;
                    ctx.globalAlpha = 1.0 * (1 - explosionProgress);
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner fill
                    ctx.fillStyle = nation.color;
                    ctx.globalAlpha = 0.4 * (1 - explosionProgress);
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }
        }
        
        const artillery = [];
        
        // Helper function to get artifact bonuses for a nation
        function getArtifactBonuses(nationId) {
            const bonuses = {
                superweaponDamage: 1.0,
                nodeCapture: 1.0,
                superweaponBuild: 1.0,
                unitSpeed: 1.0,
                unitDamage: 1.0,
                resourceIncome: 1.0,
                unitProduction: 1.0
            };
            
            // Get artifacts owned by this nation
            const ownedArtifacts = artifacts.filter(a => a.capturedBy === nationId);
            const ownedTypes = ownedArtifacts.map(a => a.type);
            
            // Also check node inventories for this nation
            const myNodes = nodes.filter(n => n.owner === nationId && n.crypticName);
            myNodes.forEach(node => {
                node.inventory.forEach(artifactType => {
                    if (!ownedTypes.includes(artifactType)) {
                        ownedTypes.push(artifactType);
                    }
                });
            });
            
            const nation = nations[nationId];
            const capitalNode = nation ? nation.capital : null;
            const myNamedNodes = nodes.filter(n => n.owner === nationId && n.crypticName);
            
            artifacts.forEach(artifact => {
                // === STANDALONE BONUSES (always active when owned) ===
                if (artifact.capturedBy === nationId) {
                    if (artifact.type === 'auth_code') {
                        bonuses.unitDamage *= 2.0; // Authorization Code: 2x damage
                    } else if (artifact.type === 'weapon') {
                        bonuses.unitDamage *= 1.5; // Advanced Weapon: 1.5x damage
                    }
                }
                
                // === LOCATION-BASED BONUSES (must be at capital or named node) ===
                if (artifact.capturedBy === nationId && artifact.movable) {
                    const atCapital = capitalNode && artifact.storedAtNode === capitalNode;
                    const atMyNode = artifact.storedAtNode && myNamedNodes.includes(artifact.storedAtNode);
                    const available = atCapital || atMyNode;
                    
                    if (available) {
                        // Spear of Longitude at capital
                        if (artifact.type === 'spear') {
                            const hasDecryptedKeycode = artifacts.some(a => 
                                a.type === 'keycode' && 
                                a.capturedBy === nationId && 
                                a.isDecrypted
                            );
                            if (hasDecryptedKeycode) {
                                bonuses.superweaponDamage *= 3.0; // Spear + decrypted Keycode = 3x
                            } else {
                                bonuses.superweaponDamage *= 2.0; // Spear alone = 2x
                            }
                        }
                        
                        // Advanced Blueprint + Research Data combo
                        else if (artifact.type === 'blueprint' && ownedTypes.includes('data')) {
                            bonuses.nodeCapture *= 4.0; // Blueprint + Data = 4x capture
                        }
                        
                        // Studied Strategic Plans (NO weapon requirement) - TIMED BONUS
                        // Only apply once even if multiple studied plans exist (prevent stacking)
                        else if (artifact.type === 'plans' && artifact.isStudied && artifact.bonusActive && bonuses.unitSpeed === 1.0) {
                            bonuses.unitSpeed = 2.5; // Studied Plans = 2.5x speed (temporary, non-stacking)
                        }
                        
                        // Decrypted Keycode alone
                        else if (artifact.type === 'keycode' && artifact.isDecrypted) {
                            bonuses.nodeCapture *= 2.0; // Decrypted Keycode = 2x capture
                        }
                    }
                }
                
                // === FACILITY BONUSES (unlocked facilities, controlled by having units nearby) ===
                // Secure-locked facilities still provide bonuses while controlled
                // TRADEOFF: Each facility creates vulnerabilities!
                if (!artifact.movable && (artifact.isUnlocked || artifact.isSecureLocked) && nation && nation.units) {
                    const unitsNearFacility = nation.units.filter(u => 
                        Math.hypot(u.x - artifact.x, u.y - artifact.y) < 100
                    );
                    
                    if (unitsNearFacility.length > 0) {
                        if (artifact.type === 'reactor') {
                            bonuses.unitProduction *= 1.5; // Fusion Reactor = 1.5x production (reduced for pacing)
                            // VULNERABILITY: Reactor is volatile - creates heat signature for enemies
                            bonuses.visibility = (bonuses.visibility || 1.0) * 1.3; // 30% more visible
                        } else if (artifact.type === 'prototype') {
                            bonuses.unitDamage *= 2.0; // Weapon Prototype = 2x damage (reduced for pacing)
                            // VULNERABILITY: Prototype weapons drain morale (experimental, unreliable)
                            bonuses.moraleDrain = (bonuses.moraleDrain || 0) + 0.05; // -5% morale per second
                        } else if (artifact.type === 'lab') {
                            // VULNERABILITY: Research Lab reveals intel to enemies (radio signals, data leaks)
                            bonuses.intelLeak = true; // Enemy artillery 20% more accurate against this nation
                        } else if (artifact.type === 'safe') {
                            // VULNERABILITY: Safe attracts enemy artifact seekers (valuable target)
                            bonuses.priorityTarget = true; // Enemies prioritize attacking nodes near safe
                        }
                        // Note: Lab no longer gives build speed bonus (that's from consumed Research Data)
                        // Note: Safe no longer gives resource bonus (it's a container for Spear)
                    }
                }
            });
            
            // === CONSUMED ARTIFACTS (permanent bonuses) ===
            // Track consumed Research Data bonuses
            if (!nation.consumedBonuses) nation.consumedBonuses = { dataConsumed: 0 };
            bonuses.superweaponBuild *= (1.0 + nation.consumedBonuses.dataConsumed * 2.0); // Each consumed Data = +2x
            
            return bonuses;
        }
        
        // Special artifacts and items that spawn on the map
        // COMPLETE PUZZLE SYSTEM - Narrative-driven unlock chains:
        //
        // === RESEARCH LAB CHAIN (Scientific Discovery) ===
        // 1. Find Lab Access Key (movable item)
        // 2. Bring key to Research Lab → unlocks instantly
        // 3. Inside Lab: Research Data + Armored Safe
        // 4. Research Data: Study at Lab (60s) → Send to capital → Consume for 2x superweapon build boost
        // 5. Lab generates new Research Data while controlled (every 120s)
        // 6. Find Safe Combination (movable item)
        // 7. Bring combo to Safe (inside Lab) → unlocks instantly
        // 8. Inside Safe: Spear of Longitude
        // 9. Bring Spear to capital → Superweapon wields it (needs Keycode for 3x damage)
        //
        // === MILITARY AUTHORIZATION CHAIN (Weapons Access) ===
        // 1. Find Security Access Card (movable item)
        // 2. Bring card to Fusion Reactor → unlocks instantly (or 7 min crack)
        // 3. Reactor grants 1.5x production while controlled
        // 4. Find Authorization Code (movable item, 2x damage standalone)
        // 5. Bring auth code to Weapon Prototype → unlocks instantly (or 8 min hack)
        // 6. Prototype grants 2x unit damage while controlled
        //
        // === TACTICAL INTELLIGENCE CHAIN (Strategic Operations) ===
        // 1. Find Keycode (encrypted spawn - appears locked)
        // 2. Bring to Archive node (Intelligence buff) → Decrypt (90s)
        // 3. Decrypted Keycode: 2x node capture + enables Blueprint generation
        // 4. Advanced Blueprint generates at Forge nodes (Efficiency buff) every 180s
        // 5. Blueprint + Research Data (from Lab) → 4x node capture at capital
        //
        // === FIELD OPERATIONS CHAIN (Mobile Warfare) ===
        // 1. Find Advanced Weapon (movable item, 1.5x damage standalone)
        // 2. Strategic Plans generate at Nexus nodes (Movement Hub) every 150s
        // 3. Study Plans at Nexus (75s) → 2.5x unit speed boost
        //
        // MECHANICS:
        // - Study: Time-based research at specific nodes (Research Data, Strategic Plans)
        // - Decrypt: Unlock encrypted items at Archive nodes (Keycode)
        // - Generate: Produce artifacts at controlled special nodes (Data, Plans, Blueprints)
        // - Consume: Use at capital for permanent boosts (studied Research Data)
        // - Nested: Items inside facilities (Safe in Lab, Spear in Safe)
        //
        
        // Helper: Find valid position near target (avoid mountains/obstacles)
        function findValidDropPosition(x, y, maxDistance = 100) {
            // Check if current position is valid
            if (isGoodNodeLocation(x, y)) {
                return { x, y };
            }
            
            // Spiral outward to find valid position
            for (let radius = 20; radius <= maxDistance; radius += 20) {
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    const testX = x + Math.cos(angle) * radius;
                    const testY = y + Math.sin(angle) * radius;
                    
                    if (isGoodNodeLocation(testX, testY)) {
                        return { x: testX, y: testY };
                    }
                }
            }
            
            // Fallback: return original position if no valid spot found
            return { x, y };
        }
        
        class SpecialArtifact {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.capturedBy = -1; // Nation ID that captured it
                this.captureProgress = 0; // Progress toward capture (0-100)
                this.captureRadius = 50;
                this.requires = null; // Artifact type required to unlock bonus
                this.hasAnnounced = false; // Track if unlock has been announced
                this.unlocks = null; // What this unlocks when paired
                this.unlockProgress = 0; // Progress toward cracking/unlocking (0-100)
                this.isUnlocked = false; // Whether facility has been unlocked (with or without key)
                
                // New mechanics
                this.studyProgress = 0; // Progress toward completing study (0-100)
                this.studyTime = 0; // Time required to study (seconds)
                this.isStudied = false; // Whether item has been studied
                this.bonusDuration = 0; // How long bonus lasts after studied (seconds)
                this.bonusTimeRemaining = 0; // Time remaining on active bonus (seconds)
                this.bonusActive = false; // Whether the bonus is currently active
                this.decryptProgress = 0; // Progress toward decryption (0-100)
                this.decryptTime = 0; // Time required to decrypt
                this.isDecrypted = false; // Whether encrypted item is decrypted
                this.generationTimer = 0; // Timer for generating new artifacts
                this.generationInterval = 0; // How often to generate
                this.containedItems = []; // Items inside this container (for nested artifacts)
                this.containerArtifact = null; // Reference to container holding this item
                this.consumedAt = null; // Node where this was consumed (for permanent boosts)
                this.isConsumed = false; // Whether item was consumed for boost
                
                // Degradation system for research/blueprints
                this.createdAt = 0; // When this artifact was created/generated
                this.degradationTime = 0; // How long until it degrades (0 = doesn't degrade)
                this.degradationStage = 0; // 0 = fresh, 1 = degraded, 2 = trash
                this.qualityMultiplier = 1.0; // 1.0 = full value, reduces as it degrades
                
                // Spawn and capture pacing
                this.spawnDelay = 0; // Seconds before artifact appears in game
                this.hasSpawned = false; // Whether artifact is visible/active yet
                this.captureSpeed = 1.0; // Multiplier for capture time (lower = harder to capture)
                this.spawnTime = 0; // When this artifact was created (for delay tracking)
                
                // Default values (safety check)
                this.name = 'Unknown Artifact';
                this.bonus = {};
                this.color = '#FFFFFF';
                this.movable = true; // Can be carried by units (default)
                
                // Type-specific properties
                // === RESEARCH LAB CHAIN ===
                if (type === 'lab') {
                    this.name = 'Research Lab';
                    this.bonus = {}; // No standalone bonus
                    this.requires = 'lab_key';
                    this.unlocks = 'Unlocks Research Data generation + reveals Armored Safe';
                    this.crackTime = 300; // 5 minutes to crack without key
                    this.color = '#00FFFF';
                    this.movable = false; // FACILITY - stationary
                    this.generationInterval = 120; // Generate Research Data every 2 minutes while controlled
                    this.spawnDelay = 90; // Appears 90 seconds into game
                    this.captureSpeed = 0.35; // Major facility - very slow capture
                    this.hasSpawned = false;
                } else if (type === 'lab_key') {
                    this.name = 'Lab Access Key';
                    this.bonus = {};
                    this.color = '#00AAAA';
                    this.movable = true;
                    this.spawnDelay = 0; // Available immediately
                    this.captureSpeed = 1.2; // Easier to grab
                    this.hasSpawned = true;
                } else if (type === 'data') {
                    this.name = 'Research Data';
                    this.description = 'Study at Lab (60s) → Bring to Capital → Consume for 2x superweapon build speed (degrades over 3min)';
                    this.bonus = {}; // No bonus until studied + consumed
                    this.studyTime = 60; // Must study at Lab for 1 minute
                    this.color = '#3333FF';
                    this.movable = true;
                    this.hasSpawned = true; // Generated later
                    this.degradationTime = 180; // Degrades over 3 minutes (fresh 0-120s, degraded 120-180s, trash after 180s)
                    this.createdAt = performance.now() / 1000;
                    // After study: consume at capital for 2x superweapon build (permanent)
                } else if (type === 'safe') {
                    this.name = 'Armored Safe';
                    this.bonus = {}; // Container - no bonus, contains Spear
                    this.requires = 'safe_key';
                    this.unlocks = 'Reveals Spear of Longitude';
                    this.crackTime = 600; // 10 minutes to crack without combination
                    this.color = '#888888';
                    this.movable = false; // FACILITY - inside Lab, revealed when Lab unlocked
                    this.hasSpawned = false; // Revealed when Lab unlocked
                    this.captureSpeed = 0.5; // Very hard to crack
                } else if (type === 'safe_key') {
                    this.name = 'Safe Combination';
                    this.bonus = {};
                    this.color = '#FFAA00';
                    this.movable = true;
                    this.spawnDelay = 120; // Appears 2 minutes in
                    this.captureSpeed = 1.0;
                    this.hasSpawned = false;
                } else if (type === 'spear') {
                    this.name = 'Spear of Longitude';
                    this.bonus = {}; // Bonus applied when at capital with Keycode
                    this.color = '#FFD700';
                    this.movable = true;
                    this.hasSpawned = false; // Inside safe
                    this.captureSpeed = 0.8; // Valuable, harder to secure
                    // At capital: 2x superweapon damage, 3x with decrypted Keycode
                }
                
                // === MILITARY AUTHORIZATION CHAIN ===
                else if (type === 'reactor') {
                    this.name = 'Fusion Reactor';
                    this.bonus = {}; // Bonus when unlocked + controlled
                    this.requires = 'access_card';
                    this.unlocks = 'Unlocks 1.5x production rate';
                    this.crackTime = 420; // 7 minutes to bypass without card
                    this.color = '#FFFF00';
                    this.movable = false; // FACILITY - stationary
                    this.spawnDelay = 60; // Appears 1 minute in
                    this.captureSpeed = 0.6; // Hard to capture
                    this.hasSpawned = false;
                } else if (type === 'access_card') {
                    this.name = 'Security Access Card';
                    this.bonus = {};
                    this.color = '#FF8800';
                    this.movable = true;
                    this.spawnDelay = 30; // Appears 30 seconds in
                    this.captureSpeed = 1.0;
                    this.hasSpawned = false;
                } else if (type === 'auth_code') {
                    this.name = 'Authorization Code';
                    this.bonus = { unitDamage: 2.0 }; // 2x damage standalone
                    this.color = '#00FF88';
                    this.movable = true;
                    this.spawnDelay = 105; // Appears 1.75 minutes in
                    this.captureSpeed = 1.0;
                    this.hasSpawned = false;
                } else if (type === 'prototype') {
                    this.name = 'Weapon Prototype';
                    this.bonus = {}; // Bonus when unlocked + controlled
                    this.requires = 'auth_code';
                    this.unlocks = 'Unlocks 2x unit damage';
                    this.crackTime = 480; // 8 minutes to hack without auth code
                    this.color = '#FF0088';
                    this.movable = false; // FACILITY - stationary
                    this.spawnDelay = 75; // Appears 1.25 minutes in
                    this.captureSpeed = 0.65; // Hard to capture
                    this.hasSpawned = false;
                }
                
                // === TACTICAL INTELLIGENCE CHAIN ===
                else if (type === 'keycode') {
                    this.name = 'Encrypted Keycode';
                    this.description = 'Decrypt at Intelligence node (90s) → 2x node capture speed + unlocks Blueprint generation';
                    this.bonus = {}; // No bonus until decrypted
                    this.decryptTime = 90; // Must decrypt at Archive (Intelligence) nodes
                    this.color = '#FFFF00';
                    this.movable = true;
                    this.spawnDelay = 150; // Appears 2.5 minutes in
                    this.captureSpeed = 0.9; // Slightly harder
                    this.hasSpawned = false;
                    // After decryption: 2x node capture + unlocks Blueprint generation
                } else if (type === 'blueprint') {
                    this.name = 'Advanced Blueprint';
                    this.bonus = {}; // Requires Research Data for full effect
                    this.requires = 'data';
                    this.unlocks = 'With Research Data: 4x node capture';
                    this.color = '#8800FF';
                    this.movable = true;
                    this.spawnDelay = 180; // Appears 3 minutes in
                    this.captureSpeed = 0.85; // Harder to secure
                    this.hasSpawned = false;
                    this.degradationTime = 240; // Degrades over 4 minutes (fresh 0-160s, degraded 160-240s, trash after 240s)
                    // Generated at Forge (Efficiency) nodes when Keycode is decrypted
                }
                
                // === FIELD OPERATIONS CHAIN ===
                else if (type === 'weapon') {
                    this.name = 'Advanced Weapon';
                    this.bonus = { unitDamage: 1.5 }; // 1.5x damage standalone
                    this.color = '#FF33FF';
                    this.movable = true;
                    this.spawnDelay = 45; // Appears 45 seconds in
                    this.captureSpeed = 1.0;
                    this.hasSpawned = false;
                } else if (type === 'plans') {
                    this.name = 'Strategic Plans';
                    this.bonus = {}; // No bonus until studied
                    this.studyTime = 75; // Must study at Nexus (Movement Hub) nodes
                    this.bonusDuration = 120; // Bonus lasts for 2 minutes after study
                    this.color = '#33FF33';
                    this.movable = true;
                    this.spawnDelay = 0; // Available immediately
                    this.captureSpeed = 1.1; // Easy to grab
                    this.hasSpawned = true;
                    this.degradationTime = 180; // Degrades over 3 minutes (fresh 0-120s, degraded 120-180s, trash after 180s)
                    this.createdAt = performance.now() / 1000;
                    // After study: 2.5x speed at capital (NO weapon requirement)
                    // Generated at Nexus nodes while controlled
                }
            }
            
            update(dt, resistanceIntensityMap = {}) {
                // Don't update artifacts that haven't spawned yet - prevents invisible captures
                if (!this.hasSpawned) return;
                
                // AUTOMATIC KEY DELIVERY SYSTEM - DISABLED
                // Proximity unlock handles this now - keys must be brought to facilities
                // (Old flying animation system removed to prevent conflicts with proximity unlock)
                
                // ANIMATE KEY FLYING TO FACILITY
                if (this.isFlyingToFacility && this.targetFacility) {
                    this.flyingProgress += dt * 0.5; // 2 second flight
                    
                    if (this.flyingProgress >= 1.0) {
                        // KEY ARRIVED - UNLOCK FACILITY
                        this.targetFacility.isUnlocked = true;
                        this.targetFacility.unlockProgress = 100;
                        this.targetFacility.crackingNation = undefined;
                        
                        const nation = nations[this.capturedBy];
                        if (nation && !this.targetFacility.hasAnnounced) {
                            Audio.announce(`${nation.name} unlocks ${this.targetFacility.name}`, 'high', this.capturedBy);
                            this.targetFacility.hasAnnounced = true;
                            
                            // Spawn nested items
                            if (this.targetFacility.type === 'lab' && !this.targetFacility.hasSpawnedContents) {
                                const data = new SpecialArtifact(this.targetFacility.x, this.targetFacility.y, 'data');
                                artifacts.push(data);
                                this.targetFacility.hasSpawnedContents = true;
                                Audio.announce(`${nation.name} finds Research Data inside`, 'high', this.capturedBy);
                            } else if (this.targetFacility.type === 'safe' && !this.targetFacility.hasSpawnedContents) {
                                // ONLY ONE SPEAR - check if it already exists
                                const existingSpear = artifacts.find(a => a.type === 'spear');
                                if (!existingSpear) {
                                    const spear = new SpecialArtifact(this.targetFacility.x, this.targetFacility.y, 'spear');
                                    spear.containerArtifact = this.targetFacility;
                                    spear.hasSpawned = true; // Make it capturable immediately
                                    artifacts.push(spear);
                                    Audio.announce(`${nation.name} finds Spear of Longitude inside!`, 'high', this.capturedBy);
                                }
                                this.targetFacility.hasSpawnedContents = true;
                            }
                        }
                        
                        // KEY RETURNS TO STORAGE - find safest node
                        const ownedNodes = nodes.filter(n => n.owner === this.capturedBy);
                        if (ownedNodes.length > 0) {
                            // Prefer named nodes, prefer less crowded, prefer closer to capital, AVOID nodes with nearby enemies
                            const nation = nations[this.capturedBy];
                            let bestNode = null;
                            let bestScore = -Infinity;
                            
                            for (let node of ownedNodes) {
                                let score = 0;
                                if (node.crypticName) score += 100; // Named nodes preferred
                                const itemsStored = artifacts.filter(a => a.storedAtNode === node).length;
                                score -= itemsStored * 10; // Less crowded is better
                                if (nation.capital) {
                                    const distToCapital = Math.hypot(node.x - nation.capital.x, node.y - nation.capital.y);
                                    score -= distToCapital * 0.1; // Closer to capital is safer
                                }
                                
                                // CHECK FOR NEARBY ENEMY UNITS - heavily penalize threatened nodes
                                const nearbyEnemies = getNearbyUnits(node.x, node.y, 150).filter(u => 
                                    u.nation !== this.capturedBy && !nations[u.nation]?.capitulated
                                );
                                if (nearbyEnemies.length > 0) {
                                    score -= 1000; // Massive penalty for enemy presence - avoid entirely if possible
                                }
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestNode = node;
                                }
                            }
                            
                            if (bestNode) {
                                this.storedAtNode = bestNode;
                                this.x = bestNode.x;
                                this.y = bestNode.y;
                                if (!bestNode.inventory.includes(this.type)) {
                                    bestNode.inventory.push(this.type);
                                }
                                Audio.announce(`${this.name} secured at ${bestNode.crypticName || 'node'}`, 'low', this.capturedBy);
                            }
                        }
                        
                        this.isFlyingToFacility = false;
                        this.targetFacility = null;
                    } else {
                        // Update position during flight (smooth interpolation)
                        const t = this.flyingProgress;
                        // Ease-in-out for smooth motion
                        const easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                        this.x = this.flyingSourceX + (this.flyingToX - this.flyingSourceX) * easedT;
                        this.y = this.flyingSourceY + (this.flyingToY - this.flyingSourceY) * easedT;
                    }
                    
                    return; // Skip other logic while flying
                }
                
                // ARTIFACT CARRIED BY UNIT - only movable items can be carried
                if (this.carrier && this.capturedBy >= 0 && this.movable) {
                    const nation = nations[this.capturedBy];
                    
                    // SUPERWEAPON CARRIER: Skip all logic - only death releases the artifact
                    // Superweapon wields it as part of their icon, not as separate item
                    if (this.carrier.isSuperweapon) {
                        this.x = this.carrier.x;
                        this.y = this.carrier.y;
                        return; // Skip all other logic - carrier death handles drop
                    }
                    
                    // Check if carrier still exists and alive
                    if (!nation || nation.capitulated || !nation.units.includes(this.carrier) || this.carrier.health <= 0) {
                        // Carrier died/removed, drop artifact at valid position
                        const validPos = findValidDropPosition(this.x, this.y);
                        this.x = validPos.x;
                        this.y = validPos.y;
                        
                        // CLEAR BOTH PROPERTIES - critical for spear duplication prevention
                        if (this.type === 'spear' && this.carrier) {
                            if (this.carrier.carriedSpear === this) {
                                this.carrier.carriedSpear = null;
                            }
                        }
                        this.carrier = null;
                        this.capturedBy = -1;
                        this.captureProgress = 0;
                        this.hasAnnounced = false;
                        if (this.storedAtNode) {
                            const idx = this.storedAtNode.inventory.indexOf(this.type);
                            if (idx >= 0) this.storedAtNode.inventory.splice(idx, 1);
                            this.storedAtNode = null;
                        }
                        return;
                    }
                    
                    // Follow carrier
                    this.x = this.carrier.x;
                    this.y = this.carrier.y;
                    
                    // Check if near storage locations - auto-deposit for storage (increased radius for faster securing)
                    // Storage locations: named nodes AND unlocked safe facilities AND capitals
                    const storageLocations = [];
                    
                    // Named nodes
                    nodes.filter(n => n.owner === this.capturedBy && n.crypticName).forEach(n => {
                        storageLocations.push({ node: n, name: n.crypticName, isFacility: false });
                    });
                    
                    // Capital (fallback if no cryptic nodes available)
                    if (nation && nation.capital && nation.capital.owner === this.capturedBy) {
                        // Add capital if not already added (some capitals have cryptic names)
                        if (!storageLocations.find(s => s.node === nation.capital)) {
                            storageLocations.push({ node: nation.capital, name: 'Capital', isFacility: false });
                        }
                    }
                    
                    // Unlocked safe facilities (act as secure storage after spear is obtained)
                    // DON'T store artifact in its own container (prevents spear/safe loop)
                    artifacts.filter(a => 
                        a.type === 'safe' && 
                        a.isUnlocked && 
                        a.hasSpawnedContents && // Spear has been taken out
                        a !== this.containerArtifact // Don't store artifact back in its own container!
                    ).forEach(safe => {
                        const safeName = safe.capturedBy === this.capturedBy ? 'Allied Safe' : 'Armored Safe';
                        storageLocations.push({ node: safe, name: safeName, isFacility: true });
                    });
                    
                    for (let storage of storageLocations) {
                        const dist = Math.hypot(storage.node.x - this.x, storage.node.y - this.y);
                        if (dist < 100) { // Within 100 units of storage location
                            // DEPOSIT ARTIFACT AT STORAGE
                            if (!storage.node.inventory) storage.node.inventory = [];
                            if (!storage.node.inventory.includes(this.type)) {
                                storage.node.inventory.push(this.type);
                            }
                            this.storedAtNode = storage.node;
                            
                            // Log artifact storage
                            logAIEvent('artifact', 'Artifact stored', {
                                artifactType: this.type,
                                storedAt: storage.name || (storage.node.crypticName || 'node'),
                                nationId: this.capturedBy,
                                isCapital: storage.node.isCapital || false,
                                isCryptic: !!storage.node.crypticName
                            });
                            
                            // CLEAR BOTH PROPERTIES - critical for spear
                            if (this.type === 'spear' && this.carrier) {
                                if (this.carrier.carriedSpear === this) {
                                    this.carrier.carriedSpear = null;
                                }
                            }
                            this.carrier = null; // Release carrier
                            this.x = storage.node.x;
                            this.y = storage.node.y;
                            // console.log(`${this.name} stored at ${storage.name} for nation ${this.capturedBy}`);
                            
                            // Special announcement for archiving studied plans
                            if (this.type === 'plans' && this.isStudied && this.carrier && this.carrier.role === 'archiveStudiedPlan') {
                                Audio.announce(`${nation.name} archives studied ${this.name} at ${storage.name}`, 'low', this.capturedBy);
                            } else {
                                // Normal storage announcement
                                Audio.announce(`${nation.name} secures ${this.name} at ${storage.name}`, 'medium', this.capturedBy);
                            }
                            break;
                        }
                    }
                    
                    // Check for unlock announcements
                    if (this.requires && this.unlocks && !this.hasAnnounced) {
                        const ownedTypes = artifacts.filter(a => a.capturedBy === this.capturedBy).map(a => a.type);
                        if (ownedTypes.includes(this.requires)) {
                            Audio.announce(`${nation.name} has unlocked the ${this.name}`, 'high', this.capturedBy);
                            this.hasAnnounced = true;
                        }
                    }
                    
                    return; // Being carried, skip normal capture logic
                }
                
                // STATIONARY FACILITY - stays at spawn location like a node
                if (!this.movable && this.capturedBy >= 0) {
                    // Facility captured - can be unlocked with key OR cracked over time
                    const nation = nations[this.capturedBy];
                    
                    // Dead/capitulated nations can't crack or unlock facilities
                    if (!nation || nation.capitulated) {
                        // Clear cracking if nation died
                        if (this.crackingNation === this.capturedBy) {
                            this.crackingNation = undefined;
                        }
                        return; // Skip all facility logic for dead nations
                    }
                    
                    // === RECAPTURE CHECK: Enemy units can capture facilities ===
                    // Check for both friendly and enemy units (contested capture like nodes)
                    let friendlyUnits = 0;
                    let enemyCapturing = null;
                    let maxEnemyPresence = 0;
                    
                    // Count friendly defenders
                    const friendlyNearby = getNearbyUnits(this.x, this.y, this.captureRadius)
                        .filter(u => u.nation === this.capturedBy);
                    friendlyUnits = friendlyNearby.length;
                    
                    // Find strongest enemy force
                    nations.forEach(enemyNation => {
                        if (enemyNation.id === this.capturedBy || enemyNation.units.length === 0) return;
                        
                        const enemyUnitsNearby = getNearbyUnits(this.x, this.y, this.captureRadius)
                            .filter(u => u.nation === enemyNation.id);
                        
                        if (enemyUnitsNearby.length > maxEnemyPresence) {
                            maxEnemyPresence = enemyUnitsNearby.length;
                            enemyCapturing = enemyNation;
                        }
                    });
                    
                    // CONTESTED CAPTURE: Enemy must OUTNUMBER defenders
                    if (enemyCapturing && maxEnemyPresence > friendlyUnits) {
                        // Enemy has numerical advantage - capture progress
                        const netAdvantage = maxEnemyPresence - friendlyUnits;
                        const captureSpeed = Math.min(netAdvantage, 5); // Cap at 5 net advantage
                        this.captureProgress += dt * 10 * captureSpeed; // 10 seconds with +1 advantage
                        
                        if (this.captureProgress >= 100) {
                            // SECURITY LOCK: If facility is unlocked, lock it before losing control!
                            if (this.isUnlocked) {
                                this.isSecureLocked = true;
                                this.isUnlocked = false;
                                Audio.announce(`${nation.name} ${this.name} enters security lockdown`, 'high', this.capturedBy);
                            }
                            
                            // Facility captured by enemy
                            const previousOwner = this.capturedBy;
                            this.capturedBy = enemyCapturing.id;
                            this.captureProgress = 0; // RESET to 0 after capture
                            this.hasAnnounced = false;
                            this.crackingNation = undefined; // Reset cracking
                            this.unlockProgress = 0; // Reset unlock progress
                            
                            // CHECK IF NEW OWNER HAS THE KEY - auto-unlock on recapture
                            if (this.requires && !this.isUnlocked) {
                                const newOwnerHasKey = artifacts.find(a => 
                                    a.type === this.requires && 
                                    a.capturedBy === enemyCapturing.id
                                );
                                
                                if (newOwnerHasKey) {
                                    // New owner has the key - instant unlock!
                                    this.isUnlocked = true;
                                    this.isSecureLocked = false;
                                    this.unlockProgress = 100;
                                    Audio.announce(`${enemyCapturing.name} captures and unlocks ${this.name} with ${newOwnerHasKey.name}`, 'high', enemyCapturing.id);
                                    
                                    // Spawn nested contents if not already spawned
                                    if (this.type === 'lab' && !this.hasSpawnedContents) {
                                        const data = new SpecialArtifact(this.x, this.y, 'data');
                                        artifacts.push(data);
                                        this.hasSpawnedContents = true;
                                        Audio.announce(`${enemyCapturing.name} finds Research Data inside`, 'high', enemyCapturing.id);
                                    } else if (this.type === 'safe' && !this.hasSpawnedContents) {
                                        // ONLY ONE SPEAR - check if it already exists
                                        const existingSpear = artifacts.find(a => a.type === 'spear');
                                        if (!existingSpear) {
                                            const spear = new SpecialArtifact(this.x, this.y, 'spear');
                                            spear.containerArtifact = this;
                                            spear.hasSpawned = true; // Make it capturable immediately
                                            artifacts.push(spear);
                                            Audio.announce(`${enemyCapturing.name} finds Spear of Longitude inside!`, 'high', enemyCapturing.id);
                                        }
                                        this.hasSpawnedContents = true;
                                    } else if (this.type === 'reactor' && !this.hasSpawnedContents) {
                                        const proto = new SpecialArtifact(this.x, this.y, 'prototype');
                                        proto.containerArtifact = this;
                                        artifacts.push(proto);
                                        this.hasSpawnedContents = true;
                                        Audio.announce(`${enemyCapturing.name} finds Experimental Prototype inside!`, 'high', enemyCapturing.id);
                                    }
                                } else {
                                    Audio.announce(`${enemyCapturing.name} captures ${this.name} from ${nation.name}`, 'high', enemyCapturing.id);
                                }
                            } else {
                                Audio.announce(`${enemyCapturing.name} captures ${this.name} from ${nation.name}`, 'high', enemyCapturing.id);
                            }
                        }
                    } else {
                        // Defenders hold or no enemies - decay capture progress faster
                        this.captureProgress = Math.max(0, this.captureProgress - dt * 30);
                    }
                    
                    // === RE-LOCKING: If unlocked facility loses its key, enter locked security state ===
                    if (this.isUnlocked && this.requires && !this.isSecureLocked) {
                        // Check if we still have the required key
                        const keyOwned = artifacts.find(a => 
                            a.type === this.requires && 
                            a.capturedBy === this.capturedBy
                        );
                        
                        if (!keyOwned) {
                            // Key has been lost! Enter locked security state
                            this.isSecureLocked = true;
                            this.isUnlocked = false; // Re-lock the facility
                            if (nation) {
                                Audio.announce(`${nation.name} loses ${this.requires} - ${this.name} enters locked security state`, 'high', this.capturedBy);
                            }
                            // Nation still controls facility and gets benefits, but it's locked again
                        }
                    }
                    
                    // === UNLOCKING FROM SECURITY LOCK: Key recovered ===
                    if (this.isSecureLocked && this.requires) {
                        const keyNearby = artifacts.find(a => 
                            a.type === this.requires && 
                            a.capturedBy === this.capturedBy &&
                            Math.hypot(a.x - this.x, a.y - this.y) < 150
                        );
                        
                        if (keyNearby) {
                            // Key recovered and brought back! Exit security lock
                            this.isSecureLocked = false;
                            this.isUnlocked = true;
                            if (nation) {
                                Audio.announce(`${nation.name} restores ${this.name} security with ${this.requires}`, 'high', this.capturedBy);
                            }
                        }
                    }
                    
                    // === PROXIMITY UNLOCK: Key must be brought NEAR facility to unlock ===
                    if (!this.isUnlocked && !this.isSecureLocked && this.requires) {
                        // Check if the required key is NEAR this facility (within 150 units)
                        // You must bring the key TO the facility, not just own it somewhere on the map!
                        const keyNearby = artifacts.find(a => 
                            a.type === this.requires && 
                            a.capturedBy === this.capturedBy &&
                            Math.hypot(a.x - this.x, a.y - this.y) < 150
                        );
                        
                        if (keyNearby && !keyNearby.isFlyingToFacility) {
                            // Key is near - trigger flying animation to visually unlock!
                            keyNearby.isFlyingToFacility = true;
                            keyNearby.flyingProgress = 0;
                            keyNearby.flyingSourceX = keyNearby.x;
                            keyNearby.flyingSourceY = keyNearby.y;
                            keyNearby.flyingToX = this.x;
                            keyNearby.flyingToY = this.y;
                            keyNearby.targetFacility = this;
                        }
                    }
                    
                    if (!this.isUnlocked && !this.isSecureLocked && this.requires && this.crackTime) {
                        // CHECK FIRST: Do we own the key anywhere? If yes, instant unlock (no units required)
                        const ownKey = artifacts.find(a => 
                            a.type === this.requires && 
                            a.capturedBy === this.capturedBy
                        );
                        
                        if (ownKey) {
                            // We already own the key - instant unlock, no units needed!
                            this.isUnlocked = true;
                            this.unlockProgress = 100;
                            this.crackingNation = undefined; // Clear cracking state
                            if (nation && !this.hasAnnounced) {
                                Audio.announce(`${nation.name} secures ${this.name}`, 'high', this.capturedBy);
                                this.hasAnnounced = true;
                            }
                            return; // Skip cracking logic entirely
                        }
                        
                        // ONLY crack (hack without key) if nation has units actively present at the facility
                        const unitsNearby = nation.units.filter(u => 
                            Math.hypot(u.x - this.x, u.y - this.y) < 100
                        );
                        
                        if (unitsNearby.length === 0) {
                            // No units present - can't crack, progress stops
                            return;
                        }
                        
                        // Check if ownership changed during cracking - facilities keep progress (persistent)
                        if (this.crackingNation !== undefined && this.crackingNation !== this.capturedBy) {
                            // Different nation now controls - they inherit the crack progress (facilities are persistent)
                            this.crackingNation = this.capturedBy;
                        } else if (this.crackingNation === undefined) {
                            // First time cracking
                            this.crackingNation = this.capturedBy;
                        }
                        
                        // Check if the required key/card/code is NEAR this facility (within 150 units)
                        // You must bring the key TO the facility, not just own it somewhere on the map!
                        const keyNearby = artifacts.find(a => 
                            a.type === this.requires && 
                            a.capturedBy === this.capturedBy &&
                            Math.hypot(a.x - this.x, a.y - this.y) < 150 // Key must be at or near facility
                        );
                        
                        // INSTANT UNLOCK: Key has been brought to the facility!
                        if (keyNearby && !keyNearby.isFlyingToFacility) {
                            // Trigger flying animation to visually unlock!
                            keyNearby.isFlyingToFacility = true;
                            keyNearby.flyingProgress = 0;
                            keyNearby.flyingSourceX = keyNearby.x;
                            keyNearby.flyingSourceY = keyNearby.y;
                            keyNearby.flyingToX = this.x;
                            keyNearby.flyingToY = this.y;
                            keyNearby.targetFacility = this;
                        } else if (!keyNearby) {
                            // Slow path: Cracking without key (persistent progress like nodes)
                            // Progress accumulates ONLY while actively controlled by the cracking nation
                            // Progress persists when ownership changes, but cracking stops until recaptured
                            if (this.capturedBy === this.crackingNation) {
                                this.unlockProgress += (dt / this.crackTime) * 100; // Progress over crackTime seconds
                            }
                            
                            if (this.unlockProgress >= 100) {
                                this.isUnlocked = true;
                                this.unlockProgress = 100;
                                this.crackingNation = undefined; // Clear cracking state
                                
                                // Announce BEFORE clearing capturedBy
                                const unlockingNation = nations[this.capturedBy];
                                if (unlockingNation && !this.hasAnnounced) {
                                    Audio.announce(`${unlockingNation.name} successfully cracks ${this.name}`, 'high', this.capturedBy);
                                    this.hasAnnounced = true;
                                }
                                
                                // === NESTED ITEM SPAWNING (cracking path) ===
                                if (this.type === 'lab' && !this.hasSpawnedContents) {
                                    // Lab cracked - spawn Research Data and Armored Safe inside
                                    const data = new SpecialArtifact(this.x, this.y, 'data');
                                    artifacts.push(data);
                                    this.hasSpawnedContents = true;
                                    if (unlockingNation) {
                                        Audio.announce(`${unlockingNation.name} finds Research Data inside`, 'medium', this.capturedBy);
                                    }
                                } else if (this.type === 'safe' && !this.hasSpawnedContents) {
                                    // Safe cracked - spawn Spear of Longitude inside
                                    // ONLY ONE SPEAR - check if it already exists
                                    const existingSpear = artifacts.find(a => a.type === 'spear');
                                    if (!existingSpear) {
                                        const spear = new SpecialArtifact(this.x, this.y, 'spear');
                                        spear.containerArtifact = this; // Track that Spear is inside Safe
                                        spear.hasSpawned = true; // Make it capturable immediately
                                        artifacts.push(spear);
                                        console.log(`SPEAR SPAWNED via cracking at (${this.x}, ${this.y}) for nation ${this.capturedBy}`);
                                        if (unlockingNation) {
                                            Audio.announce(`${unlockingNation.name} finds Spear of Longitude inside!`, 'high', this.capturedBy);
                                        }
                                    }
                                    this.hasSpawnedContents = true;
                                }
                                
                                // Once unlocked, facility becomes neutral (free for everyone to capture)
                                this.capturedBy = -1;
                                this.captureProgress = 0;
                            }
                        }
                    } else if (this.isUnlocked && !this.hasAnnounced && nation) {
                        // Facility already unlocked when captured - announce
                        Audio.announce(`${nation.name} captures unlocked ${this.name}`, 'high', this.capturedBy);
                        this.hasAnnounced = true;
                    }
                    
                    // === ARTIFACT GENERATION at controlled facilities ===
                    if (this.isUnlocked && this.generationInterval > 0 && nation) {
                        this.generationTimer += dt;
                        
                        if (this.generationTimer >= this.generationInterval) {
                            this.generationTimer = 0; // Reset timer
                            
                            // Generate specific artifacts based on facility type
                            if (this.type === 'lab') {
                                // Lab generates Research Data every 2 minutes
                                artifacts.push(new SpecialArtifact(this.x, this.y, 'data'));
                                Audio.announce(`${nation.name} generates Research Data at ${this.name}`, 'medium', this.capturedBy);
                            }
                        }
                    }
                    
                    return; // Stationary, skip normal movement logic
                }
                
                // === STUDY MECHANIC - Research Data and Strategic Plans ===
                if (this.studyTime > 0 && this.capturedBy >= 0 && this.storedAtNode && !this.isStudied) {
                    const nation = nations[this.capturedBy];
                    if (!nation) return;
                    
                    // Check if node ownership changed - RESET PROGRESS (short-term tasks)
                    if (this.studyingNode !== this.storedAtNode) {
                        // Moved to different node or node changed - reset study
                        this.studyProgress = 0;
                        this.studyingNode = this.storedAtNode;
                    }
                    
                    // Check if at correct node type for studying
                    let canStudy = false;
                    if (this.type === 'data') {
                        // Research Data must be studied at Lab (check if Lab artifact is at this node location)
                        const labAtNode = artifacts.find(a => 
                            a.type === 'lab' && 
                            a.isUnlocked &&
                            Math.hypot(a.x - this.storedAtNode.x, a.y - this.storedAtNode.y) < 50
                        );
                        canStudy = labAtNode !== undefined;
                    } else if (this.type === 'plans') {
                        // Strategic Plans must be studied at Nexus (Movement Hub) nodes
                        canStudy = this.storedAtNode.crypticData && this.storedAtNode.crypticData.buff === 'Movement Hub';
                    }
                    
                    if (canStudy) {
                        this.studyProgress += (dt / this.studyTime) * 100;
                        
                        if (this.studyProgress >= 100) {
                            this.isStudied = true;
                            this.studyProgress = 100;
                            
                            // Activate bonus if this artifact has a duration
                            if (this.bonusDuration > 0) {
                                this.bonusActive = true;
                                this.bonusTimeRemaining = this.bonusDuration;
                            }
                            
                            Audio.announce(`${nation.name} completes study of ${this.name}`, 'medium', this.capturedBy);
                        }
                    }
                }
                
                // === BONUS DURATION COUNTDOWN ===
                if (this.bonusActive && this.bonusTimeRemaining > 0) {
                    this.bonusTimeRemaining -= dt;
                    
                    if (this.bonusTimeRemaining <= 0) {
                        this.bonusActive = false;
                        this.bonusTimeRemaining = 0;
                        
                        const nation = nations[this.capturedBy];
                        if (nation) {
                            Audio.announce(`${nation.name}'s ${this.name} bonus expires`, 'low', this.capturedBy);
                        }
                    }
                }
                
                // === DECRYPT MECHANIC - Encrypted Keycode ===
                if (this.decryptTime > 0 && this.capturedBy >= 0 && this.storedAtNode && !this.isDecrypted) {
                    const nation = nations[this.capturedBy];
                    if (!nation) return;
                    
                    // Check if node ownership changed - RESET PROGRESS (short-term tasks)
                    if (this.decryptingNode !== this.storedAtNode) {
                        // Moved to different node or node changed - reset decrypt
                        this.decryptProgress = 0;
                        this.decryptingNode = this.storedAtNode;
                    }
                    
                    // Keycode must be decrypted at Archive (Intelligence buff) nodes
                    if (this.type === 'keycode' && this.storedAtNode.crypticData && this.storedAtNode.crypticData.buff === 'Intelligence') {
                        this.decryptProgress += (dt / this.decryptTime) * 100;
                        
                        if (this.decryptProgress >= 100) {
                            this.isDecrypted = true;
                            this.decryptProgress = 100;
                            Audio.announce(`${nation.name} decrypts ${this.name} - Blueprint generation enabled`, 'high', this.capturedBy);
                        }
                    }
                }
                
                // === CONSUME MECHANIC - Studied artifacts at capital ===
                if (this.isStudied && this.capturedBy >= 0 && this.storedAtNode && !this.isConsumed) {
                    const nation = nations[this.capturedBy];
                    if (!nation) return;
                    
                    // Check if at capital
                    const atCapital = nation.capital && this.storedAtNode === nation.capital;
                    
                    if (atCapital) {
                        if (this.type === 'data') {
                            // Consume Research Data at capital for permanent +2x superweapon build
                            if (!nation.consumedBonuses) nation.consumedBonuses = { dataConsumed: 0 };
                            nation.consumedBonuses.dataConsumed += 1;
                            
                            this.isConsumed = true;
                            this.consumedAt = this.storedAtNode;
                            
                            Audio.announce(`${nation.name} consumes Research Data - permanent 2x superweapon build boost`, 'high', this.capturedBy);
                            
                            // Remove from game
                            const idx = this.storedAtNode.inventory.indexOf(this.type);
                            if (idx >= 0) this.storedAtNode.inventory.splice(idx, 1);
                            this.storedAtNode = null;
                            this.capturedBy = -1;
                            
                            // Mark for removal from artifacts array (will be filtered in main loop)
                            this.shouldRemove = true;
                            return; // EXIT EARLY - artifact removed, nothing else to do
                        }
                    }
                }
                
                // ARTIFACT STORED AT NODE - movable items deposited at named nodes
                if (this.storedAtNode && this.capturedBy >= 0 && this.movable) {
                    // PROACTIVE EVACUATION: Try to evacuate artifact when node is being captured (before it falls)
                    const nation = nations[this.capturedBy];
                    if (nation && this.storedAtNode.owner === this.capturedBy && this.storedAtNode.capturingNation >= 0 && this.storedAtNode.capturingNation !== this.capturedBy) {
                        // Node is under attack! Chance to evacuate based on capture progress
                        const capturePercent = this.storedAtNode.captureProgress / 100;
                        const evacuationChance = 0.01 * capturePercent * dt; // 1% per second at full capture progress
                        
                        if (Math.random() < evacuationChance) {
                            // Emergency evacuation! Find nearby unit to extract artifact
                            const nearbyUnits = nation.units.filter(u => 
                                Math.hypot(u.x - this.storedAtNode.x, u.y - this.storedAtNode.y) < 150 &&
                                !artifacts.find(a => a.carrier === u)
                            );
                            
                            if (nearbyUnits.length > 0) {
                                const evacuator = nearbyUnits[Math.floor(Math.random() * nearbyUnits.length)];
                                // Remove from storage
                                const idx = this.storedAtNode.inventory.indexOf(this.type);
                                if (idx >= 0) this.storedAtNode.inventory.splice(idx, 1);
                                this.storedAtNode = null;
                                this.carrier = evacuator;
                                evacuator.role = 'evacuateArtifact';
                                evacuator.targetNode = nation.capital;
                                this.hasAnnounced = false;
                            }
                        }
                    }
                    
                    // Check if node still owned by same nation (only if artifact still stored)
                    if (this.storedAtNode && this.storedAtNode.owner !== this.capturedBy) {
                        // Node was captured! Evacuate artifact to safety
                        const newOwner = this.storedAtNode.owner;
                        const oldOwner = this.capturedBy;
                        
                        if (newOwner >= 0) {
                            const nation = nations[newOwner];
                            const oldNation = nations[oldOwner];
                            if (nation) {
                                // CAPITAL VULNERABILITY: If this is a capital with 4+ artifacts, ALL artifacts are lost!
                                // This creates massive incentive to spread artifacts across named nodes and safes
                                const isCapital = oldNation && oldNation.capital === this.storedAtNode;
                                const artifactsAtNode = artifacts.filter(a => a.storedAtNode === this.storedAtNode);
                                
                                if (isCapital && artifactsAtNode.length >= 4) {
                                    // CATASTROPHIC LOSS - all artifacts at capital are destroyed/scattered
                                    artifactsAtNode.forEach(art => {
                                        // Remove from inventory
                                        const idx = art.storedAtNode.inventory.indexOf(art.type);
                                        if (idx >= 0) art.storedAtNode.inventory.splice(idx, 1);
                                        
                                        // Drop artifact far from capital (scatter across map)
                                        const scatterAngle = Math.random() * Math.PI * 2;
                                        const scatterDist = 300 + Math.random() * 200;
                                        const validPos = findValidDropPosition(
                                            this.storedAtNode.x + Math.cos(scatterAngle) * scatterDist,
                                            this.storedAtNode.y + Math.sin(scatterAngle) * scatterDist
                                        );
                                        art.x = validPos.x;
                                        art.y = validPos.y;
                                        art.storedAtNode = null;
                                        art.capturedBy = -1; // Becomes unclaimed
                                        art.captureProgress = 0;
                                        
                                        // CLEAR BOTH PROPERTIES - critical for spear
                                        if (art.type === 'spear' && art.carrier) {
                                            if (art.carrier.carriedSpear === art) {
                                                art.carrier.carriedSpear = null;
                                            }
                                        }
                                        art.carrier = null;
                                        art.hasAnnounced = false;
                                        
                                        // Reset progress
                                        art.studyProgress = 0;
                                        art.decryptProgress = 0;
                                        art.studyingNode = null;
                                        art.decryptingNode = null;
                                    });
                                    
                                    if (oldNation) {
                                        Audio.announce(`${oldNation.name} capital overrun - ${artifactsAtNode.length} artifacts scattered!`, 'high', oldOwner);
                                    }
                                    Audio.announce(`${nation.name} sacks ${oldNation ? oldNation.name + "'s" : 'enemy'} capital - artifacts scattered!`, 'high', newOwner);
                                    return; // Skip normal evacuation - all artifacts lost
                                }
                                
                                // NEW OWNER: Evacuate to capital, then redistribute
                                // Remove from node inventory
                                const idx = this.storedAtNode.inventory.indexOf(this.type);
                                if (idx >= 0) this.storedAtNode.inventory.splice(idx, 1);
                                
                                // Find nearby unit to evacuate this item
                                const nearbyUnits = nation.units.filter(u => 
                                    Math.hypot(u.x - this.storedAtNode.x, u.y - this.storedAtNode.y) < 100 &&
                                    !artifacts.find(a => a.carrier === u) // Unit not already carrying something
                                );
                                
                                if (nearbyUnits.length > 0) {
                                    // Assign closest free unit to evacuate
                                    nearbyUnits.sort((a, b) => {
                                        const distA = Math.hypot(a.x - this.storedAtNode.x, a.y - this.storedAtNode.y);
                                        const distB = Math.hypot(b.x - this.storedAtNode.x, b.y - this.storedAtNode.y);
                                        return distA - distB;
                                    });
                                    
                                    const evacuator = nearbyUnits[0];
                                    this.carrier = evacuator;
                                    this.capturedBy = newOwner;
                                    this.storedAtNode = null;
                                    this.hasAnnounced = false;
                                    
                                    // RESET short-term progress tasks
                                    this.studyProgress = 0;
                                    this.decryptProgress = 0;
                                    this.studyingNode = null;
                                    this.decryptingNode = null;
                                    
                                    // Force immediate evacuation orders - go to capital first
                                    evacuator.orderTimer = 2.5; // Trigger receiveOrders immediately
                                    
                                    Audio.announce(`${nation.name} evacuates ${this.name} from captured node`, 'medium', newOwner);
                                } else {
                                    // No nearby units, just transfer ownership in place
                                    this.capturedBy = newOwner;
                                    this.hasAnnounced = false;
                                    this.studyProgress = 0;
                                    this.decryptProgress = 0;
                                    this.studyingNode = null;
                                    this.decryptingNode = null;
                                    
                                    Audio.announce(`${nation.name} captures ${this.name} at ${this.storedAtNode.crypticName}`, 'high', newOwner);
                                }
                            }
                        } else {
                            // Node became neutral, release artifact
                            this.capturedBy = -1;
                            const idx = this.storedAtNode.inventory.indexOf(this.type);
                            if (idx >= 0) this.storedAtNode.inventory.splice(idx, 1);
                            this.storedAtNode = null;
                        }
                    }
                    
                    // Check for unlock announcements (movable items at nodes)
                    if (this.capturedBy >= 0 && this.requires && this.unlocks && !this.hasAnnounced) {
                        const ownedTypes = artifacts.filter(a => a.capturedBy === this.capturedBy).map(a => a.type);
                        if (ownedTypes.includes(this.requires)) {
                            const nation = nations[this.capturedBy];
                            if (nation) {
                                Audio.announce(`${nation.name} has unlocked the ${this.name}`, 'high', this.capturedBy);
                                this.hasAnnounced = true;
                            }
                        }
                    }
                    
                    return; // Stored at node, skip capture logic
                }
                
                // UNCAPTURED OR DROPPED - can be picked up/captured
                // Check for nearby units trying to capture
                let closestUnit = null;
                let closestDist = Infinity;
                
                nations.forEach(nation => {
                    // Allow capitulated nations with units to capture (resistance fighters)
                    // Only skip nations with no units at all
                    if (nation.units.length === 0) return;
                    
                    nation.units.forEach(unit => {
                        const dist = Math.hypot(unit.x - this.x, unit.y - this.y);
                        if (dist < this.captureRadius && dist < closestDist) {
                            closestDist = dist;
                            closestUnit = { unit, nation: nation.id, dist };
                        }
                    });
                });
                
                if (closestUnit) {
                    // SPEAR PROTECTION: If spear is wielded by a superweapon, only death can take it
                    if (this.type === 'spear' && this.carrier && this.carrier.isSuperweapon === true) {
                        // Only allow another superweapon to take it, regular units cannot steal
                        if (!closestUnit.unit.isSuperweapon) {
                            // Regular unit cannot steal from superweapon
                            return;
                        }
                        // Superweapon vs superweapon - only if carrier is dead/dying
                        if (this.carrier.health > 0) {
                            return;
                        }
                    }
                    
                    // CONTESTED LOCATION: Don't secure items at nodes with enemy capture progress
                    // Find if artifact is at a node location
                    const nearbyNode = nodes.find(n => Math.hypot(n.x - this.x, n.y - this.y) < 50);
                    if (nearbyNode && nearbyNode.capturingNation >= 0 && nearbyNode.capturingNation !== closestUnit.nation) {
                        // Enemy is actively capturing this node - can't secure item here
                        this.captureProgress = 0; // Reset any progress
                        return;
                    }
                    
                    // Multiple units nearby speed up capture
                    const nearbyUnits = getNearbyUnits(this.x, this.y, this.captureRadius)
                        .filter(u => u.nation === closestUnit.nation);
                    const captureSpeed = Math.min(nearbyUnits.length, 5); // Cap at 5 units
                    
                    // Apply artifact's capture difficulty modifier
                    this.captureProgress += dt * 10 * captureSpeed * this.captureSpeed; // Base 10 seconds, modified by difficulty
                    
                    if (this.captureProgress >= 100) {
                        // FRIENDLY INSTANT UNLOCK: If facility is owned by same nation, instant access
                        if (!this.movable && !this.isUnlocked && this.capturedBy === closestUnit.nation) {
                            // Same nation capturing locked facility - instant unlock (friendly access)
                            this.isUnlocked = true;
                            this.unlockProgress = 100;
                            this.crackingNation = undefined;
                            const nation = nations[closestUnit.nation];
                            if (nation) {
                                Audio.announce(`${nation.name} accesses friendly ${this.name}`, 'medium', closestUnit.nation);
                            }
                        }
                        
                        // SECURITY LOCK: If facility is unlocked and being captured by enemy, lock it!
                        if (!this.movable && this.isUnlocked && this.capturedBy >= 0 && this.capturedBy !== closestUnit.nation) {
                            // Facility is unlocked but about to be captured - trigger security lock
                            this.isSecureLocked = true;
                            this.isUnlocked = false;
                            const previousOwner = nations[this.capturedBy];
                            if (previousOwner) {
                                Audio.announce(`${previousOwner.name} ${this.name} enters security lockdown as facility is overrun`, 'high', this.capturedBy);
                            }
                        }
                        
                        this.capturedBy = closestUnit.nation;
                        this.captureProgress = 100;
                        this.hasAnnounced = false; // Reset so new owner gets announcement
                        
                        // Only movable items are carried - facilities stay at location
                        if (this.movable) {
                            // SUPERWEAPON RESTRICTION: Superweapons wielding spear cannot carry other artifacts
                            if (closestUnit.unit.isSuperweapon && closestUnit.unit.carriedSpear) {
                                // Cannot pick up - spear takes both hands
                                this.captureProgress = 0;
                                return;
                            }
                            
                            // CLEAR PREVIOUS CARRIER - only one unit can hold an artifact
                            if (this.type === 'spear') {
                                // Clear from regular unit carrier
                                if (this.carrier && this.carrier.carriedSpear === this) {
                                    this.carrier.carriedSpear = null;
                                }
                                // Clear from any superweapon carrier
                                if (this.carrier && this.carrier.isSuperweapon && this.carrier.carriedSpear === this) {
                                    this.carrier.carriedSpear = null;
                                }
                                this.carrier = null;
                            }
                            
                            // Assign new carrier
                            this.carrier = closestUnit.unit;
                            
                            // For spear specifically, also set carriedSpear property for superweapons
                            if (this.type === 'spear' && closestUnit.unit.isSuperweapon) {
                                closestUnit.unit.carriedSpear = this;
                            }
                            // Force IMMEDIATE order reassignment on next frame - artifact delivery has absolute priority
                            closestUnit.unit.orderTimer = 2.5; // Will trigger receiveOrders immediately in unit.update()
                        }
                        
                        // NOTE: Facilities must be unlocked by bringing the key to them
                        // No instant unlock - keys must be physically delivered
                        
                        const nation = nations[closestUnit.nation];
                        if (!nation) return;
                        
                        Audio.playAlertTone();
                        
                        // Calculate dominance to celebrate powerful nations
                        const myNodeCount = nodes.filter(n => n.owner === closestUnit.nation).length;
                        const totalNodes = nodes.length;
                        const dominancePercent = totalNodes > 0 ? myNodeCount / totalNodes : 0;
                        
                        const ownedTypes = artifacts.filter(a => a.capturedBy === closestUnit.nation).map(a => a.type);
                        const artifactCount = ownedTypes.length + 1; // Include newly captured
                        
                        // Announce based on dominance level
                        if (dominancePercent >= 0.8) {
                            // 80%+ dominance: ABSOLUTE POWER announcement
                            Audio.announce(`${nation.name} dominance absolute - ${artifactCount} puzzle${artifactCount > 1 ? 's' : ''} obtained`, 'high', closestUnit.nation);
                            this.hasAnnounced = true;
                        } else if (dominancePercent >= 0.7) {
                            // 70%+ dominance: OVERWHELMING announcement
                            Audio.announce(`${nation.name} overwhelming force secures ${this.name}`, 'high', closestUnit.nation);
                            this.hasAnnounced = true;
                        } else if (this.requires && this.unlocks && ownedTypes.includes(this.requires)) {
                            // Standard unlock announcement (dependency met)
                            Audio.announce(`${nation.name} has unlocked the ${this.name}`, 'high', closestUnit.nation);
                            this.hasAnnounced = true;
                        } else if (dominancePercent >= 0.5) {
                            // 50%+ dominance: Strategic achievement
                            Audio.announce(`${nation.name} secures ${this.name}`, 'medium', closestUnit.nation);
                            this.hasAnnounced = true;
                        } else {
                            // Default: Simple capture notification
                            Audio.announce(`${nation.name} obtains ${this.name}`, 'low', closestUnit.nation);
                            this.hasAnnounced = true;
                        }
                    }
                } else {
                    // Decay capture progress if no one nearby
                    this.captureProgress = Math.max(0, this.captureProgress - dt * 5);
                }
            }
            
            draw() {
                // Hide archived studied strategic plans - they're stored but not visually relevant
                if (this.type === 'plans' && this.isStudied && this.storedAtNode) {
                    return; // Don't render archived plans
                }
                
                // Don't draw if being carried by a superweapon (superweapon icon shows it)
                if (this.carrier && this.carrier.isSuperweapon) {
                    return;
                }
                
                // HIDE STORED ARTIFACTS - only show in inventory UI, not as big visuals
                // Facilities stay visible, movable items hide when stored
                const isFacility = ['lab', 'reactor', 'prototype', 'safe'].includes(this.type);
                if (this.storedAtNode && !isFacility) {
                    return; // Don't render stored movable items - inventory UI will show them
                }
                
                // Calculate visual offset if stored at node with other artifacts
                let displayX = this.x;
                let displayY = this.y;
                
                if (this.storedAtNode) {
                    // Get all artifacts at this node (simple check - just count all at same location)
                    const artifactsHere = artifacts.filter(a => a.storedAtNode === this.storedAtNode);
                    
                    if (artifactsHere.length > 1) {
                        // Find this artifact's index in the group
                        const myIndex = artifactsHere.indexOf(this);
                        const total = artifactsHere.length;
                        
                        // Arrange in circle around node with generous spacing
                        const baseRadius = 80; // Increased base radius
                        const radiusPerItem = 15; // Additional spacing per item
                        const radius = baseRadius + (total * radiusPerItem);
                        const angle = (myIndex / total) * Math.PI * 2 - Math.PI / 2;
                        displayX = this.storedAtNode.x + Math.cos(angle) * radius;
                        displayY = this.storedAtNode.y + Math.sin(angle) * radius;
                    }
                } else if (!this.carrier && !this.storedAtNode) {
                    // Free-floating artifacts - check for others at same spawn location
                    const artifactsHere = artifacts.filter(a => 
                        !a.carrier && !a.storedAtNode &&
                        Math.abs(a.x - this.x) < 5 && Math.abs(a.y - this.y) < 5
                    );
                    
                    if (artifactsHere.length > 1) {
                        const myIndex = artifactsHere.indexOf(this);
                        const total = artifactsHere.length;
                        const radius = 80 + (total * 15);
                        const angle = (myIndex / total) * Math.PI * 2 - Math.PI / 2;
                        displayX = this.x + Math.cos(angle) * radius;
                        displayY = this.y + Math.sin(angle) * radius;
                    }
                }
                
                // Pulsing glow effect
                const pulse = Math.sin(Date.now() / 500) * 0.3 + 0.7;
                
                // Draw capture radius (only if uncaptured)
                if (this.capturedBy < 0) {
                    ctx.strokeStyle = this.color + '33';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(displayX, displayY, this.captureRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw artifact symbol
                ctx.fillStyle = this.color;
                ctx.globalAlpha = pulse;
                
                if (this.type === 'spear') {
                    // Draw spear shape
                    ctx.save();
                    ctx.translate(displayX, displayY);
                    ctx.rotate(Math.PI / 4);
                    ctx.fillRect(-3, -15, 6, 30);
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(-5, -10);
                    ctx.lineTo(5, -10);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'keycode' || this.type === 'key') {
                    // Draw key symbol
                    ctx.beginPath();
                    ctx.arc(displayX, displayY - 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(displayX - 2, displayY, 4, 10);
                    ctx.fillRect(displayX - 6, displayY + 8, 4, 4);
                } else if (this.type === 'lab') {
                    // Draw lab/building symbol
                    ctx.fillRect(displayX - 10, displayY - 5, 20, 15);
                    ctx.fillRect(displayX - 3, displayY - 15, 6, 10);
                } else if (this.type === 'safe') {
                    // Draw safe/vault symbol - LARGE stationary facility
                    // Main vault body (larger and reinforced)
                    ctx.fillRect(displayX - 15, displayY - 18, 30, 36);
                    // Reinforced corners
                    ctx.fillStyle = '#666';
                    ctx.fillRect(displayX - 15, displayY - 18, 6, 6);
                    ctx.fillRect(displayX + 9, displayY - 18, 6, 6);
                    ctx.fillRect(displayX - 15, displayY + 12, 6, 6);
                    ctx.fillRect(displayX + 9, displayY + 12, 6, 6);
                    // Large combination lock
                    ctx.fillStyle = '#000';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(displayX, displayY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    // Lock dial indicator
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(displayX - 1, displayY - 10, 2, 6);
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = this.color;
                } else if (this.type === 'auth_code' || this.type === 'access_card') {
                    // Draw card/code symbol
                    ctx.fillRect(displayX - 10, displayY - 6, 20, 12);
                    ctx.fillStyle = '#000';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(displayX - 8, displayY - 2, 4, 4);
                    ctx.fillRect(displayX + 4, displayY - 2, 4, 4);
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = this.color;
                } else if (this.type === 'prototype' || this.type === 'weapon') {
                    // Draw weapon symbol
                    ctx.save();
                    ctx.translate(displayX, displayY);
                    ctx.rotate(-Math.PI / 4);
                    ctx.fillRect(-4, -12, 8, 24);
                    ctx.fillRect(-6, -14, 12, 6);
                    ctx.restore();
                } else if (this.type === 'reactor') {
                    // Draw reactor symbol (atomic)
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                        const x = displayX + Math.cos(angle) * 8;
                        const y = displayY + Math.sin(angle) * 8;
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.arc(displayX, displayY, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'blueprint') {
                    // Draw blueprint/document symbol
                    ctx.fillRect(displayX - 8, displayY - 10, 16, 20);
                    ctx.fillStyle = '#000';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(displayX - 6, displayY - 6, 12, 2);
                    ctx.fillRect(displayX - 6, displayY - 2, 12, 2);
                    ctx.fillRect(displayX - 6, displayY + 2, 8, 2);
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = this.color;
                } else {
                    // Draw generic glowing hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const px = displayX + Math.cos(angle) * 10;
                        const py = displayY + Math.sin(angle) * 10;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1.0;
                
                // Draw lock icon if dependency not met
                // For facilities: check isUnlocked flag
                // For movable items: check if owner has required item
                if (this.requires) {
                    let showLock = false;
                    let lockColor = '#FF0000'; // Red for standard lock
                    let lockType = '🔒'; // Standard lock
                    
                    if (this.crackTime) {
                        // Facility - check if unlocked or secure locked
                        if (this.isSecureLocked) {
                            showLock = true;
                            lockColor = '#FFA500'; // Orange for secure lock (owned but locked)
                            lockType = '🔐'; // Closed lock with key (secure)
                        } else {
                            showLock = !this.isUnlocked;
                        }
                    } else {
                        // Movable item - check if owner has required artifact
                        if (this.capturedBy >= 0) {
                            const ownedTypes = artifacts.filter(a => a.capturedBy === this.capturedBy).map(a => a.type);
                            showLock = !ownedTypes.includes(this.requires);
                        } else {
                            showLock = true; // Uncaptured items always show lock if they have requirements
                        }
                    }
                    
                    if (showLock) {
                        ctx.fillStyle = lockColor;
                        ctx.font = 'bold 16px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(lockType, displayX + 15, displayY - 10);
                    }
                }
                
                // Draw capture progress bar (initial capture)
                if (this.captureProgress > 0 && this.captureProgress < 100) {
                    const barWidth = 40;
                    const barHeight = 4;
                    const barX = displayX - barWidth / 2;
                    const barY = displayY + 25;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Find which nation is capturing this facility
                    let capturingNation = null;
                    let maxPresence = 0;
                    nations.forEach(nation => {
                        if (nation.units.length === 0) return;
                        const nearbyUnits = getNearbyUnits(this.x, this.y, this.captureRadius)
                            .filter(u => u.nation === nation.id);
                        if (nearbyUnits.length > maxPresence) {
                            maxPresence = nearbyUnits.length;
                            capturingNation = nation;
                        }
                    });
                    
                    // Color bar by capturing nation
                    const barColor = capturingNation ? capturingNation.color : this.color;
                    ctx.fillStyle = barColor;
                    ctx.fillRect(barX, barY, (this.captureProgress / 100) * barWidth, barHeight);
                    
                    // Show capturing nation name
                    if (capturingNation) {
                        ctx.fillStyle = barColor;
                        ctx.font = 'bold 8px monospace';
                        ctx.textAlign = 'center';
                        const nationName = capturingNation.name.substring(0, 3).toUpperCase();
                        ctx.fillText(`${nationName} CAPTURING`, displayX, displayY + 22);
                    }
                }
                
                // Draw unlock progress bar (cracking facility)
                // Don't show if unlocked or no progress
                if (this.crackTime && this.capturedBy >= 0 && !this.isUnlocked && this.unlockProgress > 0 && this.crackingNation !== undefined) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = displayX - barWidth / 2;
                    const barY = displayY + 30;
                    
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Color bar by nation cracking it (use crackingNation, not capturedBy)
                    const crackingNation = this.crackingNation !== undefined ? nations[this.crackingNation] : null;
                    // Only show if cracking nation is alive
                    if (!crackingNation || crackingNation.capitulated) {
                        return; // Don't show progress for dead nations
                    }
                    const barColor = crackingNation ? crackingNation.color : '#FFAA00';
                    ctx.fillStyle = barColor;
                    ctx.fillRect(barX, barY, (this.unlockProgress / 100) * barWidth, barHeight);
                    
                    // Show "CRACKING..." label with nation name
                    ctx.fillStyle = barColor;
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    const timeRemaining = Math.ceil((this.crackTime * (100 - this.unlockProgress)) / 100);
                    const nationName = crackingNation ? crackingNation.name.substring(0, 3).toUpperCase() : '???';
                    ctx.fillText(`${nationName} CRACKING ${timeRemaining}s`, displayX, displayY + 42);
                }
                
                // Draw study progress bar
                if (this.studyTime && this.studyProgress > 0 && !this.isStudied) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = displayX - barWidth / 2;
                    const barY = displayY + 30;
                    
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#00AAFF'; // Blue for studying
                    ctx.fillRect(barX, barY, (this.studyProgress / 100) * barWidth, barHeight);
                    
                    // Show "STUDYING..." label
                    ctx.fillStyle = '#00AAFF';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    const timeRemaining = Math.ceil((this.studyTime * (100 - this.studyProgress)) / 100);
                    ctx.fillText(`STUDYING ${timeRemaining}s`, displayX, displayY + 42);
                }
                
                // Draw bonus duration timer for active bonuses
                if (this.bonusActive && this.bonusTimeRemaining > 0) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = displayX - barWidth / 2;
                    const barY = displayY + 30;
                    
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Color changes as time runs out: green -> yellow -> red
                    const percentRemaining = this.bonusTimeRemaining / this.bonusDuration;
                    let barColor = '#00FF00'; // Green
                    if (percentRemaining < 0.3) barColor = '#FF0000'; // Red
                    else if (percentRemaining < 0.6) barColor = '#FFAA00'; // Orange
                    
                    ctx.fillStyle = barColor;
                    ctx.fillRect(barX, barY, percentRemaining * barWidth, barHeight);
                    
                    // Show "BONUS ACTIVE" label with time remaining
                    ctx.fillStyle = barColor;
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    const timeRemaining = Math.ceil(this.bonusTimeRemaining);
                    ctx.fillText(`BONUS ${timeRemaining}s`, displayX, displayY + 42);
                }
                
                // Draw decrypt progress bar
                if (this.decryptTime && this.decryptProgress > 0 && !this.isDecrypted) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = displayX - barWidth / 2;
                    const barY = displayY + 30;
                    
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#FFFF00'; // Yellow for decrypting
                    ctx.fillRect(barX, barY, (this.decryptProgress / 100) * barWidth, barHeight);
                    
                    // Show "DECRYPTING..." label
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    const timeRemaining = Math.ceil((this.decryptTime * (100 - this.decryptProgress)) / 100);
                    ctx.fillText(`DECRYPT ${timeRemaining}s`, displayX, displayY + 42);
                }
                
                // Show "STUDIED" badge for completed study
                if (this.isStudied) {
                    ctx.fillStyle = '#00FFAA';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('✓ STUDIED', displayX + 20, displayY - 10);
                }
                
                // Show "DECRYPTED" badge for decrypted keycode
                if (this.isDecrypted) {
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('✓ DECRYPTED', displayX + 25, displayY - 10);
                }
                
                // Draw name label
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, displayX, displayY - 30);
                
                // Show what this artifact does or unlocks
                let statusHint = '';
                if (this.type === 'lab_key') statusHint = 'Opens: Research Lab';
                else if (this.type === 'safe_key') statusHint = 'Opens: Armored Safe';
                else if (this.type === 'access_card') statusHint = 'Opens: Fusion Reactor';
                else if (this.type === 'auth_code') statusHint = 'Opens: Weapon Prototype';
                else if (this.type === 'weapon') statusHint = '+50% Damage';
                else if (this.type === 'keycode' && !this.isDecrypted) statusHint = 'Decrypt at Archive';
                else if (this.type === 'keycode' && this.isDecrypted) statusHint = '+100% Capture Speed';
                else if (this.type === 'data' && !this.isStudied) statusHint = 'Study at Lab';
                else if (this.type === 'data' && this.isStudied && !this.storedAtNode) statusHint = 'Send to Capital';
                else if (this.type === 'spear') statusHint = '+200% SW Damage';
                else if (this.type === 'reactor' && this.isUnlocked) statusHint = '+50% Production';
                else if (this.type === 'prototype' && this.isUnlocked) statusHint = '+100% Damage';
                else if (this.type === 'plans' && !this.isStudied) statusHint = 'Study at Nexus';
                else if (this.type === 'plans' && this.isStudied) statusHint = '+150% Speed';
                
                if (statusHint) {
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = '8px monospace';
                    ctx.fillText(statusHint, displayX, displayY - 20);
                }
                
                // Draw requirement hint if has dependency
                if (this.requires && !this.isUnlocked) {
                    const reqArtifact = artifacts.find(a => a.type === this.requires);
                    if (reqArtifact) {
                        ctx.fillStyle = '#FFAA00';
                        ctx.font = '8px monospace';
                        const hintText = this.crackTime ? `Requires: ${reqArtifact.name}` : `Needs: ${reqArtifact.name}`;
                        ctx.fillText(hintText, displayX, displayY + 50);
                    }
                }
            }
        }
        
        let artifacts = [];
        
        // Superweapon class - Angels, EVA units, experimental weapons
        // Superweapon name pools - each nation gets unique names
        const superweaponNamePools = [
            // Pool 0
            ['Ramiel', 'Sachiel', 'Shamshel', 'Zeruel', 'Bardiel', 'Arael', 'Armisael', 'Tabris', 'Leliel', 'Gaghiel'],
            // Pool 1
            ['Titan-1', 'Titan-2', 'Titan-3', 'Colossus-1', 'Colossus-2', 'Behemoth-1', 'Behemoth-2', 'Leviathan-1', 'Leviathan-2', 'Kraken-1'],
            // Pool 2
            ['Aegis', 'Sentinel', 'Guardian', 'Warden', 'Bulwark', 'Bastion', 'Fortress', 'Rampart', 'Citadel', 'Keep'],
            // Pool 3
            ['Omega', 'Alpha', 'Delta', 'Gamma', 'Sigma', 'Theta', 'Lambda', 'Epsilon', 'Zeta', 'Kappa'],
            // Pool 4
            ['Phoenix', 'Dragon', 'Griffin', 'Chimera', 'Hydra', 'Manticore', 'Basilisk', 'Wyvern', 'Sphinx', 'Cerberus'],
            // Pool 5
            ['Thunderbolt', 'Hurricane', 'Tempest', 'Cyclone', 'Typhoon', 'Monsoon', 'Blizzard', 'Avalanche', 'Earthquake', 'Tsunami'],
            // Pool 6
            ['Valkyrie', 'Fury', 'Vengeance', 'Retribution', 'Nemesis', 'Justice', 'Vindication', 'Reckoning', 'Judgment', 'Havoc'],
            // Pool 7
            ['Eclipse', 'Supernova', 'Pulsar', 'Quasar', 'Nebula', 'Void', 'Singularity', 'Event-Horizon', 'Black-Star', 'Nova'],
            // Pool 8
            ['Excalibur', 'Durandal', 'Mjolnir', 'Gungnir', 'Gae-Bolg', 'Caliburn', 'Gram', 'Tyrfing', 'Kusanagi', 'Muramasa'],
            // Pool 9
            ['Harbinger', 'Reaper', 'Spectre', 'Phantom', 'Wraith', 'Revenant', 'Banshee', 'Apparition', 'Shade', 'Ghost'],
            // Pool 10
            ['Crimson-King', 'Scarlet-Duke', 'Ruby-Lord', 'Vermillion-Baron', 'Carmine-Knight', 'Maroon-Prince', 'Cerise-Count', 'Burgundy-Earl', 'Blood-Emperor', 'Rose-Czar'],
            // Pool 11
            ['Ironclad', 'Steelheart', 'Titanforge', 'Ironside', 'Steelwall', 'Titanshield', 'Ironguard', 'Steelwing', 'Titanblade', 'Ironborn'],
            // Pool 12
            ['Vanguard', 'Viper', 'Talon', 'Fang', 'Claw', 'Raptor', 'Falcon', 'Hawk', 'Eagle', 'Raven'],
            // Pool 13
            ['Oblivion', 'Apocalypse', 'Armageddon', 'Cataclysm', 'Ragnarok', 'Doomsday', 'Extinction', 'Annihilation', 'Devastation', 'Calamity'],
            // Pool 14
            ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Titan', 'Europa'],
            // Pool 15
            ['Ares', 'Athena', 'Zeus', 'Hera', 'Poseidon', 'Hades', 'Apollo', 'Artemis', 'Hermes', 'Hephaestus']
        ];
        
        class Superweapon {
            constructor(x, y, ownerNation, type) {
                this.x = x;
                this.y = y;
                this.owner = ownerNation;
                this.ownerNation = ownerNation; // Also store as ownerNation for AI compatibility
                this.nation = ownerNation; // Align with unit interface for threat detection
                this.type = type; // 'angel', 'eva', 'prototype'
                this.health = 2500; // Increased durability
                this.maxHealth = 2500;
                this.vx = 0;
                this.vy = 0;
                this.targetX = x;
                this.targetY = y;
                this.attackCooldown = 0;
                this.screamCooldown = 0;
                this.isBerserk = false;
                this.berserkTimer = 0;
                this.berserkDeathPhase = false; // Final rampage before detonation
                this.berserkDeathTimer = 0;
                this.damageMultiplier = 1.0; // Proportional response to damage
                this.isSuperweapon = true;
                this.duelImmunityTimer = 0; // Short immunity window after duels
                this.lastDuelOpponent = null;
                this.timeAtCapital = 0; // Track time spent at capital for accelerating regen
                this.carriedSpear = null; // Can carry and wield the Spear of Longitude
                this.stabAnimationTimer = 0; // Visual stabbing animation with spear
                this.stabDirection = 0; // Direction of stab attack
                this.duelMomentum = 0; // Tracks advantage in duels (-100 to +100)
                this.combatState = 'idle'; // idle, engaging, parrying, retreating, advancing
                this.combatStateTimer = 0; // Time in current state
                this.combatTarget = null; // Current combat opponent
                this.personalSpaceRadius = 120; // Minimum distance from other superweapons
                
                // Get unique name from nation's pool
                const nation = nations[ownerNation];
                if (!nation.usedSuperweaponNames) nation.usedSuperweaponNames = [];
                if (!nation.superweaponDeploymentCount) nation.superweaponDeploymentCount = 0;
                if (!nation.superweaponNamePool) {
                    nation.superweaponNamePool = superweaponNamePools[ownerNation % superweaponNamePools.length].slice();
                }
                
                // Increment deployment counter
                nation.superweaponDeploymentCount++;
                const deploymentNumber = nation.superweaponDeploymentCount;
                
                // Find an unused name
                const availableNames = nation.superweaponNamePool.filter(name => !nation.usedSuperweaponNames.includes(name));
                if (availableNames.length > 0) {
                    this.name = availableNames[Math.floor(Math.random() * availableNames.length)];
                    nation.usedSuperweaponNames.push(this.name);
                } else {
                    // All names used, use deployment number
                    this.name = nation.superweaponNamePool[0] + '-' + deploymentNumber;
                    nation.usedSuperweaponNames.push(this.name);
                }
                
                // Type-specific properties
                if (type === 'angel') {
                    this.attackRange = 300;
                    this.baseAttackPower = 200; // Store base power
                    this.attackPower = 200;
                    this.speed = 25; // Reduced from 35 for more dramatic, deliberate movement
                } else if (type === 'eva') {
                    this.attackRange = 150;
                    this.baseAttackPower = 150;
                    this.attackPower = 150;
                    this.speed = 40; // Reduced from 55 for more dramatic, deliberate movement
                    this.canBerserk = true;
                } else {
                    this.attackRange = 200;
                    this.baseAttackPower = 175;
                    this.attackPower = 175;
                    this.speed = 32; // Reduced from 45 for more dramatic, deliberate movement
                }
            }
            
            update(dt, allUnits) {
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);
                this.screamCooldown = Math.max(0, this.screamCooldown - dt);
                this.duelImmunityTimer = Math.max(0, this.duelImmunityTimer - dt);
                this.stabAnimationTimer = Math.max(0, this.stabAnimationTimer - dt);
                
                // Update attack effect timer
                if (this.attackEffect && this.attackEffect.timer > 0) {
                    this.attackEffect.timer -= dt;
                }
                
                if (this.duelImmunityTimer === 0) {
                    this.lastDuelOpponent = null;
                }
                
                // SPEAR HUNTING: Superweapons hunt the Spear of Longitude
                const spear = artifacts.find(a => a.type === 'spear' && a.hasSpawned);
                if (spear && !this.carriedSpear) {
                    // Priority 1: Hunt enemy units carrying the spear
                    if (spear.carrier) {
                        const carrier = spear.carrier;
                        if (carrier.nation !== this.ownerNation) {
                            // PROTECTION: If carrier is a superweapon, only attack if we can kill them
                            if (carrier.isSuperweapon && carrier.health > 0) {
                                // Another superweapon has it - hunt but don't auto-kill
                                this.targetX = carrier.x;
                                this.targetY = carrier.y;
                                // Don't take spear until they're dead (duel mechanics will handle this)
                            } else {
                                // Regular unit or dead superweapon - hunt and kill
                                this.targetX = carrier.x;
                                this.targetY = carrier.y;
                                const dist = Math.hypot(carrier.x - this.x, carrier.y - this.y);
                                if (dist < 50 && !carrier.isSuperweapon) {
                                    // Kill carrier and take spear (only if regular unit)
                                    carrier.health = 0;
                                    // CLEAR PREVIOUS CARRIER - handle both properties
                                    if (spear.carrier) {
                                        if (spear.carrier.carriedSpear === spear) spear.carrier.carriedSpear = null;
                                        spear.carrier = null;
                                    }
                                    spear.carrier = this;
                                    spear.capturedBy = this.ownerNation;
                                    this.carriedSpear = spear;
                                    Audio.announce(`${this.name} claims the Spear of Longitude!`, 'high', this.ownerNation);
                                }
                            }
                        }
                    }
                    // Priority 2: Move to node storing the spear
                    else if (spear.storedAtNode) {
                        this.targetX = spear.storedAtNode.x;
                        this.targetY = spear.storedAtNode.y;
                        const dist = Math.hypot(spear.storedAtNode.x - this.x, spear.storedAtNode.y - this.y);
                        if (dist < 50) {
                            // Check if storage is enemy-owned (handles both regular nodes and artifact safes)
                            const storageOwner = spear.storedAtNode.owner !== undefined ? spear.storedAtNode.owner : spear.storedAtNode.capturedBy;
                            const isEnemyStorage = storageOwner !== this.ownerNation;
                            
                            // Destroy/capture enemy storage to obtain spear
                            if (isEnemyStorage) {
                                // Attack the storage location until captured/destroyed
                                spear.storedAtNode.captureProgress += dt * 50; // Rapid capture
                                
                                // Check if storage is destroyed/captured
                                const captureThreshold = spear.storedAtNode.isCapital ? 36 : 30;
                                const adjustedThreshold = captureThreshold * (spear.storedAtNode.crypticData?.buff === 'Citadel' ? 1.4 : spear.storedAtNode.crypticData?.buff === 'Bastion' ? 1.6 : 1.0);
                                
                                if (spear.storedAtNode.captureProgress >= adjustedThreshold) {
                                    // Storage captured/destroyed - take spear
                                    if (spear.storedAtNode.owner !== undefined) {
                                        spear.storedAtNode.owner = this.ownerNation; // Regular node
                                    } else {
                                        spear.storedAtNode.capturedBy = this.ownerNation; // Artifact safe
                                    }
                                    spear.capturedBy = this.ownerNation;
                                    const idx = spear.storedAtNode.inventory.indexOf(spear.type);
                                    if (idx >= 0) spear.storedAtNode.inventory.splice(idx, 1);
                                    spear.storedAtNode = null;
                                    // CLEAR PREVIOUS CARRIER - handle both unit types
                                    if (spear.carrier) {
                                        if (spear.carrier.carriedSpear === spear) spear.carrier.carriedSpear = null;
                                        spear.carrier = null;
                                    }
                                    spear.carrier = this;
                                    this.carriedSpear = spear;
                                    Audio.announce(`${this.name} seizes the Spear of Longitude!`, 'high', this.ownerNation);
                                }
                            } else {
                                // Friendly storage - just take it freely
                                const idx = spear.storedAtNode.inventory.indexOf(spear.type);
                                if (idx >= 0) spear.storedAtNode.inventory.splice(idx, 1);
                                spear.storedAtNode = null;
                                // CLEAR PREVIOUS CARRIER - ensure no duplicates
                                if (spear.carrier) {
                                    if (spear.carrier.carriedSpear === spear) spear.carrier.carriedSpear = null;
                                    if (spear.carrier.isSuperweapon && spear.carrier.carriedSpear === spear) spear.carrier.carriedSpear = null;
                                    spear.carrier = null;
                                }
                                spear.carrier = this;
                                spear.capturedBy = this.ownerNation;
                                this.carriedSpear = spear;
                                Audio.announce(`${this.name} wields the Spear of Longitude!`, 'high', this.ownerNation);
                            }
                        }
                    }
                    // Priority 3: Move to loose spear
                    else if (spear.capturedBy !== this.ownerNation) {
                        this.targetX = spear.x;
                        this.targetY = spear.y;
                        const dist = Math.hypot(spear.x - this.x, spear.y - this.y);
                        if (dist < 50) {
                            // Claim the spear
                            // CLEAR PREVIOUS CARRIER - handle both unit types
                            if (spear.carrier) {
                                if (spear.carrier.carriedSpear === spear) spear.carrier.carriedSpear = null;
                                spear.carrier = null;
                            }
                            spear.carrier = this;
                            spear.capturedBy = this.ownerNation;
                            this.carriedSpear = spear;
                            Audio.announce(`${this.name} obtains the Spear of Longitude!`, 'high', this.ownerNation);
                        }
                    }
                }
                
                // Update spear position if carrying
                if (this.carriedSpear) {
                    this.carriedSpear.x = this.x;
                    this.carriedSpear.y = this.y;
                }
                
                // Count how many enemy units are engaging this superweapon (within 40 units)
                const engagingUnits = allUnits.filter(u => 
                    u.nation !== this.ownerNation && 
                    Math.hypot(u.x - this.x, u.y - this.y) < 40
                );
                this.engagedByUnitCount = engagingUnits.length;
                
                // PROPORTIONAL DAMAGE RESPONSE - more damage taken = more damage output
                // Scales from 1x at full health to 5x at critical threshold (20% HP)
                const healthPercent = this.health / this.maxHealth;
                const criticalThreshold = 0.2; // 20% HP triggers critical
                
                if (healthPercent > criticalThreshold) {
                    // Linear scaling from 1x to 5x as health drops from 100% to 20%
                    this.damageMultiplier = 1.0 + (1.0 - healthPercent) * 5.0;
                } else {
                    // Below critical threshold - maintain 5x multiplier
                    this.damageMultiplier = 5.0;
                }
                
                // Update attack power with damage multiplier
                this.attackPower = this.baseAttackPower * this.damageMultiplier;
                
                // Berserk mode (EVA units when reaching critical threshold)
                if (this.canBerserk && healthPercent <= criticalThreshold && !this.isBerserk) {
                    this.isBerserk = true;
                    this.berserkTimer = 15.0; // 15 seconds of berserk
                    this.speed *= 1.5;
                    Audio.announce(`Warning! ${this.name} has gone berserk`, 'high');
                    Audio.playTensionSiren();
                }
                
                // Angel critical scream (when reaching critical threshold)
                if (this.type === 'angel' && healthPercent <= criticalThreshold && this.screamCooldown <= 0) {
                    this.playScream();
                    this.screamCooldown = 5.0; // Longer cooldown for critical scream
                }
                
                if (this.isBerserk) {
                    this.berserkTimer -= dt;
                    if (this.berserkTimer <= 0) {
                        this.isBerserk = false;
                        this.speed /= 1.5;
                    }
                }
                
                // Return to repair if damaged below retreat threshold (unless berserk or engaged)
                // RETREAT THRESHOLD: 40% health - fight until significantly damaged before retreating
                // RECHARGE TARGET: 100% health - stay at base until fully recharged
                const retreatThreshold = 0.4; // Retreat when below 40% health
                const rechargeTarget = 1.0; // Recharge to 100% before redeploying
                
                // Check if we should be healing: either below retreat threshold OR actively healing (not yet fully recharged)
                const needsHealing = this.health < this.maxHealth * retreatThreshold;
                const currentlyHealing = this.health < this.maxHealth * rechargeTarget && this.timeAtCapital > 0;
                const shouldSeekRepair = !this.isBerserk && (needsHealing || currentlyHealing);
                
                // Check if we're engaged in combat (enemy superweapons or units nearby)
                let isEngaged = false;
                if (shouldSeekRepair) {
                    // Check for nearby enemies only if badly damaged
                    if (needsHealing) {
                        const nearbyEnemySuperweapons = superweapons.filter(sw => 
                            sw.ownerNation !== this.ownerNation && 
                            Math.hypot(sw.x - this.x, sw.y - this.y) < this.attackRange * 1.5
                        );
                        
                        if (nearbyEnemySuperweapons.length > 0) {
                            isEngaged = true;
                        }
                    }
                    
                    // BERSERK MODE: No retreat, no return - fight to the death
                    // If in berserk death phase, never return to base - continue hunting for maximum casualties
                    if (!this.berserkDeathPhase && !isEngaged && nations[this.ownerNation]) {
                        const nation = nations[this.ownerNation];
                        
                        // Find repair location: capital first, fallback to any friendly node
                        let repairNode = nation.capital && nation.capital.owner === nation.id ? nation.capital : null;
                        
                        // No capital or capital lost - find any friendly node
                        if (!repairNode) {
                            const friendlyNodes = nodes.filter(n => n.owner === nation.id);
                            if (friendlyNodes.length > 0) {
                                // Prefer cryptic nodes for repair, otherwise closest node
                                const crypticNodes = friendlyNodes.filter(n => n.crypticName);
                                const nodesToConsider = crypticNodes.length > 0 ? crypticNodes : friendlyNodes;
                                
                                // Find closest repair node
                                nodesToConsider.sort((a, b) => {
                                    const distA = Math.hypot(a.x - this.x, a.y - this.y);
                                    const distB = Math.hypot(b.x - this.x, b.y - this.y);
                                    return distA - distB;
                                });
                                repairNode = nodesToConsider[0];
                            }
                        }
                        
                        if (repairNode) {
                            const distToRepair = Math.hypot(repairNode.x - this.x, repairNode.y - this.y);
                            
                            // Head to exact center of repair node
                            this.targetX = repairNode.x;
                            this.targetY = repairNode.y;
                            
                            // At repair node center - accelerating regeneration
                            if (distToRepair < 30) { // Must be very close to center
                            // Accumulate time at capital
                            this.timeAtCapital += dt;
                            
                            // Accelerating regen: starts at 50 HP/s, increases by 10 HP/s every second
                            // After 5 seconds: 100 HP/s, after 10 seconds: 150 HP/s, after 20 seconds: 250 HP/s
                            const baseRegen = 50;
                            const regenAcceleration = 10 * this.timeAtCapital; // +10 HP/s per second at repair node
                            const currentRegen = baseRegen + regenAcceleration;
                            
                            this.health = Math.min(this.maxHealth, this.health + currentRegen * dt);
                            
                            // WAIT UNTIL RECHARGED TO TARGET before leaving repair node
                            // Stay at node to recharge - prevents premature deployment
                            if (this.health >= this.maxHealth * rechargeTarget) {
                                this.timeAtCapital = 0;
                            } else {
                                // Still recharging - stay at repair node, don't acquire new targets
                                return true; // Continue update loop but don't move away
                            }
                        } else {
                            // Not at repair node center yet - reset timer
                            this.timeAtCapital = 0;
                        }
                    } else {
                        // No friendly nodes available - keep fighting
                        this.timeAtCapital = 0;
                    }
                    } else {
                        // Not returning to capital - reset timer
                        this.timeAtCapital = 0;
                    }
                } else {
                    // Healthy or berserk - reset timer
                    this.timeAtCapital = 0;
                }
                
                // Move toward target - SUPERWEAPONS IGNORE TERRAIN/MOUNTAINS
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                
                // PERSONAL SPACE ENFORCEMENT: Superweapons maintain distance from each other
                // Creates dynamic combat spacing with engage/retreat/parry behaviors
                let collisionForceX = 0;
                let collisionForceY = 0;
                let nearestEnemy = null;
                let nearestEnemyDist = Infinity;
                
                superweapons.forEach(other => {
                    if (other !== this && other.ownerNation !== this.ownerNation) {
                        const odx = other.x - this.x;
                        const ody = other.y - this.y;
                        const odist = Math.hypot(odx, ody);
                        
                        if (odist < nearestEnemyDist) {
                            nearestEnemy = other;
                            nearestEnemyDist = odist;
                        }
                        
                        // SPACING ENFORCEMENT: Strong repulsion at close range
                        if (odist < this.personalSpaceRadius && odist > 0) {
                            const overlap = this.personalSpaceRadius - odist;
                            const pushStrength = (overlap / this.personalSpaceRadius) * 3.0;
                            collisionForceX -= (odx / odist) * pushStrength;
                            collisionForceY -= (ody / odist) * pushStrength;
                        }
                    }
                });
                
                // Also maintain spacing with friendly superweapons (prevent overlapping)
                superweapons.forEach(other => {
                    if (other !== this && other.ownerNation === this.ownerNation) {
                        const odx = other.x - this.x;
                        const ody = other.y - this.y;
                        const odist = Math.hypot(odx, ody);
                        const minFriendlyDist = 80; // Closer spacing for friendlies
                        
                        if (odist < minFriendlyDist && odist > 0) {
                            const overlap = minFriendlyDist - odist;
                            const pushStrength = (overlap / minFriendlyDist) * 2.0;
                            collisionForceX -= (odx / odist) * pushStrength;
                            collisionForceY -= (ody / odist) * pushStrength;
                        }
                    }
                });
                
                if (dist > 15) {
                    // Apply speed with delta time for smooth movement
                    // Apply slowdown based on engaged units - each unit slows by 25%
                    const slowdownFactor = 1.0 / (1.0 + this.engagedByUnitCount * 0.25);
                    const moveSpeed = this.speed * dt * slowdownFactor;
                    
                    // Combine movement intention with spacing forces
                    this.vx = (dx / dist) * moveSpeed + collisionForceX * this.speed * dt;
                    this.vy = (dy / dist) * moveSpeed + collisionForceY * this.speed * dt;
                } else {
                    // At target - apply spacing forces only
                    this.vx = this.vx * 0.9 + collisionForceX * this.speed * dt;
                    this.vy = this.vy * 0.9 + collisionForceY * this.speed * dt;
                }
                
                // Apply movement - no terrain checks, superweapons fly/phase through everything
                this.x += this.vx * gameSpeed;
                this.y += this.vy * gameSpeed;
                
                // Clamp to world
                const worldWidth = canvas.width * WORLD_SCALE;
                const worldHeight = canvas.height * WORLD_SCALE;
                this.x = Math.max(0, Math.min(worldWidth, this.x));
                this.y = Math.max(0, Math.min(worldHeight, this.y));
                
                // Check for death - enter berserk rampage phase before detonation
                if (this.health <= 0 && !this.berserkDeathPhase) {
                    this.berserkDeathPhase = true;
                    // Randomize death timer (12-24 seconds) with additional staggering - increased for slower, more dramatic sequences
                    let baseTimer = 12.0 + Math.random() * 12.0; // Wider range: 12-24 seconds (increased from 8-16s)
                    
                    // STAGGER: If another superweapon recently entered death phase, add delay
                    if (!game.lastSuperweaponDeathTime) game.lastSuperweaponDeathTime = 0;
                    const now = performance.now() / 1000;
                    if (now - game.lastSuperweaponDeathTime < 5.0) { // Increased from 3s to 5s
                        // Another superweapon died in last 5 seconds - add 6-12s stagger (increased from 4-8s)
                        baseTimer += 6.0 + Math.random() * 6.0;
                    }
                    game.lastSuperweaponDeathTime = now;
                    
                    this.berserkDeathTimer = baseTimer;
                    this.health = 1; // Keep alive during death phase
                    this.speed *= 2.0; // Double speed
                    this.attackPower *= 3.0; // Triple damage
                    this.lastBeepTime = this.berserkDeathTimer; // Track for countdown beeps
                    
                    // Type-specific announcements and sounds
                    if (this.type === 'angel') {
                        Audio.announce(`${this.name} entering critical phase!`, 'high');
                        Audio.playAngelScream(this.x, this.y, 1.5); // Intense geometric scream
                    } else if (this.type === 'eva') {
                        Audio.announce(`${this.name} goes berserk!`, 'high');
                        Audio.playEVARoar(this.x, this.y, 1.8); // Rage roar
                    } else {
                        Audio.announce(`${this.name} entering critical phase!`, 'high');
                        Audio.playKeyTurnSequence(this.x, this.y);
                    }
                    
                    // Immediately play death phase announcement before detonation
                    announcerState.priorityQueue = announcerState.priorityQueue.filter(a => 
                        !a.text.includes(this.name) || a.text.includes('critical') || a.text.includes('berserk')
                    );
                    return true; // Keep alive for death phase
                }
                
                // Countdown berserk death timer with TYPE-SPECIFIC audio alerts
                if (this.berserkDeathPhase) {
                    this.berserkDeathTimer -= dt;
                    
                    if (this.type === 'eva') {
                        // EVA BERSERK: Roars of rage that intensify
                        const timeRemaining = this.berserkDeathTimer;
                        const maxTime = 25.0; // Updated from 16s to match new berserk timer
                        const intensity = 1.0 - (timeRemaining / maxTime); // 0 to 1.0
                        
                        if (timeRemaining <= 2.0) {
                            // Final 2 seconds: constant enraged roaring (every 0.25s)
                            const roarInterval = 0.25;
                            if (Math.floor(timeRemaining / roarInterval) < Math.floor(this.lastBeepTime / roarInterval)) {
                                Audio.playEVARoar(this.x, this.y, Math.min(2.0, 1.5 + intensity * 0.5));
                            }
                        } else if (timeRemaining <= 5.0) {
                            // 2-5 seconds: frequent rage roars (every 0.4s)
                            const roarInterval = 0.4;
                            if (Math.floor(timeRemaining / roarInterval) < Math.floor(this.lastBeepTime / roarInterval)) {
                                Audio.playEVARoar(this.x, this.y, 1.3 + intensity * 0.4);
                            }
                        } else if (timeRemaining <= 8.0) {
                            // 5-8 seconds: building roars (every 0.6s)
                            const roarInterval = 0.6;
                            if (Math.floor(timeRemaining / roarInterval) < Math.floor(this.lastBeepTime / roarInterval)) {
                                Audio.playEVARoar(this.x, this.y, 1.0 + intensity * 0.3);
                            }
                        } else {
                            // 8+ seconds: growling roars (every 1.0s)
                            const roarInterval = 1.0;
                            if (Math.floor(timeRemaining / roarInterval) < Math.floor(this.lastBeepTime / roarInterval)) {
                                Audio.playEVARoar(this.x, this.y, 0.8 + intensity * 0.2);
                            }
                        }
                    } else if (this.type === 'angel') {
                        // ANGEL: Shrieking scream that increases in intensity and frequency
                        const timeRemaining = this.berserkDeathTimer;
                        const maxTime = 20.0; // Maximum berserk timer (updated from 12s)
                        const intensity = 1.0 - (timeRemaining / maxTime); // 0 to 1.0
                        
                        if (timeRemaining <= 3.0) {
                            // Final 3 seconds: constant screaming (every 0.3s, reduced frequency)
                            const screamInterval = 0.3;
                            if (Math.floor(timeRemaining / screamInterval) < Math.floor(this.lastBeepTime / screamInterval)) {
                                Audio.playAngelScream(this.x, this.y, Math.min(1.5, intensity * 1.5)); // Reduced from 2.0x
                            }
                        } else if (timeRemaining <= 6.0) {
                            // 3-6 seconds: frequent screams (every 0.5s, reduced frequency)
                            const screamInterval = 0.5;
                            if (Math.floor(timeRemaining / screamInterval) < Math.floor(this.lastBeepTime / screamInterval)) {
                                Audio.playAngelScream(this.x, this.y, intensity * 1.2); // Reduced from 1.5x
                            }
                        } else {
                            // 6+ seconds: building screams (every 0.9s, reduced frequency)
                            const screamInterval = 0.9;
                            if (Math.floor(timeRemaining / screamInterval) < Math.floor(this.lastBeepTime / screamInterval)) {
                                Audio.playAngelScream(this.x, this.y, intensity * 0.8); // Reduced base intensity
                            }
                        }
                    } else {
                        // PROTOTYPE: Standard countdown beeps
                        if (this.berserkDeathTimer <= 8.0) {
                            const beepInterval = 0.7; // Slower beeps (was 0.5s)
                            if (Math.floor(this.berserkDeathTimer / beepInterval) < Math.floor(this.lastBeepTime / beepInterval)) {
                                const pitch = 600 + (8.0 - this.berserkDeathTimer) * 60; // Adjusted for new timing
                                Audio.playCountdownBeep(this.x, this.y, pitch);
                            }
                        } else if (this.berserkDeathTimer <= 18.0) {
                            const beepInterval = 1.5; // Slower beeps (was 1.0s)
                            if (Math.floor(this.berserkDeathTimer / beepInterval) < Math.floor(this.lastBeepTime / beepInterval)) {
                                Audio.playCountdownBeep(this.x, this.y, 500);
                            }
                        }
                    }
                    
                    this.lastBeepTime = this.berserkDeathTimer;
                    
                    if (this.berserkDeathTimer <= 0) {
                        // Drop spear before detonating
                        if (this.carriedSpear) {
                            this.carriedSpear.carrier = null;
                            this.carriedSpear.capturedBy = -1;
                            this.carriedSpear.captureProgress = 0;
                            // Drop at current position
                            const validPos = findValidDropPosition(this.x, this.y);
                            this.carriedSpear.x = validPos.x;
                            this.carriedSpear.y = validPos.y;
                            this.carriedSpear = null;
                        }
                        return false; // Time to detonate
                    }
                }
                
                return this.health > 0 || this.berserkDeathPhase;
            }
            
            takeDamage(amount) {
                this.health -= amount;
                // Angels scream when damaged - frequency based on damage amount
                if (this.type === 'angel' && this.screamCooldown <= 0) {
                    // Bigger hits = more likely to scream
                    const screamChance = Math.min(1.0, amount / 100);
                    if (Math.random() < screamChance) {
                        this.playScream();
                        this.screamCooldown = 1.5;
                    }
                }
            }
            
            playScream() {
                if (!Audio.enabled || !audioCtx || audioCtx.state !== 'running') return;
                
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                // Eerie descending scream
                osc.frequency.setValueAtTime(1800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.5);
                osc.type = 'sawtooth';
                
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                osc.connect(gain);
                gain.connect(audioChannels.combat);
                osc.start(now);
                osc.stop(now + 0.5);
            }
            
            detonate(nations, allUnits, superweapons) {
                // Massive explosion that damages everything nearby
                const detonationRadius = 120; // Reduced from 240 for smaller detonations
                const detonationDamage = 500;
                
                // TYPE-SPECIFIC DEATH EFFECTS
                if (this.type === 'eva') {
                    // EVA: Pilot ejects before detonation
                    const ejectDistance = 80 + Math.random() * 40; // 80-120 units away
                    const ejectAngle = Math.random() * Math.PI * 2;
                    const ejectX = this.x + Math.cos(ejectAngle) * ejectDistance;
                    const ejectY = this.y + Math.sin(ejectAngle) * ejectDistance;
                    
                    // Create pilot ejection visual
                    this.pilotEjection = {
                        startX: this.x,
                        startY: this.y,
                        x: ejectX,
                        y: ejectY,
                        timer: 0,
                        duration: 1.5, // 1.5 second ejection arc
                        alpha: 1.0
                    };
                    detonationEffects.push(this.pilotEjection);
                } else if (this.type === 'angel') {
                    // Angel: Blood splatter and neon genesis cross
                    const nationColor = nations[this.ownerNation] ? nations[this.ownerNation].color : '#ff0000';
                    this.angelDeath = {
                        x: this.x,
                        y: this.y,
                        timer: 0,
                        duration: 5.0, // Cross lasts 5 seconds
                        orbRadius: 0,
                        maxOrbRadius: 25,
                        crossHeight: 0,
                        maxCrossHeight: 100,
                        color: nationColor,
                        bloodSplatters: Array.from({ length: 30 }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            distance: 40 + Math.random() * 60,
                            size: 3 + Math.random() * 8,
                            alpha: 0.8 + Math.random() * 0.2
                        }))
                    };
                    detonationEffects.push(this.angelDeath);
                }
                
                // Play massive explosion sound
                Audio.playArtillery(this.x, this.y);
                Audio.playTensionSiren();
                
                // Damage units in radius: closest enemy is heavily damaged but not outright killed; others can be killed
                const enemiesInBlast = allUnits
                    .filter(u => u.nation !== this.ownerNation)
                    .map(u => ({ unit: u, dist: Math.hypot(u.x - this.x, u.y - this.y) }))
                    .filter(entry => entry.dist < detonationRadius)
                    .sort((a, b) => a.dist - b.dist);

                enemiesInBlast.forEach((entry, idx) => {
                    const { unit, dist } = entry;
                    const falloff = 1.0 - (dist / detonationRadius);
                    const damage = detonationDamage * falloff;

                    if (idx === 0) {
                        // Primary target: heavily damage but leave them barely alive
                        const maxDamage = Math.max(0, unit.health - 5); // leave 5 HP
                        unit.health -= Math.min(maxDamage, damage);
                    } else {
                        // Secondary targets: full lethal damage
                        unit.health -= damage;
                        if (unit.health <= 0) {
                            Audio.playDeath(unit.x, unit.y);
                        }
                    }
                });
                
                // Damage other superweapons in radius (friendly or enemy)
                superweapons.forEach(other => {
                    if (other !== this) {
                        const dist = Math.hypot(other.x - this.x, other.y - this.y);
                        if (dist < detonationRadius) {
                            const duelImmunity = other.lastDuelOpponent === this && other.duelImmunityTimer > 0;
                            if (duelImmunity) return; // Victor of the duel shrugs off the blast
                            
                            const falloff = 1.0 - (dist / detonationRadius);
                            const damage = detonationDamage * falloff * 2.0; // Extra damage to superweapons
                            other.takeDamage(damage);
                        }
                    }
                });
                
                // Create multi-stage visual detonation effect
                this.detonationEffect = {
                    x: this.x,
                    y: this.y,
                    radius: 0,
                    maxRadius: detonationRadius * 2.0,
                    alpha: 1.0,
                    duration: 4.0, // 4 second total effect
                    timer: 0,
                    // Debris particles
                    particles: Array.from({ length: 40 }, () => ({
                        angle: Math.random() * Math.PI * 2,
                        speed: 80 + Math.random() * 120,
                        distance: 0,
                        maxDistance: detonationRadius * (0.8 + Math.random() * 0.6),
                        size: 2 + Math.random() * 4,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 8
                    }))
                };
                
                // Create permanent crater/burn mark - baked into terrain rendering
                craters.push({
                    x: this.x,
                    y: this.y,
                    radius: detonationRadius * 1.2,
                    createdAt: Date.now(),
                    age: 0 // Age in seconds, used for cooling effect
                });
                
                return this.detonationEffect;
            }
            
            draw() {
                ctx.save();
                
                // Flashing alert for critical/berserk state
                let flashAlpha = 1.0;
                if (this.berserkDeathPhase && this.berserkDeathTimer <= 5.0) {
                    // Rapid flashing in final 5 seconds
                    const flashSpeed = 10; // Hz
                    flashAlpha = Math.sin(Date.now() * flashSpeed * Math.PI / 1000) > 0 ? 1.0 : 0.3;
                } else if (this.berserkDeathPhase) {
                    // Slower flashing 5-10 seconds
                    const flashSpeed = 3; // Hz
                    flashAlpha = Math.sin(Date.now() * flashSpeed * Math.PI / 1000) > 0 ? 1.0 : 0.5;
                } else if (this.health < this.maxHealth * 0.3) {
                    // Critical health warning
                    const flashSpeed = 2; // Hz
                    flashAlpha = Math.sin(Date.now() * flashSpeed * Math.PI / 1000) > 0 ? 1.0 : 0.7;
                }
                
                ctx.globalAlpha = flashAlpha;
                
                // WEAPON EFFECT: Draw attack beam/slash before body
                if (this.attackEffect && this.attackEffect.timer > 0) {
                    const progress = 1.0 - (this.attackEffect.timer / 0.2);
                    const alpha = this.attackEffect.timer / 0.2;
                    
                    if (this.type === 'angel') {
                        // Multi-spectral light beam
                        ctx.globalAlpha = alpha * 0.6;
                        const beamColors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00'];
                        for (let i = 0; i < beamColors.length; i++) {
                            ctx.strokeStyle = beamColors[i];
                            ctx.lineWidth = 8 - i * 1.5;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            const offsetAngle = (i - 2) * 0.05; // Spread the beams slightly
                            const angle = Math.atan2(this.attackEffect.targetY - this.y, this.attackEffect.targetX - this.x) + offsetAngle;
                            const distance = Math.hypot(this.attackEffect.targetX - this.x, this.attackEffect.targetY - this.y);
                            ctx.lineTo(
                                this.x + Math.cos(angle) * distance,
                                this.y + Math.sin(angle) * distance
                            );
                            ctx.stroke();
                        }
                        ctx.globalAlpha = flashAlpha;
                    } else if (this.type === 'eva') {
                        // Progressive knife slash effect
                        ctx.globalAlpha = alpha * 0.8;
                        const angle = Math.atan2(this.attackEffect.targetY - this.y, this.attackEffect.targetX - this.x);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        const slashLength = 35;
                        ctx.moveTo(
                            this.x + Math.cos(angle - 0.3) * slashLength,
                            this.y + Math.sin(angle - 0.3) * slashLength
                        );
                        ctx.lineTo(
                            this.x + Math.cos(angle + 0.3) * slashLength,
                            this.y + Math.sin(angle + 0.3) * slashLength
                        );
                        ctx.stroke();
                        
                        // Energy trail
                        ctx.strokeStyle = nations[this.owner] ? nations[this.owner].color : '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.globalAlpha = flashAlpha;
                    }
                }
                
                // Draw superweapon (large geometric shape)
                if (this.type === 'angel') {
                    // Octahedron (Ramiel-style)
                    ctx.strokeStyle = this.berserkDeathPhase ? '#ff0000' : (nations[this.owner] ? nations[this.owner].color : '#ffffff');
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const size = 15;
                    ctx.moveTo(this.x, this.y - size);
                    ctx.lineTo(this.x + size, this.y);
                    ctx.lineTo(this.x, this.y + size);
                    ctx.lineTo(this.x - size, this.y);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    // EVA/Prototype - humanoid silhouette
                    ctx.fillStyle = this.berserkDeathPhase ? '#ff0000' : (nations[this.owner] ? nations[this.owner].color : '#ffffff');
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw carried spear separately with stab animation
                if (this.carriedSpear) {
                    const spearLength = 28;
                    const spearAngle = this.stabAnimationTimer > 0 ? this.stabDirection : 0;
                    const stabExtend = this.stabAnimationTimer > 0 ? 8 : 0; // Extends during stab
                    const spearBaseX = this.x + Math.cos(spearAngle) * (12 + stabExtend);
                    const spearBaseY = this.y + Math.sin(spearAngle) * (12 + stabExtend);
                    
                    ctx.save();
                    ctx.translate(spearBaseX, spearBaseY);
                    ctx.rotate(spearAngle);
                    
                    // Cross-guard (perpendicular line at base)
                    ctx.strokeStyle = '#B8860B'; // Dark gold
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -4);
                    ctx.lineTo(0, 4);
                    ctx.stroke();
                    
                    // Spear shaft (tapered from 4px to 2.5px)
                    const shaftGradient = ctx.createLinearGradient(0, 0, spearLength - 8, 0);
                    shaftGradient.addColorStop(0, '#FFD700');
                    shaftGradient.addColorStop(1, '#FFA500');
                    ctx.strokeStyle = shaftGradient;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(spearLength - 10, 0);
                    ctx.stroke();
                    
                    // Thinner shaft near tip
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(spearLength - 10, 0);
                    ctx.lineTo(spearLength - 8, 0);
                    ctx.stroke();
                    
                    // Spearhead (diamond/leaf shape)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(spearLength, 0); // Tip
                    ctx.lineTo(spearLength - 8, -3.5); // Upper edge
                    ctx.lineTo(spearLength - 10, 0); // Middle notch
                    ctx.lineTo(spearLength - 8, 3.5); // Lower edge
                    ctx.closePath();
                    ctx.fill();
                    
                    // Spearhead outline for definition
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                ctx.globalAlpha = 1.0;
                
                // Name label
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillText(this.name, this.x + 1, this.y - 26);
                ctx.fillStyle = this.isBerserk ? '#ff0000' : (nations[this.owner] ? nations[this.owner].color : '#ffffff');
                ctx.fillText(this.name, this.x, this.y - 27);
                
                // Health bar
                const barWidth = 30;
                const barHeight = 3;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(this.x - barWidth/2, this.y - 20, barWidth, barHeight);
                ctx.fillStyle = this.health > this.maxHealth * 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(this.x - barWidth/2, this.y - 20, barWidth * (this.health / this.maxHealth), barHeight);
                
                ctx.restore();
            }
        }
        
        const superweapons = [];
        const detonationEffects = []; // Persistent array for nuclear blast effects
        const craters = []; // Permanent scarred/burned areas from detonations
        
        // Unit balance system - scaled for screen-spanning battle lines
        // DYNAMIC optimal count based on territory control
        // Formula: ~5 units per node (so half the map = ~100 units sustained)
        const BASE_OPTIMAL_UNIT_COUNT = 200;  // Fallback if no nodes owned
        const UNITS_PER_NODE = 5;              // Each node supports ~5 units optimally
        const MAX_UNIT_COUNT = 250;            // Hard population cap per nation (25% overflow)
        
        // Economic constants - rebalanced for scarcity
        const TERRITORY_INCOME_RATE = 0.02;      // Resources per second per territory cell (reduced 10x)
        const NODE_INCOME_BASE = 0.5;            // Base resources per second per node (reduced 50%)
        const NODE_INCOME_CAPITAL = 1.0;         // Capital nodes generate more (reduced 50%)
        const UNIT_PRODUCTION_COST = 50;         // Resources to produce one unit (increased 5x)
        const UNIT_UPKEEP = 0.5;                 // Resources per second per unit (reduced for sustainability)
        const DEFICIT_ATTRITION_RATE = 1;        // HP damage per second when in deficit (reduced from 5)
        const MAX_RESOURCES = 200;               // Resource stockpile cap (reduced from 500)
        
        // Simple 2D noise function for natural value distribution
        function noise2D(x, y) {
            // Simple pseudo-random noise based on position
            const seed = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (seed - Math.floor(seed)); // Returns 0-1
        }
        
        // Get natural value bias for a position (combines multiple noise octaves)
        function getPositionValueNoise(x, y) {
            // Multiple octaves of noise for more natural variation
            const scale1 = 0.001; // Large features
            const scale2 = 0.005; // Medium features
            const scale3 = 0.01;  // Small features
            
            const noise1 = noise2D(x * scale1, y * scale1);
            const noise2 = noise2D(x * scale2, y * scale2);
            const noise3 = noise2D(x * scale3, y * scale3);
            
            // Combine octaves with different weights
            const combined = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;
            
            // Map to range 0.75x to 1.5x (natural variation)
            return 0.75 + combined * 0.75;
        }
        
        // Find the weakest nation by resource count
        function getWeakestNation() {
            if (nations.length === 0) return null;
            let weakest = nations[0];
            for (let nation of nations) {
                if (nation.resources < weakest.resources) {
                    weakest = nation;
                }
            }
            return weakest;
        }
        
        function getStrongestNation() {
            // Find strongest by combined score: units + nodes + resources
            let strongest = null;
            let highestScore = -1;
            
            for (let nation of nations) {
                if (nation.capitulated) continue;
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                const score = nation.units.length + nodeCount * 10 + nation.resources * 0.1;
                if (score > highestScore) {
                    highestScore = score;
                    strongest = nation;
                }
            }
            return strongest;
        }
        
        // Calculate strength modifier based on nation's unit count
        function getUnitStrengthModifier(nation) {
            // Return the nation's current decaying strength modifier
            // This is updated in the game loop to gradually decay
            return nation.strengthModifier;
        }
        
        function getMonumentBonus(x, y, nationId) {
            // MONUMENT buff: +15% strength to all friendly units within 300 units
            const monumentNodes = nodes.filter(n => 
                n.owner === nationId && 
                n.crypticName === 'Monument'
            );
            
            for (let node of monumentNodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= 300) {
                    return 1.15; // +15% strength boost
                }
            }
            return 1.0; // No bonus
        }
        
        function calculateTargetStrengthModifier(nation) {
            // Calculate the IDEAL strength modifier based on current population
            const unitCount = nation.units.length;
            if (unitCount === 0) return 1.0;
            
            // Dynamic optimal count based on territory
            const nodeCount = nodes.filter(n => n.owner === nation.id).length;
            const OPTIMAL_UNIT_COUNT = Math.max(50, nodeCount * UNITS_PER_NODE); // Min 50, scales with nodes
            
            // Reduced comeback mechanics - weaker inverse relationship
            // With half the map (~22 nodes): optimal = 110 units
            // At optimal: 1.0x strength (100%)
            // At 2x optimal: 0.5x strength (50%)
            // At 0.5x optimal: 1.3x strength (130%) - reduced from 2.0x
            const ratio = unitCount / OPTIMAL_UNIT_COUNT;
            
            if (ratio <= 1.0) {
                // Fewer units = slightly stronger (capped at 1.3x instead of unlimited)
                const boost = 1.0 / ratio; // e.g., 50 units = 2.0x
                return Math.min(1.3, boost); // Cap at 30% bonus instead of 100%
            } else {
                // More units = weaker (inversely proportional)
                // Additional penalty based on how long they've been overpopulated
                const baseModifier = 1.0 / ratio; // e.g., 200 units = 100/200 = 0.5x
                
                // Time-based decay: after 60 seconds of overpopulation, approaches 0%
                // overpopTimer is in seconds
                const timePenalty = Math.min(nation.overpopTimer / 60, 1.0); // 0 to 1 over 60 seconds
                
                // Gradually reduce from base modifier toward 0% based on time
                return baseModifier * (1.0 - timePenalty * 0.95); // Can reach as low as 5% of base
            }
        }
        
        // Nations configuration
        // Diplomatic stance types
        const DIPLOMATIC_STANCE = {
            WAR: 'WAR',
            NEUTRAL: 'NEUTRAL',
            NON_AGGRESSION: 'NON_AGGRESSION',
            TRADE: 'TRADE',
            ALLIED: 'ALLIED',
            TRIBUTARY: 'TRIBUTARY'  // One nation pays tribute to another
        };
        
        // Nation personalities - defines behavioral biases
        const nationPersonalities = [
            { aggressive: 0.8, defensive: 0.3, expansionist: 0.9, diplomatic: 0.2 }, // NERVA - aggressive expansionist
            { aggressive: 0.3, defensive: 0.7, expansionist: 0.4, diplomatic: 0.8 }, // ZELUS - diplomatic defender
            { aggressive: 0.5, defensive: 0.5, expansionist: 0.7, diplomatic: 0.5 }, // VALKYR - balanced expansionist
            { aggressive: 0.6, defensive: 0.4, expansionist: 0.3, diplomatic: 0.6 }, // PRAXEN - aggressive diplomat
            { aggressive: 0.4, defensive: 0.9, expansionist: 0.2, diplomatic: 0.4 }, // SOLARIS - defensive isolationist
            { aggressive: 0.9, defensive: 0.2, expansionist: 0.5, diplomatic: 0.1 }, // BARONIX - highly aggressive
            { aggressive: 0.2, defensive: 0.6, expansionist: 0.8, diplomatic: 0.7 }, // ATRION - peaceful expansionist
            { aggressive: 0.7, defensive: 0.3, expansionist: 0.6, diplomatic: 0.3 }, // TRANSGUILD - aggressive expansionist
            { aggressive: 0.5, defensive: 0.8, expansionist: 0.3, diplomatic: 0.6 }, // BENEDICTA - defensive diplomat
            { aggressive: 0.85, defensive: 0.25, expansionist: 0.75, diplomatic: 0.15 }, // TYRAX - very aggressive
            { aggressive: 0.3, defensive: 0.5, expansionist: 0.5, diplomatic: 0.5 }, // WAYLANE - balanced neutral
            { aggressive: 0.6, defensive: 0.4, expansionist: 0.8, diplomatic: 0.4 }, // OMNIFORGE - aggressive expansionist
            { aggressive: 0.4, defensive: 0.6, expansionist: 0.6, diplomatic: 0.7 }, // CYBRYNE - diplomatic expansionist
            { aggressive: 0.25, defensive: 0.7, expansionist: 0.6, diplomatic: 0.75 }, // SOYLUX - peaceful diplomatic
            { aggressive: 0.7, defensive: 0.35, expansionist: 0.55, diplomatic: 0.35 }, // TYCORE - moderately aggressive
            { aggressive: 0.95, defensive: 0.15, expansionist: 0.65, diplomatic: 0.05 }  // HEGEMYR - extremely aggressive
        ];
        
        const nationColors = [
            { name: 'NERVAR', color: '#FF0000', capitalTerm: 'dogma' },         // Pure Red - neural spearpoint
            { name: 'ZELUS', color: '#00FF00', capitalTerm: 'command' },         // Pure Lime - covert cabal
            { name: 'VALKYRY', color: '#0080FF', capitalTerm: 'core' },        // Bright Blue - strike wings
            { name: 'PRAXEN', color: '#FFFF00', capitalTerm: 'prison' },        // Pure Yellow - psychohist labs
            { name: 'SOLARIS', color: '#FF00FF', capitalTerm: 'throne' },       // Pure Magenta - stellar empire
            { name: 'BARONIX', color: '#00FFFF', capitalTerm: 'council' },       // Pure Cyan - refinery lords
            { name: 'ATRION', color: '#FF8000', capitalTerm: 'leadership' },        // Pure Orange - noble wardens
            { name: 'TORGUILD', color: '#8000FF', capitalTerm: 'syndicate' },    // Purple - void consortium
            { name: 'BENEDICTA', color: '#FFD700', capitalTerm: 'sanctum' },     // Gold - hidden order (was white)
            { name: 'VYRAX', color: '#00CED1', capitalTerm: 'directive' },         // Dark Turquoise - replicant cartel (was gray)
            { name: 'LANGWAYS', color: '#FF0080', capitalTerm: 'headquarters' },       // Rose - salvage combine
            { name: 'OMNISCENE', color: '#00FF80', capitalTerm: 'forge' },     // Spring Green - warfoundry
            { name: 'CYBRYNE', color: '#0080C0', capitalTerm: 'matrix' },       // Deep Sky Blue - machine synod
            { name: 'VOLUX', color: '#C08000', capitalTerm: 'hub' },        // Dark Orange - bioprovisioners
            { name: 'TYRANEL', color: '#80FF00', capitalTerm: 'dominion' },        // Chartreuse - resource cartel
            { name: 'HEGEMYR', color: '#C00000', capitalTerm: 'regime' }      // Dark Red - war dominion
        ];
        
        const NATION_COUNT = 4; // Configure how many nations spawn (2-8)
        
        const nations = [];
        
        // Voice configurations for each nation - EXTREME variations to ensure NO similarity to announcer
        // Announcer is pitch 0.8, rate 0.85 - all nations must be dramatically different
        const nationVoices = [
            { pitch: 0.3, rate: 1.1 },    // NERVA - ultra deep, faster
            { pitch: 1.8, rate: 1.6 },    // ZELUS - ultra high, fast
            { pitch: 0.35, rate: 1.5 },   // VALKYR - ultra deep, fast
            { pitch: 1.7, rate: 1.05 },   // PRAXEN - ultra high, faster
            { pitch: 1.9, rate: 1.7 },    // SOLARIS - maximum high, fast
            { pitch: 0.25, rate: 1.0 },   // BARONIX - maximum deep, faster
            { pitch: 1.5, rate: 1.55 },   // ATRION - very high, fast
            { pitch: 1.75, rate: 1.65 },  // TRANSGUILD - ultra high, fast
            { pitch: 0.3, rate: 1.05 },   // BENEDICTA - ultra deep, faster
            { pitch: 1.85, rate: 1.6 },   // TYRAX - ultra ultra high, fast
            { pitch: 1.6, rate: 1.6 },    // WAYLANE - very high, fast
            { pitch: 1.65, rate: 1.55 },  // OMNIFORGE - very high, fast
            { pitch: 1.7, rate: 1.5 },    // CYBRYNE - very high, moderate
            { pitch: 1.4, rate: 1.5 },    // SOYLUX - high, moderate
            { pitch: 0.35, rate: 1.1 },   // TYCORE - ultra deep, faster
            { pitch: 0.28, rate: 1.02 }   // HEGEMYR - maximum deep, faster
        ];
        
        // Helper function to calculate color difference (Euclidean distance in RGB space)
        function colorDistance(color1, color2) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            
            return Math.sqrt(
                Math.pow(r1 - r2, 2) +
                Math.pow(g1 - g2, 2) +
                Math.pow(b1 - b2, 2)
            );
        }
        
        // Select nations with fair random chance but ensure visually distinct colors
        // Everyone is equally eligible, but selected colors must be vibrant and different
        const selectedIndices = [];
        const shuffledPool = [];
        for (let i = 0; i < nationColors.length; i++) {
            shuffledPool.push(i);
        }
        
        // Fisher-Yates shuffle for fair random selection
        for (let i = shuffledPool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledPool[i], shuffledPool[j]] = [shuffledPool[j], shuffledPool[i]];
        }
        
        // Select nations ensuring color distinctiveness
        const MIN_COLOR_DISTANCE = 120; // Require significant color difference (0-441 range)
        
        for (let candidate of shuffledPool) {
            if (selectedIndices.length >= NATION_COUNT) break;
            
            // Check if this color is distinct enough from already selected
            let isDistinct = true;
            for (let selectedIdx of selectedIndices) {
                const distance = colorDistance(
                    nationColors[candidate].color,
                    nationColors[selectedIdx].color
                );
                if (distance < MIN_COLOR_DISTANCE) {
                    isDistinct = false;
                    break;
                }
            }
            
            if (isDistinct) {
                selectedIndices.push(candidate);
            }
        }
        
        // Fallback: if we couldn't find enough distinct colors, just take what we have
        // (This shouldn't happen with well-chosen color palette)
        while (selectedIndices.length < NATION_COUNT && shuffledPool.length > 0) {
            const candidate = shuffledPool.find(idx => !selectedIndices.includes(idx));
            if (candidate !== undefined) {
                selectedIndices.push(candidate);
            } else {
                break;
            }
        }
        
        for (let i = 0; i < selectedIndices.length; i++) {
            const templateIndex = selectedIndices[i];
            nations.push({
                id: i,
                name: nationColors[templateIndex].name,
                color: nationColors[templateIndex].color,
                capitalTerm: nationColors[templateIndex].capitalTerm, // Unique capital name
                personality: nationPersonalities[templateIndex],
                voice: nationVoices[templateIndex],  // Persistent voice settings
                templateIndex: templateIndex,  // Store original index for voice mapping
                units: [],
                capital: null,
                capitulated: false,
                strengthModifier: 1.0,
                resources: 50,  // Reduced from 500 - must build economy
                income: 0,
                upkeep: 0,
                production: 0,
                unitQueue: 0,
                artilleryMagazine: 0, // Stuck mountain units feed into artillery ammunition
                queueSpawnTimer: 0,
                overpopTimer: 0,
                // Diplomatic state
                diplomaticRelations: {},
                warExhaustion: 0,
                totalCasualties: 0,
                recentLosses: [],
                recentWins: [],
                lastDiplomaticEval: 0,
                activeOffers: [],
                tributePaying: -1,
                tributeReceiving: [],
                warCrimes: 0,
                recentWarCrimes: [],
                allianceTrust: {},
                lastCapitalEval: 0,
                capitalEvacuations: 0,  // Track number of rapid evacuations
                evacuationCooldown: 0,   // Cooldown timer for rapid evacuations
                superweaponProgress: 0,  // Progress toward building superweapon (0-100)
                superweaponCooldown: 0,  // Cooldown after deploying
                resurrectionCount: 0     // Track resurrections (limited to 2 = 3 total lives)
            });
        }
        
        // Initialize all nations with empty diplomatic relations (undefined = can fight/capture)
        // Nations will evaluate and establish formal relations over time
        // This allows the game to start with competition, then diplomacy emerges
        nations.forEach(nation => {
            nations.forEach(other => {
                if (nation.id !== other.id) {
                    // Don't initialize relations - undefined = hostile by default
                    // nation.diplomaticRelations[other.id] = DIPLOMATIC_STANCE.NEUTRAL;
                }
            });
        });
        
        // Initialize economic values for all nations
        nations.forEach(nation => {
            nation.resources = 500;
            nation.income = 0;
            nation.upkeep = 0;
            nation.production = 0;
        });
        
        // === DIPLOMATIC SYSTEM ===
        
        // Calculate war exhaustion for a nation (0-100)
        function calculateWarExhaustion(nation) {
            let exhaustion = 0;
            
            // Recent casualties increase exhaustion
            const recentCasualties = nation.recentLosses.reduce((sum, loss) => sum + loss.count, 0);
            exhaustion += recentCasualties * 1.0; // Balanced rate
            
            // Long wars increase exhaustion (check how long at war)
            const atWarWith = Object.keys(nation.diplomaticRelations).filter(id => 
                nation.diplomaticRelations[id] === DIPLOMATIC_STANCE.WAR
            );
            exhaustion += atWarWith.length * 3; // Moderate pressure
            
            // Economic strain (deficit) increases exhaustion
            if (nation.income < nation.upkeep) {
                const deficit = nation.upkeep - nation.income;
                exhaustion += deficit * 0.2; // Reduced from 0.5 to 0.2
            }
            
            // Low resources = exhaustion
            if (nation.resources < 50) {
                exhaustion += (50 - nation.resources) * 0.05; // Only when very low, reduced multiplier
            }
            
            // Losing territory = exhaustion
            const ownedNodes = nodes.filter(n => n.owner === nation.id).length;
            if (ownedNodes <= 1) {
                exhaustion += 15; // Reduced from 20 to 15
            }
            
            // Recent victories reduce exhaustion (increased benefit)
            const recentWins = nation.recentWins.filter(w => Date.now() - w.time < 60000).length;
            exhaustion -= recentWins * 8; // Increased from 3 to 8
            
            return Math.max(0, Math.min(100, exhaustion));
        }
        
        // Calculate relative military strength between two nations
        function calculateStrengthRatio(nation1, nation2) {
            const nation1Strength = nation1.units.length * (1 + nation1.strengthModifier);
            const nation2Strength = nation2.units.length * (1 + nation2.strengthModifier);
            
            if (nation2Strength === 0) return 10; // Infinitely stronger
            return nation1Strength / nation2Strength;
        }
        
        // Evaluate diplomatic stance toward another nation
        function evaluateDiplomaticStance(nation, targetNation) {
            // Don't evaluate with self or capitulated nations
            if (nation.id === targetNation.id || nation.capitulated || targetNation.capitulated) {
                return null;
            }
            
            const currentStance = nation.diplomaticRelations[targetNation.id];
            const strengthRatio = calculateStrengthRatio(nation, targetNation);
            const warExhaustion = nation.warExhaustion;
            
            // Calculate threat level from target
            const targetNodes = nodes.filter(n => n.owner === targetNation.id);
            const myNodes = nodes.filter(n => n.owner === nation.id);
            
            // Proximity threat - are they near us?
            let proximityThreat = 0;
            if (myNodes.length > 0 && targetNodes.length > 0) {
                myNodes.forEach(myNode => {
                    targetNodes.forEach(targetNode => {
                        const dist = Math.hypot(myNode.x - targetNode.x, myNode.y - targetNode.y);
                        if (dist < 300) proximityThreat += 1;
                    });
                });
            }
            
            // Find common enemies
            const commonEnemies = nations.filter(n => 
                n.id !== nation.id && n.id !== targetNation.id &&
                nation.diplomaticRelations[n.id] === DIPLOMATIC_STANCE.WAR &&
                targetNation.diplomaticRelations[n.id] === DIPLOMATIC_STANCE.WAR
            );
            
            // Check war crimes - recent artillery on nodes causes deep animosity
            const targetRecentCrimes = targetNation.recentWarCrimes.filter(wc => Date.now() - wc.time < 120000).length; // 2 minutes
            const hasCommittedWarCrimes = targetRecentCrimes > 0;
            const seriousWarCriminal = targetRecentCrimes >= 2; // Multiple strikes = serious criminal
            
            // Find who else is at war with the war criminal
            const othersAgainstCriminal = seriousWarCriminal ? nations.filter(n => 
                n.id !== nation.id && n.id !== targetNation.id && !n.capitulated &&
                n.diplomaticRelations[targetNation.id] === DIPLOMATIC_STANCE.WAR
            ) : [];
            
            // DECISION LOGIC - rational evaluation with personality influence
            
            // Personality modifiers affect thresholds
            const aggressionMod = nation.personality.aggressive; // 0.0-1.0, higher = more warlike
            const diplomaticMod = nation.personality.diplomatic; // 0.0-1.0, higher = seeks alliances
            const defensiveMod = nation.personality.defensive; // 0.0-1.0, higher = seeks security
            
            // SERIOUS WAR CRIMES (2+) = DEEP HATRED - break all peaceful relations
            // Aggressive nations are more tolerant of war crimes (realpolitik)
            const warCrimeThreshold = seriousWarCriminal && (currentStance === DIPLOMATIC_STANCE.ALLIED || 
                currentStance === DIPLOMATIC_STANCE.TRADE || 
                currentStance === DIPLOMATIC_STANCE.NON_AGGRESSION);
            
            if (warCrimeThreshold && Math.random() > aggressionMod * 0.4) {
                // Announce betrayal/condemnation
                if (currentStance === DIPLOMATIC_STANCE.ALLIED) {
                    Audio.announce(`${nation.name} denounces ${targetNation.name} as a war criminal!`, 'high');
                }
                
                return {
                    newStance: DIPLOMATIC_STANCE.WAR,
                    reason: `Repeated war crimes by ${targetNation.name} (${targetRecentCrimes} artillery strikes on nodes)`
                };
            }
            
            // PRIORITY: Join coalition against serious war criminals (lower threshold)
            // Diplomatic nations more likely to join coalitions
            const coalitionChance = 0.3 + (diplomaticMod * 0.4);
            if (seriousWarCriminal && currentStance === DIPLOMATIC_STANCE.NEUTRAL && 
                strengthRatio > coalitionChance) {
                return {
                    newStance: DIPLOMATIC_STANCE.WAR,
                    reason: `Join coalition against war criminal ${targetNation.name} (${targetRecentCrimes} strikes)`
                };
            }
            
            // Single war crime - causes tension but not immediate war (unless already hostile)
            if (hasCommittedWarCrimes && !seriousWarCriminal && currentStance === DIPLOMATIC_STANCE.ALLIED) {
                // Downgrade alliance but don't immediately declare war
                return {
                    newStance: DIPLOMATIC_STANCE.NON_AGGRESSION,
                    reason: `Tension with ${targetNation.name} over artillery strike on node`
                };
            }
            
            // PRIORITY: Form alliances with others fighting the war criminal
            if (othersAgainstCriminal.length > 0 && currentStance !== DIPLOMATIC_STANCE.ALLIED &&
                targetNation.id !== nation.id) {
                // Check if we can ally with someone fighting the criminal
                for (let ally of othersAgainstCriminal) {
                    if (nation.diplomaticRelations[ally.id] !== DIPLOMATIC_STANCE.ALLIED) {
                        // This will be handled in the mutual evaluation
                        break;
                    }
                }
            }
            
            // If very weak and exhausted - seek peace or become tributary
            // Defensive personalities more willing to surrender early
            const surrenderThreshold = 0.5 + (defensiveMod * 0.3);
            if (strengthRatio < surrenderThreshold && warExhaustion > (60 - defensiveMod * 20)) {
                if (currentStance === DIPLOMATIC_STANCE.WAR) {
                    // Losing badly - offer tributary status or peace
                    return { 
                        newStance: DIPLOMATIC_STANCE.TRIBUTARY,
                        reason: 'Losing war, seeking tributary peace'
                    };
                }
            }
            
            // PRIORITY: If fighting common enemy - propose alliance
            // Diplomatic nations more likely to form alliances
            if (commonEnemies.length > 0 && currentStance !== DIPLOMATIC_STANCE.ALLIED &&
                Math.random() < (0.7 + diplomaticMod * 0.3)) {
                // Check if common enemy is a war criminal - prioritize these alliances
                const criminalEnemy = commonEnemies.find(e => 
                    e.recentWarCrimes.filter(wc => Date.now() - wc.time < 300000).length > 0
                );
                return {
                    newStance: DIPLOMATIC_STANCE.ALLIED,
                    reason: criminalEnemy ? 
                        `Unite against war criminal ${criminalEnemy.name}` :
                        `Common enemy: ${commonEnemies.map(e => e.name).join(', ')}`
                };
            }
            
            // If strong and target is weak - demand tributary or war
            // Aggressive nations more likely to attack weak neighbors
            const aggressionThreshold = 2.0 - (aggressionMod * 0.8);
            if (strengthRatio > aggressionThreshold && currentStance === DIPLOMATIC_STANCE.NEUTRAL &&
                Math.random() < aggressionMod) {
                // Aggressive expansion
                return {
                    newStance: DIPLOMATIC_STANCE.WAR,
                    reason: 'Opportunistic aggression against weak neighbor'
                };
            }
            
            // If exhausted from war - seek peace
            // Aggressive nations tolerate higher exhaustion
            const exhaustionThreshold = 70 + (aggressionMod * 20);
            if (currentStance === DIPLOMATIC_STANCE.WAR && warExhaustion > exhaustionThreshold) {
                // Announce peace treaty
                Audio.announce(`${nation.name} and ${targetNation.name} sign peace treaty`, 'normal');
                
                return {
                    newStance: DIPLOMATIC_STANCE.NON_AGGRESSION,
                    reason: 'War exhaustion too high'
                };
            }
            
            // If no proximity threat and not at war - trade agreement
            // Diplomatic nations more likely to pursue trade
            if (proximityThreat === 0 && currentStance === DIPLOMATIC_STANCE.NEUTRAL &&
                Math.random() < diplomaticMod) {
                return {
                    newStance: DIPLOMATIC_STANCE.TRADE,
                    reason: 'Distant nation, mutual benefit'
                };
            }
            
            // If allied but common enemy defeated - downgrade to non-aggression
            if (currentStance === DIPLOMATIC_STANCE.ALLIED && commonEnemies.length === 0) {
                return {
                    newStance: DIPLOMATIC_STANCE.NON_AGGRESSION,
                    reason: 'Alliance no longer necessary'
                };
            }
            
            return null; // No stance change
        }
        
        // Process diplomatic evaluation for all nations
        function processDiplomacy(currentTime) {
            nations.forEach(nation => {
                if (nation.capitulated) return;
                
                // Update war exhaustion
                nation.warExhaustion = calculateWarExhaustion(nation);
                
                // Regenerate alliance trust slowly when not under pressure
                Object.keys(nation.diplomaticRelations).forEach(allyId => {
                    if (nation.diplomaticRelations[allyId] === DIPLOMATIC_STANCE.ALLIED) {
                        if (!nation.allianceTrust[allyId]) {
                            nation.allianceTrust[allyId] = 100;
                        } else if (nation.allianceTrust[allyId] < 100) {
                            // Regenerate 0.5 trust per second (slow recovery)
                            nation.allianceTrust[allyId] = Math.min(100, nation.allianceTrust[allyId] + 0.5 * ((currentTime - nation.lastDiplomaticEval) / 1000));
                        }
                    }
                });
                
                // Evaluate diplomatic stance every 30 seconds (throttled for performance)
                // Skip if checked recently (within 30 seconds)
                if (!nation.lastDiplomaticEval) nation.lastDiplomaticEval = 0;
                if (currentTime - nation.lastDiplomaticEval > 30000) {
                    nation.lastDiplomaticEval = currentTime;
                    
                    nations.forEach(targetNation => {
                        const evaluation = evaluateDiplomaticStance(nation, targetNation);
                        if (evaluation) {
                            // Check if target agrees (mutual benefit logic)
                            const targetEval = evaluateDiplomaticStance(targetNation, nation);
                            
                            // For peaceful stances, both must agree
                            if (evaluation.newStance === DIPLOMATIC_STANCE.ALLIED ||
                                evaluation.newStance === DIPLOMATIC_STANCE.TRADE ||
                                evaluation.newStance === DIPLOMATIC_STANCE.NON_AGGRESSION) {
                                
                                // Both want similar peaceful stance - agree
                                if (targetEval && targetEval.newStance !== DIPLOMATIC_STANCE.WAR) {
                                    nation.diplomaticRelations[targetNation.id] = evaluation.newStance;
                                    targetNation.diplomaticRelations[nation.id] = evaluation.newStance;
                                    
                                    // Initialize alliance trust when forming alliance
                                    if (evaluation.newStance === DIPLOMATIC_STANCE.ALLIED) {
                                        nation.allianceTrust[targetNation.id] = 100;
                                        targetNation.allianceTrust[nation.id] = 100;
                                        
                                        // Announce new alliance
                                        Audio.announce(`${nation.name} and ${targetNation.name} establish tactical cooperation`, 'high');
                                    }
                                }
                            } else if (evaluation.newStance === DIPLOMATIC_STANCE.WAR) {
                                // One-sided declaration of war
                                nation.diplomaticRelations[targetNation.id] = DIPLOMATIC_STANCE.WAR;
                                targetNation.diplomaticRelations[nation.id] = DIPLOMATIC_STANCE.WAR;
                                
                                // Announce war declaration
                                Audio.announce(`Alert. ${nation.name} initiates combat operations against ${targetNation.name}`, 'high');
                            } else if (evaluation.newStance === DIPLOMATIC_STANCE.TRIBUTARY) {
                                // Offer tributary status (target must accept)
                                const targetStrength = calculateStrengthRatio(targetNation, nation);
                                if (targetStrength > 1.5) {
                                    nation.diplomaticRelations[targetNation.id] = DIPLOMATIC_STANCE.TRIBUTARY;
                                    targetNation.diplomaticRelations[nation.id] = DIPLOMATIC_STANCE.TRIBUTARY;
                                    nation.tributePaying = targetNation.id;
                                    targetNation.tributeReceiving.push(nation.id);
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // Particle/Unit class
        class Unit {
            constructor(x, y, nationId) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.nation = nationId;
                this.influence = 1;
                this.age = 0;
                
                // Combat stats
                this.health = 100;
                this.maxHealth = 100;
                this.strength = 0.5 + Math.random() * 0.5; // 0.5-1.0
                this.morale = 1.0;
                this.veterancy = 0; // Experience level: 0-100
                this.damageBonus = Math.random() * 0.3 - 0.15; // -15% to +15% RNG
                this.defenseBonus = Math.random() * 0.3 - 0.15; // -15% to +15% RNG
                this.inBattle = false;
                this.battleCooldown = 0;
                this.engagedEnemy = null; // Track current combat target
                this.engagedEnemies = []; // All enemies engaged with this unit
                this.isLocked = false; // Completely immobile when locked in melee
                this.lockTimer = 0; // How long we've been locked (stays locked for a while)
                
                // Mountain proximity tracking
                this.nearMountainTimer = 0; // Track how long we've been near mountains
                
                // Stamina system - units tire from long marches and sprinting
                this.stamina = 100; // 0-100, drains with movement, regenerates at rest
                this.distanceTraveled = 0; // Track total distance for fatigue
                this.lastPosX = x; // For distance tracking
                this.lastPosY = y;
                
                // Command & control
                this.targetNode = null;
                this.waypointNode = null; // Intermediate node to route through for pathfinding
                this.orderTimer = 2.0; // Start with 2.0 to get first orders quickly (triggers at 2.5)
                this.targetCommitmentTime = 0; // How long we've been targeting current node
                this.role = 'garrison'; // garrison, border, offensive, captureArtifact
                this.onFrontline = false;
                this.connectedToCapital = true;
                this.nearestFriendlyNode = null;
                this.targetSuperweapon = null; // Active intercept target
                this.targetArtifact = null; // Artifact capture target
                this.targetPos = null; // Generic position target
                
                // Stuck detection
                this.stuckCounter = 0;
                this.lastX = x;
                this.lastY = y;
                this.stuckAtNodeTimer = 0; // Track how long stuck at uncapturable node
                
                // Jitter detection for mountain teleport
                this.jitterTimer = 0;
                this.jitterPositions = [];
                this.jitterCooldown = 0; // Prevent immediate re-launch
                this.jitterBurstCount = 0; // Track consecutive launches (machine gun bursts)
                this.jitterBurstTarget = 0; // How many missiles in this burst
                this.capitalMissileCooldown = 0; // Capital missile defense system
                this.isAirborne = false; // Parabolic flight mode
                this.airborneTimer = 0;
                this.launchVelocity = { x: 0, y: 0 };
                this.launchHeight = 0;
                this.impactSoundPlayed = false; // Track if impact sound has been played
                
                // Amphibious mechanics
                this.onBoat = false;
                this.boatTimer = 0;
            }
            
            // Check if unit has clear path to capital (not cut off)
            checkConnectivity(nodes, allUnits, nation) {
                if (!nation.capital) {
                    this.connectedToCapital = false;
                    return;
                }
                
                // Find nearest friendly node
                const friendlyNodes = nodes.filter(n => n.owner === this.nation);
                if (friendlyNodes.length === 0) {
                    this.connectedToCapital = false;
                    this.nearestFriendlyNode = null;
                    return;
                }
                
                this.nearestFriendlyNode = this.findClosest(friendlyNodes);
                
                // Check if path to nearest node is blocked by enemies
                const pathToNode = this.nearestFriendlyNode || nation.capital;
                const dx = pathToNode.x - this.x;
                const dy = pathToNode.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Sample points along path
                let enemiesBlockingPath = 0;
                const samples = Math.floor(dist / 30);
                for (let i = 1; i < samples; i++) {
                    const t = i / samples;
                    const px = this.x + dx * t;
                    const py = this.y + dy * t;
                    
                    // Count enemies near this point on path
                    for (let unit of allUnits) {
                        if (unit.nation !== this.nation) {
                            const d = Math.hypot(unit.x - px, unit.y - py);
                            if (d < 40) {
                                enemiesBlockingPath++;
                            }
                        }
                    }
                }
                
                // Connected if path is mostly clear
                this.connectedToCapital = enemiesBlockingPath < samples * 2;
            }
            
            // Check if local area is secured (no enemies nearby)
            isAreaSecured(allUnits) {
                const secureRadius = 100;
                for (let unit of allUnits) {
                    if (unit.nation !== this.nation) {
                        const dist = Math.hypot(unit.x - this.x, unit.y - this.y);
                        if (dist < secureRadius) {
                            return false; // Enemy nearby, not secured
                        }
                    }
                }
                return true; // No enemies in range, area is secured
            }
            
            // Find nearest unpainted or enemy-painted territory
            findNearestUnpaintedArea(influenceGrid, gridSize) {
                const myGridX = Math.floor(this.x / gridSize);
                const myGridY = Math.floor(this.y / gridSize);
                const searchRadius = 25; // Increased from 15 - look further for territory
                
                let nearestDist = Infinity;
                let nearestPos = null;
                
                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const gx = myGridX + dx;
                        const gy = myGridY + dy;
                        
                        if (gy >= 0 && gy < influenceGrid.length && 
                            gx >= 0 && gx < influenceGrid[0].length) {
                            const cell = influenceGrid[gy][gx];
                            
                            // Find neutral or enemy territory
                            if (cell.nation !== this.nation) {
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestPos = {
                                        x: gx * gridSize + gridSize / 2,
                                        y: gy * gridSize + gridSize / 2
                                    };
                                }
                            }
                        }
                    }
                }
                
                return nearestPos;
            }
            
            // Find frontline position (border with enemy territory)
            findFrontlinePosition(influenceGrid, gridSize) {
                const myGridX = Math.floor(this.x / gridSize);
                const myGridY = Math.floor(this.y / gridSize);
                const searchRadius = 20;
                
                let frontlines = [];
                
                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const gx = myGridX + dx;
                        const gy = myGridY + dy;
                        
                        if (gy >= 0 && gy < influenceGrid.length && 
                            gx >= 0 && gx < influenceGrid[0].length) {
                            const cell = influenceGrid[gy][gx];
                            
                            // Check if this is friendly territory next to enemy
                            if (cell.nation === this.nation) {
                                const neighbors = [[0,-1],[1,0],[0,1],[-1,0]];
                                let hasEnemyNeighbor = false;
                                
                                for (let [ndx, ndy] of neighbors) {
                                    const nx = gx + ndx;
                                    const ny = gy + ndy;
                                    if (ny >= 0 && ny < influenceGrid.length && 
                                        nx >= 0 && nx < influenceGrid[0].length) {
                                        const neighbor = influenceGrid[ny][nx];
                                        if (neighbor.nation >= 0 && neighbor.nation !== this.nation) {
                                            hasEnemyNeighbor = true;
                                            break;
                                        }
                                    }
                                }
                                
                                if (hasEnemyNeighbor) {
                                    frontlines.push({
                                        x: gx * gridSize + gridSize / 2,
                                        y: gy * gridSize + gridSize / 2,
                                        dist: Math.sqrt(dx * dx + dy * dy)
                                    });
                                }
                            }
                        }
                    }
                }
                
                if (frontlines.length > 0) {
                    // Find closest frontline position
                    frontlines.sort((a, b) => a.dist - b.dist);
                    return { x: frontlines[0].x, y: frontlines[0].y };
                }
                
                return null;
            }
            
            receiveOrders(nodes, allUnits, nation, nearbyEnemies = []) {
                // RESISTANCE FIGHTERS: If capitulated without capital, only capture nearby nodes
                if (nation.capitulated && !nation.capital) {
                    // Resistance fighters don't zoom across map - only capture nearby nodes
                    const nearbyNodes = nodes.filter(n => {
                        const dist = Math.hypot(n.x - this.x, n.y - this.y);
                        return dist < 200 && n.owner !== nation.id; // Only nearby nodes
                    });
                    
                    if (nearbyNodes.length > 0) {
                        // Find closest nearby node
                        nearbyNodes.sort((a, b) => {
                            const distA = Math.hypot(a.x - this.x, a.y - this.y);
                            const distB = Math.hypot(b.x - this.x, b.y - this.y);
                            return distA - distB;
                        });
                        
                        this.role = 'captureNode';
                        this.targetNode = nearbyNodes[0];
                        this.targetPos = { x: nearbyNodes[0].x, y: nearbyNodes[0].y };
                    } else {
                        // No nearby nodes - wander locally
                        this.role = null;
                        this.targetNode = null;
                        this.targetPos = null;
                    }
                    return; // Skip normal order logic
                }
                
                // Use cached node lists from nation to avoid recalculating per unit
                const myNodes = nation.cachedMyNodes || [];
                const uncontrolledNodes = nation.cachedUncontrolledNodes || [];
                const threatenedNodes = nation.cachedThreatenedNodes || [];
                
                // Check if this unit has been pre-assigned as a node guardian
                if (this.role === 'nodeGuardian' && this.targetNode) {
                    return;
                }
                
                // CAPITAL DEFENSE PRIORITY - EMERGENCY ONLY (prevent clustering)
                // Only defend if capital is actively being captured AND nearly lost
                if (nation.capital && nation.capital.owner === nation.id) {
                    const distToCapital = Math.hypot(this.x - nation.capital.x, this.y - nation.capital.y);
                    const isCapitalThreatened = nation.capital.capturingNation >= 0;
                    const captureProgress = nation.capital.captureProgress || 0;
                    
                    // ONLY defend if capital is 50%+ captured and unit is close
                    // This prevents clustering while still protecting capital in emergencies
                    const isEmergency = isCapitalThreatened && captureProgress > 50;
                    const isCloseEnough = distToCapital < 250;
                    
                    // Only 40% of nearby units defend even in emergency (others keep attacking)
                    if (isEmergency && isCloseEnough && Math.random() < 0.4) {
                        this.role = 'defendCapital';
                        this.targetNode = nation.capital;
                        this.waypointNode = null;
                        return;
                    }
                }
                
                // STUCK NEAR MOUNTAINS CHECK - if unit is near mountains, force reassignment
                const currentTerrain = getTerrainType(this.x, this.y);
                let stuckNearMountains = false;
                if (currentTerrain === TERRAIN_TYPES.MOUNTAIN) {
                    stuckNearMountains = true;
                } else {
                    // Check if surrounded by mountains
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const checkX = this.x + Math.cos(angle) * 40;
                        const checkY = this.y + Math.sin(angle) * 40;
                        if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                            stuckNearMountains = true;
                            break;
                        }
                    }
                }

                // ============================================================
                // ARTIFACT CARRIER PRIORITY - Secure valuable items ASAP!
                // Units carrying artifacts immediately seek storage locations
                // STRATEGIC: Don't bring unlock keys to enemy-owned facilities!
                // THIS IS THE ABSOLUTE TOP PRIORITY - check BEFORE everything else
                // ============================================================
                
                // Check if this unit is carrying any artifacts
                const carriedArtifact = artifacts.find(a => a.carrier === this);
                if (carriedArtifact) {
                    // ABSOLUTE PRIORITY - unit is carrying something valuable
                    // NO OTHER TASK can override this - not even superweapons!
                    
                    // Check if this is an UNLOCK KEY for a specific facility
                    const unlockMappings = {
                        'lab_key': 'lab',
                        'safe_key': 'safe',
                        'access_card': 'reactor',
                        'auth_code': 'prototype'
                    };
                    
                    const unlocksType = unlockMappings[carriedArtifact.type];
                    
                    if (unlocksType) {
                        // This is an unlock key! Check if we control the facility
                        const targetFacility = artifacts.find(a => 
                            a.type === unlocksType && 
                            !a.movable && // Must be a facility (stationary)
                            !a.isUnlocked // Must be locked (needs key)
                        );
                        
                        if (targetFacility) {
                            // Facility exists and is locked
                            if (targetFacility.capturedBy === this.nation) {
                                // WE OWN IT! Bring the key TO the facility for proximity unlock
                                this.role = 'unlockFacility';
                                this.targetNode = null; // Not targeting a node
                                this.targetPos = { x: targetFacility.x, y: targetFacility.y };
                                this.waypointNode = null;
                                return; // Deliver key to facility!
                            } else if (targetFacility.capturedBy >= 0 && targetFacility.capturedBy !== this.nation) {
                                // ENEMY OWNS IT! DON'T bring them the key - secure it safely!
                                // Guard this key - it's strategic leverage
                                if (nation.capital && nation.capital.owner === this.nation) {
                                    this.role = 'guardKey';
                                    this.targetNode = nation.capital;
                                    this.waypointNode = null;
                                    return; // Protect key from enemy!
                                }
                            }
                            // If neutral (capturedBy === -1), fall through to normal securing
                        }
                    }
                    
                    // HIGH PRIORITY: Get this valuable item to safety!
                    const storageLocations = [];
                    
                    // Capital is always a valid storage location
                    if (nation.capital && nation.capital.owner === this.nation) {
                        storageLocations.push({
                            node: nation.capital,
                            dist: Math.hypot(nation.capital.x - this.x, nation.capital.y - this.y),
                            itemCount: artifacts.filter(a => a.storedAtNode === nation.capital).length,
                            isCapital: true,
                            isSafe: false
                        });
                    }
                    
                    // Named nodes are preferred storage locations
                    myNodes.forEach(node => {
                        if (node.crypticName) {
                            storageLocations.push({
                                node: node,
                                dist: Math.hypot(node.x - this.x, node.y - this.y),
                                itemCount: artifacts.filter(a => a.storedAtNode === node).length,
                                isCapital: false,
                                isSafe: false
                            });
                        }
                    });
                    
                    // Unlocked safe facilities (secure storage after spear is obtained)
                    artifacts.forEach(artifact => {
                        if (artifact.type === 'safe' && 
                            artifact.isUnlocked && 
                            artifact.capturedBy === this.nation &&
                            artifact.hasSpawnedContents) { // Spear has been taken out
                            storageLocations.push({
                                node: artifact,
                                dist: Math.hypot(artifact.x - this.x, artifact.y - this.y),
                                itemCount: artifact.inventory ? artifact.inventory.length : 0,
                                isCapital: false,
                                isSafe: true
                            });
                        }
                    });
                    
                    if (storageLocations.length > 0) {
                        // Prefer spreading items across different locations
                        // Sort by: safes first (most secure) > fewer items stored > closer distance > capital LAST (vulnerability penalty)
                        storageLocations.sort((a, b) => {
                            // Safes are highest priority (most secure)
                            if (a.isSafe !== b.isSafe) {
                                return a.isSafe ? -1 : 1;
                            }
                            // HEAVY PENALTY for capital with 3+ artifacts (risk of catastrophic loss)
                            const aCapitalPenalty = (a.isCapital && a.itemCount >= 3) ? 1000 : 0;
                            const bCapitalPenalty = (b.isCapital && b.itemCount >= 3) ? 1000 : 0;
                            const penaltyDiff = aCapitalPenalty - bCapitalPenalty;
                            if (penaltyDiff !== 0) return penaltyDiff;
                            
                            // Prioritize locations with fewer items
                            if (a.itemCount !== b.itemCount) {
                                return a.itemCount - b.itemCount;
                            }
                            // If tied, prefer named nodes over capital (spread defensive)
                            if (a.isCapital !== b.isCapital) {
                                return a.isCapital ? 1 : -1;
                            }
                            // Finally sort by distance
                            return a.dist - b.dist;
                        });
                        
                        // Assign to nearest empty/low-count storage location
                        this.role = 'secureArtifact';
                        this.targetNode = storageLocations[0].node;
                        this.waypointNode = null; // Direct path to safety
                        return; // ABORT other orders - securing artifacts is top priority!
                    }
                }

                // EMERGENCY: intercept enemy superweapons threatening our space
                // (Only if NOT carrying artifacts - artifact security takes absolute priority)
                const enemySupers = superweapons.filter(sw => sw.ownerNation !== nation.id && !nations[sw.ownerNation]?.capitulated);
                if (enemySupers.length > 0) {
                    let closestThreat = null;
                    enemySupers.forEach(sw => {
                        const distToMe = Math.hypot(sw.x - this.x, sw.y - this.y);
                        const distToCapital = nation.capital ? Math.hypot(sw.x - nation.capital.x, sw.y - nation.capital.y) : Infinity;
                        let distToNode = Infinity;
                        myNodes.forEach(node => {
                            distToNode = Math.min(distToNode, Math.hypot(sw.x - node.x, sw.y - node.y));
                        });
                        const score = Math.min(distToMe, distToCapital, distToNode);
                        if (!closestThreat || score < closestThreat.score) {
                            closestThreat = { sw, distToMe, distToCapital, distToNode, score };
                        }
                    });

                    if (closestThreat) {
                        const imminentToCore = closestThreat.distToCapital < 800 || closestThreat.distToNode < 600;
                        const closeToUnit = closestThreat.distToMe < 450;
                        // ALWAYS intercept threatening superweapons (removed random check)
                        if (imminentToCore || closeToUnit) {
                            this.role = 'interceptSuperweapon';
                            this.targetSuperweapon = closestThreat.sw;
                            this.targetNode = null;
                            this.targetPos = { x: closestThreat.sw.x, y: closestThreat.sw.y };
                            this.waypointNode = null;
                            return;
                        }
                    }
                }
                
                // ============================================================
                // COMMITMENT-BASED ORDERING
                // Units stick to targets and only reassign when necessary
                // ============================================================
                
                // CRITICAL: Units carrying artifacts NEVER get reassigned to other roles
                // They must complete artifact storage before doing anything else
                const stillCarryingArtifact = artifacts.find(a => a.carrier === this);
                if (stillCarryingArtifact) {
                    // ABSOLUTE PRIORITY - unit is carrying something valuable
                    // Ensure we have artifact-related role
                    if (this.role !== 'secureArtifact' && this.role !== 'guardKey' && this.role !== 'archiveStudiedPlan' && this.role !== 'redistributeArtifact') {
                        this.role = 'secureArtifact';
                    }
                    
                    // If we have a valid target node that we still own, keep heading there
                    if (this.targetNode && this.targetNode.owner === this.nation) {
                        return; // KEEP current target - don't reassign!
                    }
                    
                    // Target lost or invalid - find new storage location
                    const ownedNodes = myNodes.filter(n => n.owner === this.nation);
                    if (ownedNodes.length === 0) {
                        // No owned nodes - just hold position
                        this.targetNode = null;
                        return;
                    }
                    
                    const storageLocations = ownedNodes.map(node => {
                        const dist = Math.hypot(node.x - this.x, node.y - this.y);
                        const itemsStored = artifacts.filter(a => a.storedAtNode === node).length;
                        const isCapital = node === nation.capital;
                        const isCryptic = !!node.crypticName;
                        return { node, dist, itemsStored, isCapital, isCryptic };
                    }).sort((a, b) => {
                        // Prefer cryptic nodes over capital
                        if (a.isCryptic && !b.isCryptic) return -1;
                        if (!a.isCryptic && b.isCryptic) return 1;
                        // Then prefer fewer items stored
                        if (a.itemsStored !== b.itemsStored) return a.itemsStored - b.itemsStored;
                        // Then prefer capital
                        if (a.isCapital && !b.isCapital) return -1;
                        if (!a.isCapital && b.isCapital) return 1;
                        // Finally by distance
                        return a.dist - b.dist;
                    });
                    
                    this.targetNode = storageLocations[0].node;
                    this.waypointNode = null; // Direct path
                    return; // ABORT - carrying artifact overrides all other tasks!
                }
                
                // Check if current target is still valid
                let shouldReassign = false;
                
                if (!this.targetNode) {
                    shouldReassign = true; // No target, need one
                } else if (this.targetNode.owner === this.nation) {
                    // Target was captured - ALWAYS reassign to next objective
                    shouldReassign = true;
                } else if (threatenedNodes.includes(this.targetNode)) {
                    // Target is under attack - emergency defense
                    shouldReassign = true;
                } else if (stuckNearMountains && nearbyEnemies.length === 0) {
                    // Stuck near mountains with no enemies in sight - probably trying to reach through mountain
                    shouldReassign = true;
                } else if (this.targetNode && this.targetNode.owner >= 0 && this.targetNode.owner !== this.nation) {
                    // Check if we're stuck trying to capture a node we CAN'T capture
                    const distToTarget = Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y);
                    
                    // STUCK DETECTION: Near target for extended time without capturing it
                    if (distToTarget < 60) {
                        // Track how long we've been near this node
                        if (!this.stuckAtNodeTimer) this.stuckAtNodeTimer = 0;
                        this.stuckAtNodeTimer += 1; // Increment on each order cycle
                        
                        // If stuck for 5+ order cycles (~15 seconds), check if capture is impossible
                        if (this.stuckAtNodeTimer > 5) {
                            // Check diplomatic relations - can't capture ally nodes
                            const targetOwner = this.targetNode.owner;
                            const myDiplomacy = nation.diplomaticRelations[targetOwner];
                            const theirDiplomacy = nations[targetOwner]?.diplomaticRelations[this.nation];
                            
                            const areAllies = myDiplomacy === DIPLOMATIC_STANCE.ALLIED || 
                                            theirDiplomacy === DIPLOMATIC_STANCE.ALLIED;
                            
                            // Check if target is heavily defended (many units)
                            let defenderCount = 0;
                            for (const unit of allUnits) {
                                if (unit.nation === targetOwner) {
                                    const d = Math.hypot(unit.x - this.targetNode.x, unit.y - this.targetNode.y);
                                    if (d < 80) defenderCount++;
                                }
                            }
                            
                            let attackerCount = 0;
                            for (const unit of allUnits) {
                                if (unit.nation === this.nation) {
                                    const d = Math.hypot(unit.x - this.targetNode.x, unit.y - this.targetNode.y);
                                    if (d < 80) attackerCount++;
                                }
                            }
                            
                            // Node is uncapturable if:
                            // 1. We're allies with the owner
                            // 2. Heavily defended (3+ defenders vs our attackers)
                            const heavilyDefended = defenderCount >= attackerCount + 3;
                            
                            if (areAllies || heavilyDefended) {
                                shouldReassign = true;
                                this.stuckAtNodeTimer = 0;
                                console.log(`Unit stuck at uncapturable node - reassigning (allies: ${areAllies}, defended: ${heavilyDefended})`);
                            }
                        }
                    } else {
                        // Not near target, reset stuck timer
                        this.stuckAtNodeTimer = 0;
                    }
                }
                
                // Only reassign if necessary
                if (!shouldReassign) {
                    return; // Keep current target, stop ping-ponging
                }
                
                // ============================================================
                // RADIAL EXPANSION SECURITY PERIMETER
                // Units expand outward in waves from capital, like cell wall projection
                // ============================================================
                
                // PRIORITY 1: Defend threatened nodes (EMERGENCY)
                // Only assign if we can actually reach it
                if (threatenedNodes.length > 0) {
                    for (const node of threatenedNodes) {
                        const dist = Math.hypot(node.x - this.x, node.y - this.y);
                        if (hasPathTo(this.x, this.y, node.x, node.y, Math.min(400, dist + 50))) {
                            this.role = 'garrison';
                            this.targetNode = node;
                            return;
                        }
                    }
                }
                
                // PRIORITY 1.5: FLANK/BORDER DEFENSE - protect exposed nodes from enemy flanking
                // Use cached exposed nodes from nation to avoid expensive per-unit scanning
                const exposedNodes = nation.cachedExposedNodes || [];
                
                // Only 25% of units defend flanks - most should be pushing fronts
                if (exposedNodes.length > 0 && Math.random() < 0.25) {
                    this.role = 'flankDefense';
                    // Choose border node that has fewer defenders AND clear path
                    let bestNode = null;
                    let leastDefenders = Infinity;
                    for (let node of exposedNodes) {
                        // Check if we can reach this node
                        const dist = Math.hypot(node.x - this.x, node.y - this.y);
                        if (!hasPathTo(this.x, this.y, node.x, node.y, Math.min(400, dist + 50))) continue;
                        
                        let defenderCount = 0;
                        for (let u of allUnits) {
                            if (u.nation === this.nation && u.targetNode === node) {
                                defenderCount++;
                            }
                        }
                        if (defenderCount < leastDefenders) {
                            leastDefenders = defenderCount;
                            bestNode = node;
                        }
                    }
                    if (bestNode) {
                        this.targetNode = bestNode;
                        return;
                    }
                }
                
                // PRIORITY 1.7: UNCLAIMED ARTIFACTS - ALWAYS pursue nearby artifacts first!
                // Don't use random chance - if there's an unclaimed artifact nearby, GET IT!
                // (Declare variables early to avoid redeclaration)
                const unclaimedArtifacts = artifacts.filter(a => a.capturedBy === -1 && a.hasSpawned);
                const myArtifacts = artifacts.filter(a => a.capturedBy === this.nation);
                
                if (unclaimedArtifacts.length > 0) {
                    // Find closest unclaimed artifact within reasonable range
                    let closestArtifact = null;
                    let closestDist = 400; // Only pursue if within 400 units
                    
                    for (const artifact of unclaimedArtifacts) {
                        const dist = Math.hypot(artifact.x - this.x, artifact.y - this.y);
                        if (dist < closestDist && hasPathTo(this.x, this.y, artifact.x, artifact.y, Math.min(500, dist + 100))) {
                            closestDist = dist;
                            closestArtifact = artifact;
                        }
                    }
                    
                    if (closestArtifact) {
                        this.role = 'captureArtifact';
                        this.targetArtifact = closestArtifact;
                        this.targetPos = { x: closestArtifact.x, y: closestArtifact.y };
                        return; // STOP - artifact capture takes priority over nodes!
                    }
                }
                
                // PRIORITY 1.8: STRATEGIC ARTIFACT CAPTURE - puzzle pieces unlock dominance
                // HIGHEST PRIORITY: Unlock keys for owned facilities!
                // Check if we own any unlock keys - if so, prioritize retrieving and delivering them!
                const unlockMappings = {
                    'lab_key': 'lab',
                    'safe_key': 'safe',
                    'access_card': 'reactor',
                    'auth_code': 'prototype'
                };
                
                // Variables already declared above - reuse them
                
                // CRITICAL: Check for keys that need to be delivered to facilities
                for (const [keyType, facilityType] of Object.entries(unlockMappings)) {
                    const ownedKey = myArtifacts.find(a => a.type === keyType);
                    if (ownedKey) {
                        // We have the key! Find the facility
                        const facility = artifacts.find(a => 
                            a.type === facilityType && 
                            !a.movable &&
                            a.hasSpawned && // Only target spawned facilities
                            !a.isUnlocked && // Still locked
                            !a.isSecureLocked // Not in security lockdown
                        );
                        
                        if (facility && facility.capturedBy === this.nation) {
                            // WE OWN BOTH THE KEY AND THE FACILITY!
                            // Check if key is stored at a node - need to retrieve it
                            if (ownedKey.storedAtNode) {
                                // Key is stored at a node - send unit to retrieve it and bring to facility
                                const keyNode = ownedKey.storedAtNode;
                                const distToKey = Math.hypot(keyNode.x - this.x, keyNode.y - this.y);
                                const distFacilityToKey = Math.hypot(facility.x - keyNode.x, facility.y - keyNode.y);
                                
                                // Only retrieve if reasonably close and facility needs it
                                if (distToKey < 800 && distFacilityToKey > 150) {
                                    this.role = 'retrieveKey';
                                    this.targetPos = { x: keyNode.x, y: keyNode.y };
                                    this.targetArtifact = ownedKey;
                                    this.deliveryTarget = facility; // Where to bring the key
                                    return; // HIGH PRIORITY - unlock facilities!
                                }
                            } else if (!ownedKey.carrier && ownedKey.capturedBy === this.nation) {
                                // Key is loose but owned - capture it
                                const distToKey = Math.hypot(ownedKey.x - this.x, ownedKey.y - this.y);
                                if (distToKey < 500) {
                                    this.role = 'captureArtifact';
                                    this.targetArtifact = ownedKey;
                                    return;
                                }
                            } else if (ownedKey.carrier && ownedKey.carrier.nation === this.nation) {
                                // Key is being carried by friendly unit
                                // Check if carrier is near facility (within unlock range)
                                const carrierDistToFacility = Math.hypot(ownedKey.x - facility.x, ownedKey.y - facility.y);
                                if (carrierDistToFacility > 150) {
                                    // Carrier not near facility - escort them there
                                    this.role = 'escortKey';
                                    this.targetPos = { x: facility.x, y: facility.y };
                                    this.targetArtifact = ownedKey;
                                    return;
                                }
                            }
                        } else if (facility && facility.capturedBy === -1) {
                            // Facility is uncaptured - capture it first!
                            const dist = Math.hypot(facility.x - this.x, facility.y - this.y);
                            if (dist < 800 && hasPathTo(this.x, this.y, facility.x, facility.y, Math.min(500, dist + 100))) {
                                this.role = 'captureFacility';
                                this.targetPos = { x: facility.x, y: facility.y };
                                this.targetArtifact = facility;
                                return;
                            }
                        }
                    }
                }
                
                // Dominant nations (70%+ nodes) AGGRESSIVELY pursue artifacts
                // PRIORITIZE artifacts that are dependencies for artifacts we already own
                
                // PRIORITY: Archive studied strategic plans (move to safe storage, make room for new ones)
                const studiedPlans = myArtifacts.filter(a => a.type === 'plans' && a.isStudied && !a.storedAtNode);
                if (studiedPlans.length > 0) {
                    // Find a plan carrier who should archive it
                    const carriedStudiedPlan = studiedPlans.find(plan => {
                        const carrier = nation.units.find(u => {
                            const carrying = artifacts.find(a => 
                                a.capturedBy === this.nation && 
                                !a.storedAtNode && 
                                Math.hypot(a.x - u.x, a.y - u.y) < 5
                            );
                            return carrying === plan;
                        });
                        return carrier === this;
                    });
                    
                    if (carriedStudiedPlan) {
                        // Archive this studied plan at a named node or capital
                        const archiveLocations = [];
                        
                        // Prefer named nodes for archives
                        myNodes.forEach(node => {
                            if (node.crypticName) {
                                archiveLocations.push({
                                    node: node,
                                    dist: Math.hypot(node.x - this.x, node.y - this.y),
                                    itemCount: artifacts.filter(a => a.storedAtNode === node).length
                                });
                            }
                        });
                        
                        // Capital as fallback
                        if (nation.capital && nation.capital.owner === this.nation) {
                            archiveLocations.push({
                                node: nation.capital,
                                dist: Math.hypot(nation.capital.x - this.x, nation.capital.y - this.y),
                                itemCount: artifacts.filter(a => a.storedAtNode === nation.capital).length
                            });
                        }
                        
                        if (archiveLocations.length > 0) {
                            // Sort by item count (prefer less crowded) then distance
                            archiveLocations.sort((a, b) => {
                                if (a.itemCount !== b.itemCount) return a.itemCount - b.itemCount;
                                return a.dist - b.dist;
                            });
                            
                            this.role = 'archiveStudiedPlan';
                            this.targetNode = archiveLocations[0].node;
                            this.waypointNode = null;
                            return; // Archive studied plans before capturing new ones
                        }
                    }
                }
                
                // Calculate nation dominance (% of total nodes controlled)
                const myNodeCount = myNodes.length;
                const totalNodes = nodes.length;
                const dominancePercent = totalNodes > 0 ? myNodeCount / totalNodes : 0;
                
                // Artifact capture priority scales with dominance
                // 50% nodes: 30% chance
                // 60% nodes: 50% chance
                // 70% nodes: 70% chance (DOMINANT)
                // 80% nodes: 90% chance (OVERWHELMING)
                // 90%+ nodes: 100% chance (ABSOLUTE - must collect all puzzles)
                let artifactPriority = 0.3; // Base 30% chance
                if (dominancePercent >= 0.5) {
                    artifactPriority = Math.min(1.0, 0.3 + (dominancePercent - 0.5) * 2.0);
                }
                
                if (unclaimedArtifacts.length > 0 && Math.random() < artifactPriority) {
                    // STRATEGIC INCENTIVE: If we own a Nexus node, prioritize Strategic Plans!
                    const ownNexus = myNodes.some(n => n.crypticData && n.crypticData.buff === 'Movement Hub');
                    
                    // FILTER: Exclude studied strategic plans from capture targets
                    // Focus on unstudied plans if any are available
                    const unstudiedPlans = unclaimedArtifacts.filter(a => a.type === 'plans' && !a.isStudied);
                    const studiedPlansUnclaimed = unclaimedArtifacts.filter(a => a.type === 'plans' && a.isStudied);
                    const nonPlanArtifacts = unclaimedArtifacts.filter(a => a.type !== 'plans');
                    
                    // Priority: unstudied plans (if we have Nexus) > other artifacts > studied plans (only if nothing else)
                    let availableArtifacts = unclaimedArtifacts;
                    if (ownNexus && unstudiedPlans.length > 0) {
                        // WE HAVE A NEXUS! Prioritize Strategic Plans to study there
                        availableArtifacts = [...unstudiedPlans, ...nonPlanArtifacts];
                    } else if (unstudiedPlans.length > 0) {
                        // Prioritize unstudied plans (even without Nexus, we might capture one later)
                        availableArtifacts = [...unstudiedPlans, ...nonPlanArtifacts];
                    } else if (nonPlanArtifacts.length > 0) {
                        // No unstudied plans, focus on other artifacts
                        availableArtifacts = nonPlanArtifacts;
                    }
                    // else: only studied plans available, capture them if needed
                    
                    // Find dependency artifacts first (highest priority)
                    const neededDependencies = [];
                    myArtifacts.forEach(owned => {
                        if (owned.requires && !myArtifacts.some(a => a.type === owned.requires)) {
                            // We own an artifact but don't have its dependency
                            const dependencyArtifact = availableArtifacts.find(a => a.type === owned.requires && a.hasSpawned);
                            if (dependencyArtifact) {
                                neededDependencies.push(dependencyArtifact);
                            }
                        }
                    });
                    
                    // Prioritize dependencies, then any available artifact (filtered for unstudied plans)
                    const targetPool = neededDependencies.length > 0 ? neededDependencies : availableArtifacts;
                    
                    // Find closest artifact from target pool with path
                    let bestArtifact = null;
                    let bestDist = Infinity;
                    
                    for (const artifact of targetPool) {
                        const dist = Math.hypot(artifact.x - this.x, artifact.y - this.y);
                        if (dist < bestDist && hasPathTo(this.x, this.y, artifact.x, artifact.y, Math.min(500, dist + 100))) {
                            bestDist = dist;
                            bestArtifact = artifact;
                        }
                    }
                    
                    if (bestArtifact) {
                        this.role = 'captureArtifact';
                        this.targetArtifact = bestArtifact;
                        this.targetPos = { x: bestArtifact.x, y: bestArtifact.y };
                        return;
                    }
                }
                
                // PRIORITY 1.8: INFILTRATION - Steal artifacts from enemy nodes (low chance, high reward)
                const carryingArtifact = artifacts.find(a => a.carrier === this);
                if (!carryingArtifact && Math.random() < 0.015) { // 1.5% chance per unit assignment
                    // Find enemy-controlled nodes with stored artifacts
                    const enemyNodesWithArtifacts = nodes.filter(n => {
                        if (n.owner < 0 || n.owner === this.nation) return false; // Skip neutral and owned
                        const artifactsStored = artifacts.filter(a => a.storedAtNode === n && a.movable);
                        return artifactsStored.length > 0;
                    });
                    
                    if (enemyNodesWithArtifacts.length > 0) {
                        // Pick closest target
                        let closest = enemyNodesWithArtifacts[0];
                        let closestDist = Math.hypot(closest.x - this.x, closest.y - this.y);
                        for (const node of enemyNodesWithArtifacts) {
                            const dist = Math.hypot(node.x - this.x, node.y - this.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closest = node;
                            }
                        }
                        
                        this.role = 'infiltrate';
                        this.targetNode = closest;
                        this.infiltrationTimer = 0; // Reset timer
                        return;
                    }
                }
                
                // PRIORITY 1.9: Occasional territory expansion - small percentage seek unclaimed land
                // This makes territory control matter as a secondary objective alongside nodes
                if (Math.random() < 0.15 && uncontrolledNodes.length > 0) {
                    const targetPos = this.findNearestUnpaintedArea(influenceGrid, gridSize);
                    if (targetPos) {
                        this.role = 'territorial';
                        this.targetPos = targetPos;
                        return;
                    }
                }
                
                // PRIORITY 2: Radial expansion - units form security waves expanding outward
            // TARGET WEAKEST NEIGHBORS FIRST - prioritize nodes from weaker enemies
            if (uncontrolledNodes.length > 0 && nation.capital) {
                // STRATEGIC INCENTIVE: If we own Strategic Plans, prioritize Nexus (Movement Hub) nodes!
                const ownPlans = myArtifacts.some(a => a.type === 'plans' && !a.isStudied);
                
                // Filter out nodes we can't capture due to diplomatic relations
                const capturableNodes = uncontrolledNodes.filter(n => {
                    if (n.owner < 0) return true; // Neutral nodes always capturable
                    
                    const myDiplomacy = nation.diplomaticRelations[n.owner];
                    const theirDiplomacy = nations[n.owner]?.diplomaticRelations[this.nation];
                    
                    // Can't capture ally nodes
                    const areAllies = myDiplomacy === DIPLOMATIC_STANCE.ALLIED || 
                                    theirDiplomacy === DIPLOMATIC_STANCE.ALLIED;
                    
                    return !areAllies;
                });
                
                // Find capturable nodes sorted by enemy strength (weakest first) then distance
                // Prioritize nodes with DIRECT LINE OF SIGHT (no mountains in the way)
                const nodesByPriority = capturableNodes
                    .map(n => {
                        const dist = Math.hypot(n.x - this.x, n.y - this.y);
                        const hasDirectPath = hasPathTo(this.x, this.y, n.x, n.y, Math.min(300, dist + 50));
                        const crossesRiver = pathCrossesRiver(this.x, this.y, n.x, n.y);
                        
                        // STRATEGIC BOOST: If this is a Nexus and we have unstudied plans, PRIORITIZE IT!
                        const isNexus = n.crypticData && n.crypticData.buff === 'Movement Hub';
                        const strategicPriority = (ownPlans && isNexus) ? -10000 : 0; // Huge priority boost
                        
                        // Calculate enemy strength (weakest = highest priority)
                        let enemyStrength = 0;
                        if (n.owner >= 0 && nations[n.owner]) {
                            enemyStrength = nations[n.owner].units.length;
                        }
                        
                        // CONTINENTAL PREFERENCE: Penalize river crossings heavily
                        // Units prefer to expand on their current landmass
                        const riverPenalty = crossesRiver ? 400 : 0; // Massive distance penalty
                        
                        return { 
                            node: n, 
                            dist: dist, 
                            hasDirectPath: hasDirectPath, 
                            enemyStrength: enemyStrength,
                            strategicPriority: strategicPriority,
                            isNexus: isNexus,
                            crossesRiver: crossesRiver,
                            effectiveDistance: dist + riverPenalty // Apply river penalty to distance
                        };
                    })
                    .sort((a, b) => {
                        // 0. STRATEGIC PRIORITY FIRST - Nexus nodes when we have Plans!
                        if (a.strategicPriority !== b.strategicPriority) {
                            return a.strategicPriority - b.strategicPriority;
                        }
                        
                        // 1. Prioritize direct paths first
                        if (a.hasDirectPath && !b.hasDirectPath) return -1;
                        if (!a.hasDirectPath && b.hasDirectPath) return 1;
                        
                        // 2. Then prioritize weakest enemies (lower unit count = higher priority)
                        if (a.enemyStrength !== b.enemyStrength) {
                            return a.enemyStrength - b.enemyStrength;
                        }
                        
                        // 3. Sort by effective distance (includes river penalty)
                        // This creates continental preference naturally
                        return a.effectiveDistance - b.effectiveDistance;
                    });
                
                // Priority 2a: Target nodes with direct line of sight first
                // These are the nodes "in sight" that units can reach immediately
                // DIVERSIFY targeting - spread units across multiple objectives instead of clustering
                // VULNERABILITY: Prioritize nodes storing artifacts (steal enemy items!)
                const nodesStoringArtifacts = nodes.filter(n => {
                    const stored = artifacts.filter(a => a.storedAtNode === n);
                    return stored.length > 0 && n.owner !== this.nation;
                });
                
                for (const storageNode of nodesStoringArtifacts) {
                    const dist = Math.hypot(storageNode.x - this.x, storageNode.y - this.y);
                    if (dist < 600 && hasPathTo(this.x, this.y, storageNode.x, storageNode.y, Math.min(400, dist + 50))) {
                        // HIGH PRIORITY - steal enemy artifacts!
                        this.role = 'expand';
                        this.targetNode = storageNode;
                        return;
                    }
                }
                
                // Priority 2: Direct path nodes with unit limit
                const directPathNodes = nodesByPriority.filter(nd => nd.hasDirectPath);
                for (let {node, dist, hasDirectPath} of directPathNodes) {
                    // Quick count without full filter
                    let unitsTargetingNode = 0;
                    for (let u of allUnits) {
                        if (u.nation === this.nation && u.targetNode === node) {
                            unitsTargetingNode++;
                            if (unitsTargetingNode >= 3) break; // Back to 3 for better spreading
                        }
                    }
                    
                    // Max 3 units per target - prevents clustering while maintaining effective force
                    if (unitsTargetingNode >= 3) continue;
                    
                    this.role = 'expand';
                    this.targetNode = node;
                    return;
                }
                
                // Priority 2b: If no direct paths available, fall back to prioritized nodes
                // (waypoint system will handle routing around mountains)
                if (nodesByPriority.length > 0) {
                    this.role = 'expand';
                    this.targetNode = nodesByPriority[0].node;
                    return;
                }
                
                // PRIORITY 3: Hold positions at friendly nodes
                // If no targets, garrison nearest friendly node
                if (myNodes.length > 0) {
                    this.role = 'garrison';
                    this.targetNode = this.findClosest(myNodes);
                } else if (nation.capital) {
                    this.role = 'garrison';
                    this.targetNode = nation.capital;
                }
                
                // PATHFINDING: Set waypoint if mountain blocks direct path to target
                // Units near capital should ALWAYS route through friendly nodes to avoid mountains
                // ARTIFACT CARRIERS SKIP PATHFINDING - they phase through mountains
                const carryingArtifactPathfinding = artifacts.find(a => a.carrier === this);
                this.waypointNode = null;
                if (this.targetNode && myNodes.length > 0 && !carryingArtifactPathfinding) {
                    // Check if direct path to target crosses mountains
                    const directDist = Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y);
                    
                    // Units near capital are more cautious - check path even if seems close
                    const distToCapital = nation.capital ? Math.hypot(this.x - nation.capital.x, this.y - nation.capital.y) : Infinity;
                    const nearCapital = distToCapital < 400;
                    
                    // If near capital OR path blocked, find waypoint
                    const pathBlocked = !hasPathTo(this.x, this.y, this.targetNode.x, this.targetNode.y, Math.min(600, directDist + 100));
                    const shouldUseWaypoint = pathBlocked || (nearCapital && directDist > 150);
                    
                    if (shouldUseWaypoint) {
                        // Find nearest friendly node to route through
                        let bestWaypoint = null;
                        let bestScore = Infinity;
                        
                        for (const node of myNodes) {
                            const distToWaypoint = Math.hypot(node.x - this.x, node.y - this.y);
                            const distToTarget = Math.hypot(this.targetNode.x - node.x, this.targetNode.y - node.y);
                            
                            // CRITICAL: Check BOTH paths are clear
                            // 1. Unit to waypoint must be clear
                            if (!hasPathTo(this.x, this.y, node.x, node.y, Math.min(400, distToWaypoint + 50))) continue;
                            
                            // 2. Waypoint to target must be clear
                            if (!hasPathTo(node.x, node.y, this.targetNode.x, this.targetNode.y, Math.min(600, distToTarget + 50))) continue;
                            
                            // Score = total distance via waypoint
                            const score = distToWaypoint + distToTarget;
                            
                            if (score < bestScore) {
                                bestScore = score;
                                bestWaypoint = node;
                            }
                        }
                        
                        // If NO valid waypoint found and path is blocked, CLEAR THE TARGET
                        // Don't let units get stuck trying to reach unreachable objectives
                        if (!bestWaypoint && pathBlocked) {
                            this.targetNode = null;
                            this.role = null;
                        } else {
                            this.waypointNode = bestWaypoint;
                        }
                    }
                }
            }
            }
            
            findClosest(nodes) {
                if (nodes.length === 0) return null;
                let closest = nodes[0];
                let closestDist = Math.hypot(this.x - closest.x, this.y - closest.y);
                for (let node of nodes) {
                    const dist = Math.hypot(this.x - node.x, this.y - node.y);
                    if (dist < closestDist) {
                        closest = node;
                        closestDist = dist;
                    }
                }
                return closest;
            }
            
            update(dt, allUnits, nodes) {
                // Safety check: Fix NaN positions immediately
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    const nation = nations[this.nation];
                    if (nation && nation.capital) {
                        this.x = nation.capital.x + (Math.random() - 0.5) * 50;
                        this.y = nation.capital.y + (Math.random() - 0.5) * 50;
                    } else {
                        this.x = canvas.width / 2;
                        this.y = canvas.height / 2;
                    }
                    this.vx = 0;
                    this.vy = 0;
                }
                
                this.age += dt;
                this.battleCooldown = Math.max(0, this.battleCooldown - dt);
                
                // Veterancy - units gain experience over time and in combat
                if (this.veterancy < 100) {
                    // Base experience gain: 1 point per 10 seconds of survival
                    this.veterancy = Math.min(100, this.veterancy + dt * 0.1);
                }
                
                // CAPITULATED NATION BEHAVIOR
                const myNation = nations[this.nation];
                let friendliesNearCapital = 0; // Declare early for capitulation check

                // Keep intercept courses updated for moving superweapons
                if (this.targetSuperweapon && !superweapons.includes(this.targetSuperweapon)) {
                    this.targetSuperweapon = null;
                    if (this.role === 'interceptSuperweapon') {
                        this.role = null;
                        this.targetNode = null;
                        this.targetPos = null;
                    }
                } else if (this.targetSuperweapon) {
                    this.targetPos = { x: this.targetSuperweapon.x, y: this.targetSuperweapon.y };
                }
                
                if (myNation.capitulated && myNation.capital) {
                    // Only apply capitulation behavior if nation has a capital to retreat to
                    // Resistance fighters (defected units) don't have capitals, so they act normally
                    
                    // Harsh attrition for defeated units
                    const attritionRate = 0.15; // 15% chance per second
                    if (Math.random() < dt * attritionRate) {
                        this.health -= 30;
                    }
                    
                    // Count friendlies near capital for resurrection
                    if (myNation.capital) {
                        for (let u of allUnits) {
                            if (u.nation === this.nation) {
                                const capDx = u.x - myNation.capital.x;
                                const capDy = u.y - myNation.capital.y;
                                if (capDx * capDx + capDy * capDy < 3600) { // 60 units radius
                                    friendliesNearCapital++;
                                }
                            }
                        }
                    }
                    
                    // Rush back to capital to attempt resurrection
                    if (myNation.capital) {
                        const dx = myNation.capital.x - this.x;
                        const dy = myNation.capital.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Desperate sprint toward capital
                            this.vx = (dx / dist) * 2.5;
                            this.vy = (dy / dist) * 2.5;
                            
                            // Avoid bunching - add spreading force from other retreating allies
                            let spreadX = 0, spreadY = 0;
                            for (let other of allUnits) {
                                if (other.nation === this.nation && other !== this) {
                                    const odx = this.x - other.x;
                                    const ody = this.y - other.y;
                                    const odist = Math.sqrt(odx * odx + ody * ody);
                                    if (odist < 20 && odist > 0) {
                                        spreadX += (odx / odist) * 0.5;
                                        spreadY += (ody / odist) * 0.5;
                                    }
                                }
                            }
                            this.vx += spreadX;
                            this.vy += spreadY;
                        }
                        
                        // Check if we can resurrect the capital (count already cached above)
                        if (dist < 50 && myNation.capital.owner !== this.nation) {
                            // Initialize resurrection progress tracking
                            if (!myNation.resurrectionProgress) {
                                myNation.resurrectionProgress = 0; // 0-100 progress
                                myNation.resurrectionStartTime = Date.now();
                            }
                            
                            // Need significant force to resurrect (at least 15 units)
                            if (friendliesNearCapital >= 15) {
                                // Accumulate resurrection progress over time (2-6 minutes)
                                // More units = faster resurrection (15 units = 6min, 50+ units = 2min)
                                const unitCountFactor = Math.min(friendliesNearCapital / 50, 1.0); // 0.3 to 1.0
                                const baseTime = 360; // 6 minutes base
                                const fastTime = 120; // 2 minutes with overwhelming force
                                const resurrectionTime = baseTime - (baseTime - fastTime) * unitCountFactor;
                                
                                const progressPerSecond = 100 / resurrectionTime;
                                myNation.resurrectionProgress += progressPerSecond * dt;
                                
                                if (myNation.resurrectionProgress >= 100) {
                                    // Check resurrection limit - only allow 2 resurrections per nation
                                    const MAX_RESURRECTIONS = 2;
                                    
                                    if (myNation.resurrectionCount >= MAX_RESURRECTIONS) {
                                        // Nation has resurrected too many times - permanent death
                                        // Kill all remaining units to allow new nation spawn
                                        myNation.units.forEach(u => u.health = 0);
                                        myNation.resurrectionProgress = 0;
                                        myNation.capitulated = true; // Stay dead
                                        return; // Exit early - no resurrection
                                    }
                                    
                                    // RESURRECTION COMPLETE! Recapture capital
                                    myNation.capital.owner = this.nation;
                                    myNation.capital.controlStrength = 1.0;
                                    myNation.capitulated = false;
                                    myNation.resurrectionCount++; // Increment resurrection counter
                                    myNation.resurrectionProgress = 0;
                                    
                                    // Restore morale of surviving units
                                    myNation.units.forEach(u => {
                                        u.morale = 0.8;
                                    });
                                }
                            } else {
                                // Not enough units - reset progress (need sustained effort)
                                myNation.resurrectionProgress = Math.max(0, myNation.resurrectionProgress - dt * 5); // Decay 5% per second
                            }
                        } else {
                            // Moved away from capital or capital already captured - reset progress
                            if (myNation.resurrectionProgress) {
                                myNation.resurrectionProgress = 0;
                            }
                        }
                    }
                    
                    // Early exit - capitulated units don't do normal behavior
                    this.x += this.vx * gameSpeed;
                    this.y += this.vy * gameSpeed;
                    this.vx *= 0.85;
                    this.vy *= 0.85;
                    return;
                }
                
                // Morale regeneration when not in battle
                if (!this.inBattle) {
                    this.morale = Math.min(1.0, this.morale + dt * 0.1);
                    
                    // VULNERABILITY: Prototype Facility drains morale (experimental weapons unreliable)
                    const myArtifactBonuses = getArtifactBonuses(this.nation);
                    if (myArtifactBonuses.moraleDrain) {
                        this.morale = Math.max(0, this.morale - dt * myArtifactBonuses.moraleDrain);
                    }
                }
                
                this.inBattle = false;
                
                // Calculate nearby enemies and allies using spatial grid
                const detectionRadius = 60;
                const rearguardRadius = 120; // Extended range for detecting flanking threats
                const combatRadius = 15;
                const nearbyEnemies = [];
                const nearbyAllies = [];
                const nearbyForeignAllies = []; // Allied but different nations - for standoff
                const flankingThreats = []; // Enemies approaching from behind or sides
                
                // Use spatial grid for efficient queries
                const candidates = getNearbyUnits(this.x, this.y, detectionRadius, true);
                const extendedCandidates = getNearbyUnits(this.x, this.y, rearguardRadius, true);
                
                // Helper function to check if two nations are at war
                const thisNation = nations[this.nation];
                const areAtWar = (otherNationId) => {
                    if (!thisNation.diplomaticRelations) return false; // Default to peaceful if no diplomacy system
                    const stance = thisNation.diplomaticRelations[otherNationId];
                    // ONLY at WAR stance counts as hostile - NEUTRAL is not hostile!
                    return stance === DIPLOMATIC_STANCE.WAR;
                };
                
                const areAllied = (otherNationId) => {
                    if (!thisNation.diplomaticRelations) return false;
                    const stance = thisNation.diplomaticRelations[otherNationId];
                    return stance === DIPLOMATIC_STANCE.ALLIED;
                };
                
                for (let other of candidates) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < detectionRadius) {
                        // LINE OF SIGHT CHECK - can't see through mountains
                        const hasLOS = hasPathTo(this.x, this.y, other.x, other.y, dist + 10);
                        if (!hasLOS) continue; // Skip units blocked by mountains
                        
                        if (other.nation === this.nation) {
                            nearbyAllies.push({ unit: other, dist, dx, dy });
                        } else if (areAtWar(other.nation)) {
                            // Only count as enemy if at war or neutral (not allied/trade/non-aggression)
                            nearbyEnemies.push({ unit: other, dist, dx, dy });
                        } else {
                            // Friendly/neutral - treat as ally for movement purposes
                            nearbyAllies.push({ unit: other, dist, dx, dy });
                            // Track foreign allies separately for standoff distance
                            if (areAllied(other.nation)) {
                                nearbyForeignAllies.push({ unit: other, dist, dx, dy, nationId: other.nation });
                            }
                        }
                    }
                }
                
                // FLANKING THREAT DETECTION - check extended radius for enemies approaching from behind/sides
                // Determine our current facing direction based on velocity or target
                let facingX = 0, facingY = 0;
                if (this.targetNode) {
                    facingX = this.targetNode.x - this.x;
                    facingY = this.targetNode.y - this.y;
                } else if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    facingX = this.vx;
                    facingY = this.vy;
                } else {
                    facingX = 1; facingY = 0; // Default forward
                }
                const facingDist = Math.sqrt(facingX * facingX + facingY * facingY);
                if (facingDist > 0) {
                    facingX /= facingDist;
                    facingY /= facingDist;
                }
                
                for (let other of extendedCandidates) {
                    if (other === this || other.nation === this.nation) continue;
                    if (!areAtWar(other.nation)) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < rearguardRadius && dist >= detectionRadius) {
                        // Check angle relative to facing direction
                        const dotProduct = (dx * facingX + dy * facingY) / dist;
                        // dotProduct: 1.0 = directly ahead, 0.0 = perpendicular, -1.0 = directly behind
                        
                        // Flanking threat if enemy is behind or to the side (dot < 0.3 means >70 degree angle)
                        if (dotProduct < 0.3) {
                            flankingThreats.push({ unit: other, dist, dx, dy, angle: dotProduct });
                        }
                    }
                }
                
                // CUT-OFF DETECTION - unit is isolated from friendly support
                // Check if in friendly territory OR near friendly units
                const gx = Math.floor(this.x / gridSize);
                const gy = Math.floor(this.y / gridSize);
                let inFriendlyTerritory = false;
                
                if (gy >= 0 && gy < influenceGrid.length && 
                    gx >= 0 && gx < influenceGrid[0].length) {
                    const cell = influenceGrid[gy][gx];
                    inFriendlyTerritory = cell.nation === this.nation && cell.strength > 0.3;
                }
                
                const hasFriendlySupport = nearbyAllies.length > 0;
                const isCutOff = !inFriendlyTerritory && !hasFriendlySupport;
                
                // === ARTIFACT CARRIER/SEEKER PRIORITY EVASION - HIGHEST PRIORITY ===
                // Units carrying or seeking artifacts MUST avoid all combat - this overrides normal behavior
                const carryingArtifact = artifacts.find(a => a.carrier === this);
                const goingForArtifact = this.role === 'captureArtifact' && this.targetArtifact;
                const isArtifactMission = carryingArtifact || goingForArtifact;
                
                if (isArtifactMission && nearbyEnemies.length > 0) {
                    // EMERGENCY EVASION - artifact units flee from ALL enemies
                    let emergencyEvadeX = 0;
                    let emergencyEvadeY = 0;
                    
                    nearbyEnemies.forEach(enemy => {
                        if (enemy.dist < 150) { // Very wide threat detection for artifact units
                            const dx = this.x - enemy.unit.x;
                            const dy = this.y - enemy.unit.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                // STRONG evasion force - flee aggressively
                                const threatLevel = (150 - enemy.dist) / 150;
                                const evadeForce = 6.0 * threatLevel; // Very strong flee
                                emergencyEvadeX += (dx / dist) * evadeForce;
                                emergencyEvadeY += (dy / dist) * evadeForce;
                            }
                        }
                    });
                    
                    // Move toward safety while evading
                    const myNation = nations[this.nation];
                    let safeTarget = null;
                    
                    if (carryingArtifact) {
                        // Carrying: flee to storage node or capital
                        safeTarget = this.targetNode || this.nearestFriendlyNode || myNation.capital;
                    } else if (goingForArtifact) {
                        // Seeking: try to reach artifact while evading
                        safeTarget = this.targetArtifact;
                    }
                    
                    if (safeTarget) {
                        const dx = safeTarget.x - this.x;
                        const dy = safeTarget.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            emergencyEvadeX += (dx / dist) * 3.0;
                            emergencyEvadeY += (dy / dist) * 3.0;
                        }
                    }
                    
                    // Apply emergency evasion - this takes priority over everything
                    this.vx += emergencyEvadeX;
                    this.vy += emergencyEvadeY;
                    
                    // Mark as locked to prevent combat engagement
                    this.isLocked = true;
                    this.lockTimer = 0.5; // Short lock to prevent fighting
                }
                
                // COLLISION AND ENGAGEMENT - minimal personal space buffer
                // Check if we're at ANY node to suppress collision orbits
                let atCaptureNodeCheck = false;
                if (this.targetNode) {
                    const dist = Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y);
                    if (dist < 60) {
                        atCaptureNodeCheck = true;
                    }
                }
                
                let collisionForceX = 0;
                let collisionForceY = 0;
                const personalSpace = 10; // Personal space buffer - breathing room
                const engagementRange = 35; // Contact distance for melee
                
                this.inBattle = false;
                this.engagedEnemies = [];
                
                // Decay lock timer
                if (this.lockTimer > 0) {
                    this.lockTimer -= dt;
                }
                
                // Use spatial grid for collision checks (performance)
                const collisionCandidates = getNearbyUnits(this.x, this.y, Math.max(personalSpace, engagementRange) * 2, true);
                
                // Apply collision forces (reduced at capture nodes to prevent tight overlap)
                const collisionMultiplier = atCaptureNodeCheck ? 0.3 : 1.0;
                
                // Track pressure on allied nations
                let allyPressureDetected = false;
                
                for (let other of collisionCandidates) {
                    if (other === this) continue;
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Allied standoff distance - give foreign allies some breathing room
                    // This allows for pressure/backstabbing while maintaining some separation
                    const isAlly = other.nation !== this.nation && areAllied(other.nation);
                    const allyStandoffDistance = 18; // Larger than personal space, smaller than engagement
                    
                    if (isAlly && dist < allyStandoffDistance && dist > 0) {
                        // Gentle repulsion from allies - creates standoff
                        const overlap = allyStandoffDistance - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const force = overlap * 3.0; // Much gentler than enemy collision
                        
                        collisionForceX += nx * force;
                        collisionForceY += ny * force;
                        
                        // If we're very close, it's pressure - potential backstabbing
                        if (dist < 12) {
                            allyPressureDetected = true;
                        }
                    }
                    
                    // Personal space buffer - prevent particle overlap (ALL units)
                    if (dist < personalSpace && dist > 0 && !isAlly) {
                        const overlap = personalSpace - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const force = overlap * 15.0 * collisionMultiplier; // Scale by capture status
                        
                        collisionForceX += nx * force;
                        collisionForceY += ny * force;
                    }
                    
                    // Enemy engagement at close range - ALWAYS check, even at capture nodes
                    if (other.nation !== this.nation && dist < engagementRange && dist > 0) {
                        // ARTIFACT CARRIERS/SEEKERS NEVER ENGAGE - skip combat entirely
                        // (using carryingArtifact and isArtifactMission from outer scope)
                        
                        if (isArtifactMission) {
                            // Artifact units FLEE, never fight - skip this engagement
                            continue;
                        }
                        
                        // Check if enemy is a superweapon - units will sacrifice to engage them
                        const enemyIsSuperweapon = other.isSuperweapon === true;
                        
                        // ARTIFACT CARRIERS SKIP SUPERWEAPON INTERCEPTION - they have ONE job: deliver
                        const isCarryingArtifactCombat = artifacts.find(a => a.carrier === this);
                        if (enemyIsSuperweapon && isCarryingArtifactCombat) {
                            // Skip this engagement - artifact delivery is more important
                            continue;
                        }
                        
                        // VULNERABILITY: Check if enemy is carrying artifact (for damage reduction)
                        const enemyCarryingArtifact = artifacts.find(a => a.carrier === other);
                        
                        // Count local force balance
                        const localEnemies = nearbyEnemies.filter(e => e.dist < 40).length;
                        const localAllies = nearbyAllies.filter(a => a.dist < 40).length;
                        const outnumbered = localEnemies > localAllies + 1;
                        
                        // Normal engagement rules for non-artifact units
                        const canEngage = enemyIsSuperweapon || // ALWAYS engage superweapons to halt them
                                         (!isCutOff && !outnumbered) || // Not isolated AND not outnumbered
                                         (inFriendlyTerritory && !outnumbered) || // In our territory with numbers
                                         (nearbyAllies.length >= localEnemies * 1.5); // Clear numerical advantage
                        
                        if (canEngage) {
                            // Track engagement
                            this.engagedEnemies.push(other);
                            this.inBattle = true;
                            this.isLocked = true;
                            this.lockTimer = 3.0; // Stay locked for 3 seconds after contact
                            
                            // COMBAT - fight enemies we're touching
                            if (this.battleCooldown <= 0) {
                                const strengthMod = getUnitStrengthModifier(myNation);
                                const baseAttack = this.strength * strengthMod;
                                const enemyNation = nations[other.nation];
                                const enemyStrengthMod = enemyNation ? getUnitStrengthModifier(enemyNation) : 1.0;
                                const enemyIsSuperweapon = other.isSuperweapon === true;

                                // MONUMENT buff: +15% strength within 300 units of Monument node
                                const myMonumentBonus = getMonumentBonus(this.x, this.y, this.nation);
                                const enemyMonumentBonus = getMonumentBonus(other.x, other.y, other.nation);

                                // Veterancy bonuses: 0-100% extra effectiveness
                                const myVetBonus = 1.0 + (this.veterancy / 100) * 1.0;
                                const enemyVetBonus = enemyIsSuperweapon ? 1.0 : 1.0 + (other.veterancy / 100) * 1.0;

                                // Damage calculation with veterancy, RNG, and Monument bonuses
                                let damage = baseAttack * 20 * dt * myVetBonus * myMonumentBonus * (1.0 + this.damageBonus);
                                let enemyDamage = enemyIsSuperweapon
                                    ? (other.attackPower || other.baseAttackPower || 150) * 0.5 * dt
                                    : other.strength * enemyStrengthMod * 20 * dt * enemyVetBonus * enemyMonumentBonus * (1.0 + (other.damageBonus || 0));

                                // Apply artifact bonuses
                                const myArtifactBonuses = getArtifactBonuses(this.nation);
                                const enemyArtifactBonuses = getArtifactBonuses(other.nation);
                                damage *= myArtifactBonuses.unitDamage;
                                enemyDamage *= enemyArtifactBonuses.unitDamage;
                                
                                // VULNERABILITY: Artifact carriers deal 50% less damage (distracted, protecting cargo)
                                if (carryingArtifact) {
                                    damage *= 0.5; // Heavy combat penalty for carrying valuable items
                                }
                                if (enemyCarryingArtifact) {
                                    enemyDamage *= 0.5; // Enemy carriers are also vulnerable
                                }

                                // RIVER TERRAIN BONUSES
                                const myTerrain = getTerrainType(this.x, this.y);
                                const enemyTerrain = getTerrainType(other.x, other.y);

                                // Defender in river gets defensive bonus (harder to dislodge)
                                if (enemyTerrain === TERRAIN_TYPES.RIVER) {
                                    damage *= 0.7; // 30% damage reduction when attacking across river
                                }
                                if (myTerrain === TERRAIN_TYPES.RIVER) {
                                    enemyDamage *= 0.7; // 30% damage reduction when attacking across river
                                }

                                // Attacker crossing river takes penalty (wet, cold, exposed)
                                if (myTerrain === TERRAIN_TYPES.RIVER && enemyTerrain !== TERRAIN_TYPES.RIVER) {
                                    damage *= 0.8; // 20% damage penalty when crossing river to attack
                                }
                                if (enemyTerrain === TERRAIN_TYPES.RIVER && myTerrain !== TERRAIN_TYPES.RIVER) {
                                    enemyDamage *= 0.8; // 20% damage penalty when crossing river to attack
                                }

                                // Defense bonus reduces incoming damage
                                const enemyDefenseBonus = enemyIsSuperweapon ? 0 : (other.defenseBonus || 0);
                                damage *= (1.0 - enemyDefenseBonus * 0.5); // Defense is half as effective as offense
                                enemyDamage *= (1.0 - this.defenseBonus * 0.5);

                                // Gain veterancy faster in combat
                                this.veterancy = Math.min(100, this.veterancy + dt * 2.0);
                                if (!enemyIsSuperweapon) {
                                    other.veterancy = Math.min(100, other.veterancy + dt * 2.0);
                                }

                                // Cut-off units take much more damage and deal less
                                if (isCutOff) {
                                    damage *= 0.4;
                                    enemyDamage *= 2.5;
                                }

                                // Check if enemy is cut off
                                const enemyGx = Math.floor(other.x / gridSize);
                                const enemyGy = Math.floor(other.y / gridSize);
                                let enemyInFriendlyTerritory = false;

                                if (enemyGy >= 0 && enemyGy < influenceGrid.length && 
                                    enemyGx >= 0 && enemyGx < influenceGrid[0].length) {
                                    const enemyCell = influenceGrid[enemyGy][enemyGx];
                                    enemyInFriendlyTerritory = enemyCell.nation === other.nation && enemyCell.strength > 0.3;
                                }

                                const enemyHasFriendlySupport = allUnits.some(u => 
                                    u.nation === other.nation && u !== other &&
                                    Math.hypot(u.x - other.x, u.y - other.y) < detectionRadius
                                );
                                const enemyIsCutOff = !enemyInFriendlyTerritory && !enemyHasFriendlySupport;

                                if (enemyIsCutOff) {
                                    damage *= 2.5;
                                    enemyDamage *= 0.4;
                                }

                                // Outnumbered modifier - stronger penalty for being outnumbered
                                const mySupport = nearbyAllies.length;
                                // Use spatial grid instead of filtering all units
                                const enemyNeighbors = getNearbyUnits(other.x, other.y, detectionRadius, true);
                                let enemySupport = 0;
                                for (let u of enemyNeighbors) {
                                    if (u.nation === other.nation && u !== other) {
                                        const dist = Math.hypot(u.x - other.x, u.y - other.y);
                                        if (dist < detectionRadius) {
                                            enemySupport++;
                                        }
                                    }
                                }

                                const supportRatio = (mySupport + 1) / (enemySupport + 1);
                                // More pronounced advantage for outnumbering: 0.6x when outnumbered 2:1, 1.4x when outnumbering 2:1
                                damage *= (0.6 + supportRatio * 0.4);

                                // Morale penalty when outnumbered
                                if (supportRatio < 0.8) {
                                    this.morale = Math.max(0.1, this.morale - dt * 0.3);
                                }

                                // Apply damage
                                if (enemyIsSuperweapon && typeof other.takeDamage === 'function') {
                                    // Units do much less damage to superweapons (10% effectiveness)
                                    other.takeDamage(damage * 0.1);
                                } else {
                                    other.health -= damage;
                                }
                                this.health -= enemyDamage;

                                // Play combat hit sound (5% chance to avoid spam)
                                if (Math.random() < 0.05) {
                                    const avgIntensity = (damage + enemyDamage) / 200;
                                    Audio.playHit(this.x, this.y, Math.min(1.5, avgIntensity));
                                }

                                // Morale impact
                                if (damage > enemyDamage) {
                                    this.morale = Math.min(1.0, this.morale + dt * 0.05);
                                    if (!enemyIsSuperweapon && other.morale !== undefined) {
                                        other.morale = Math.max(0, other.morale - dt * 0.1);
                                    }
                                } else {
                                    this.morale = Math.max(0, this.morale - dt * 0.1);
                                    if (!enemyIsSuperweapon && other.morale !== undefined) {
                                        other.morale = Math.min(1.0, other.morale + dt * 0.05);
                                    }
                                }
                            }
                        } else {
                            // Not stable enough to fight - avoid enemy instead
                            const avoidForce = (engagementRange - dist) / engagementRange * 2.0;
                            collisionForceX += (dx / dist) * avoidForce * 20.0;
                            collisionForceY += (dy / dist) * avoidForce * 20.0;
                        }
                    }
                }
                
                // Set battle cooldown if we fought
                if (this.engagedEnemies.length > 0 && this.battleCooldown <= 0) {
                    this.battleCooldown = 0.1;
                }
                
                // If lock timer expired and no enemies in collision range, unlock
                if (this.lockTimer <= 0 && this.engagedEnemies.length === 0) {
                    this.isLocked = false;
                }
                
                // NOW apply collision forces based on lock status
                if (this.isLocked) {
                    // Locked units: can't move strategically, but MUST respond to collision
                    this.vx = collisionForceX; // Full collision response to maintain spacing
                    this.vy = collisionForceY;
                } else {
                    // Free units: apply collision
                    this.vx += collisionForceX;
                    this.vy += collisionForceY;
                }
                
                // Only apply strategic movement if not locked in melee AND not engaged
                if (!this.isLocked && !this.inBattle) {
                    // RETREAT WHEN OUTNUMBERED OR NEAR DEATH - survival instinct
                    // DISABLED when capturing a node - must commit to the capture
                    let retreatForceX = 0;
                    let retreatForceY = 0;
                    const closeEnemies = nearbyEnemies.filter(e => e.dist < 50).length;
                    const closeAllies = nearbyAllies.filter(a => a.dist < 50).length;
                    
                    // Check if we're trying to capture a node (will be set in objective force section)
                    let preCaptureCheck = false;
                    if (this.targetNode) {
                        const dist = Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y);
                        const isUncaptured = this.targetNode.owner !== this.nation;
                        if (isUncaptured && dist < 100) {
                            preCaptureCheck = true;
                        }
                    }
                    
                    // FLANKING THREAT RESPONSE - if enemies approaching from behind, turn to face or retreat
                    if (flankingThreats.length > 0 && !preCaptureCheck) {
                        const nearestThreat = flankingThreats.reduce((closest, t) => 
                            t.dist < closest.dist ? t : closest
                        );
                        
                        // If threat is close (<80 units), react defensively
                        if (nearestThreat.dist < 80) {
                            // Count how many allies are nearby to help defend
                            const defensiveSupport = nearbyAllies.filter(a => a.dist < 60).length;
                            
                            if (defensiveSupport >= 2) {
                                // Have support - turn to face the threat
                                const dx = nearestThreat.unit.x - this.x;
                                const dy = nearestThreat.unit.y - this.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                retreatForceX -= (dx / dist) * 1.5; // Move toward threat to intercept
                                retreatForceY -= (dy / dist) * 1.5;
                            } else {
                                // Alone - retreat to nearest friendly position
                                const myNation = nations[this.nation];
                                const retreatTarget = this.nearestFriendlyNode || myNation.capital;
                                if (retreatTarget) {
                                    const dx = retreatTarget.x - this.x;
                                    const dy = retreatTarget.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist > 0) {
                                        retreatForceX += (dx / dist) * 2.0;
                                        retreatForceY += (dy / dist) * 2.0;
                                    }
                                }
                            }
                        }
                    }
                    
                    // CRITICAL HEALTH RETREAT - survival takes priority
                    const criticalHealth = this.health < 25; // Below 25% HP
                    const lowHealth = this.health < 40; // Below 40% HP
                    
                    if ((closeEnemies > closeAllies + 2 || criticalHealth) && !preCaptureCheck) {
                        // Significantly outnumbered OR critically wounded - retreat to safety
                        const myNation = nations[this.nation];
                        const retreatTarget = this.nearestFriendlyNode || myNation.capital;
                        if (retreatTarget) {
                            const dx = retreatTarget.x - this.x;
                            const dy = retreatTarget.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                // Critical health = desperate flee (3x force), low health = cautious retreat (2.5x)
                                const retreatIntensity = criticalHealth ? 3.0 : (lowHealth ? 2.5 : 2.0);
                                retreatForceX += (dx / dist) * retreatIntensity;
                                retreatForceY += (dy / dist) * retreatIntensity;
                            }
                        }
                    }
                    
                    this.vx += retreatForceX;
                    this.vy += retreatForceY;
                    
                    // PRIMARY OBJECTIVE FORCE - move toward assigned target (node or position)
                    // Units get TUNNEL VISION for uncaptured nodes - extremely strong pull
                    // STAMINA CONSIDERATION - tired units reduce urgency for distant targets
                    let objectiveForceX = 0;
                    let objectiveForceY = 0;
                    let atCaptureNode = false; // Track if we're at ANY node to suppress orbiting
                    
                    // Validate target node still exists
                    if (this.targetNode && !nodes.includes(this.targetNode)) {
                        this.targetNode = null; // Clear phantom node reference
                    }
                    
                    // Use waypoint for navigation if set, otherwise go direct to target
                    const navigationTarget = this.waypointNode || this.targetNode;
                    
                    if (navigationTarget) {
                        const dx = navigationTarget.x - this.x;
                        const dy = navigationTarget.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Clear waypoint if we've reached it
                        if (this.waypointNode && dist < 50) {
                            this.waypointNode = null;
                        }
                        
                        // Tired units are reluctant to travel far, BUT nearby nodes are always worth it!
                        // Only apply fatigue penalty to distant targets (>150 units away)
                        let fatigueModifier = 1.0;
                        if (dist > 150 && this.stamina < 50) {
                            const staminaFactor = 0.5 + this.stamina / 50 * 0.5; // 50%-100% urgency
                            const distancePenalty = 200 / dist; // Reduce urgency for far targets when tired
                            fatigueModifier = staminaFactor * distancePenalty;
                        }
                        // Nearby nodes (<150 units) - ALWAYS go for them, even when tired!
                        // This ensures units still capture objectives within reach
                        
                        // Suppress orbiting when near ANY node (friendly or enemy)
                        if (dist < 60) {
                            atCaptureNode = true;
                        }
                        
                        // Check if target node is uncaptured (neutral or enemy)
                        const isUncaptured = this.targetNode.owner !== this.nation;
                        
                        // Artifact carriers have EXTREME urgency to reach storage
                        // (using carryingArtifact from outer scope)
                        // CRITICAL: Artifact carriers NEVER enter "capture mode" - they just deliver and move on
                        if (carryingArtifact && (this.role === 'secureArtifact' || this.role === 'guardKey' || this.role === 'archiveStudiedPlan' || this.role === 'redistributeArtifact')) {
                            // MAXIMUM URGENCY - sprint directly to storage node!
                            // No capture behavior, no orbiting - just get there fast and auto-deposit
                            const urgency = 18.0; // Very strong pull
                            objectiveForceX = (dx / dist) * urgency;
                            objectiveForceY = (dy / dist) * urgency;
                        } else if (isUncaptured && dist < 100) {
                            atCaptureNode = true; // Flag to suppress spreading/orbiting
                            
                            // ABSOLUTE TUNNEL VISION - when capturing, ONLY move toward node center
                            if (dist > 45) {
                                // Far away - strong pull inward (only reduced by fatigue if very far)
                                const urgency = 12.0 * fatigueModifier;
                                objectiveForceX = (dx / dist) * urgency;
                                objectiveForceY = (dy / dist) * urgency;
                            } else {
                                // Within capture range - strong damping but allow movement to center
                                this.vx *= 0.2; // Heavy damping to prevent orbits
                                this.vy *= 0.2;
                                
                                // Strong centering force to pull to exact center
                                const urgency = 5.0;
                                objectiveForceX = (dx / dist) * urgency;
                                objectiveForceY = (dy / dist) * urgency;
                            }
                        } else {
                            // FRIENDLY NODE - already captured, DON'T orbit!
                            // If we're close to a friendly node, clear target and move on
                            if (dist < 60) {
                                // Mission accomplished - clear target so we get reassigned
                                this.targetNode = null;
                                this.waypointNode = null;
                                this.role = null; // Will get new orders next AI tick
                                
                                // Just coast to a stop
                                this.vx *= 0.8;
                                this.vy *= 0.8;
                            } else if (dist > 80) {
                                // Still en route to friendly node - gentle pull
                                const urgency = 4.0 * fatigueModifier;
                                objectiveForceX = (dx / dist) * urgency;
                                objectiveForceY = (dy / dist) * urgency;
                            } else {
                                // Approaching friendly node - slow down
                                this.vx *= 0.75;
                                this.vy *= 0.75;
                            }
                        }
                    } else if (this.role === 'captureFacility' && this.targetPos) {
                        // Capturing facility to unlock with key we already own - HIGH PRIORITY!
                        const dx = this.targetPos.x - this.x;
                        const dy = this.targetPos.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 1.0) {
                            // Very strong pull - need to capture this facility to unlock it
                            const urgency = 18.0;
                            objectiveForceX = (dx / dist) * urgency;
                            objectiveForceY = (dy / dist) * urgency;
                        }
                    } else if (this.role === 'infiltrate' && this.targetNode) {
                        // INFILTRATION - sneak to enemy node and attempt to steal artifact
                        const dx = this.targetNode.x - this.x;
                        const dy = this.targetNode.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Move toward target node
                            const urgency = 12.0;
                            objectiveForceX = (dx / dist) * urgency;
                            objectiveForceY = (dy / dist) * urgency;
                        }
                        
                        // If close to node, attempt theft
                        if (dist < 80) {
                            if (!this.infiltrationTimer) this.infiltrationTimer = 0;
                            this.infiltrationTimer += dt;
                            
                            // Takes 5-10 seconds to steal artifact
                            const theftTime = 5 + Math.random() * 5;
                            if (this.infiltrationTimer >= theftTime) {
                                // Attempt theft!
                                const artifactsAtNode = artifacts.filter(a => a.storedAtNode === this.targetNode && a.movable);
                                if (artifactsAtNode.length > 0) {
                                    const stolenArtifact = artifactsAtNode[Math.floor(Math.random() * artifactsAtNode.length)];
                                    // Remove from storage
                                    const idx = stolenArtifact.storedAtNode.inventory.indexOf(stolenArtifact.type);
                                    if (idx >= 0) stolenArtifact.storedAtNode.inventory.splice(idx, 1);
                                    stolenArtifact.storedAtNode = null;
                                    stolenArtifact.carrier = this;
                                    stolenArtifact.capturedBy = this.nation;
                                    stolenArtifact.captureProgress = 100;
                                    stolenArtifact.hasAnnounced = false;
                                    this.role = null;
                                    this.infiltrationTimer = 0;
                                    const nation = nations[this.nation];
                                    const enemyNation = nations[this.targetNode.owner];
                                    const nodeName = this.targetNode.crypticName || 'node';
                                    if (nation && enemyNation) {
                                        const theftVerb = stolenArtifact.name.includes('Data') || stolenArtifact.name.includes('Plans') ? 'have been' : 'has been';
                                        Audio.announce(`${nation.name} infiltrates ${nodeName} - ${stolenArtifact.name} ${theftVerb} stolen!`, 'high', this.nation);
                                        logGameEvent('theft', `${nation.name} stole ${stolenArtifact.name} from ${enemyNation.name} ${nodeName}`, 'high');
                                    }
                                } else {
                                    // No artifacts left, abort
                                    this.role = null;
                                    this.infiltrationTimer = 0;
                                }
                            }
                        } else {
                            this.infiltrationTimer = 0; // Reset if not at node
                        }
                        
                        // If node was captured or no longer has artifacts, abort
                        if (this.targetNode.owner === this.nation || this.targetNode.owner < 0) {
                            this.role = null;
                            this.targetNode = null;
                            this.infiltrationTimer = 0;
                        }
                    } else if (this.role === 'captureArtifact' && this.targetArtifact) {
                        // Artifact capture - move toward artifact location like a high-value node
                        const dx = this.targetArtifact.x - this.x;
                        const dy = this.targetArtifact.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Strong pull toward artifact - high priority objective
                            const urgency = 15.0;
                            objectiveForceX = (dx / dist) * urgency;
                            objectiveForceY = (dy / dist) * urgency;
                        }
                        
                        // If artifact was captured by someone else, clear target
                        if (this.targetArtifact.capturedBy >= 0) {
                            this.targetArtifact = null;
                            this.role = null;
                        }
                    } else if (this.targetPos) {
                        // Territorial units move toward unclaimed territory positions
                        const dx = this.targetPos.x - this.x;
                        const dy = this.targetPos.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Gentler pull toward territory - secondary objective
                            const urgency = 6.0;
                            objectiveForceX = (dx / dist) * urgency;
                            objectiveForceY = (dy / dist) * urgency;
                        }
                        
                        // Spread out when reaching territory (to claim more land)
                        if (dist < 20) {
                            // Check what nation currently controls this territory
                            const gx = Math.floor(this.targetPos.x / gridSize);
                            const gy = Math.floor(this.targetPos.y / gridSize);
                            
                            if (gy >= 0 && gy < influenceGrid.length && 
                                gx >= 0 && gx < influenceGrid[0].length) {
                                const cell = influenceGrid[gy][gx];
                                
                                // If we've captured it, spread to adjacent unclaimed areas
                                if (cell.nation === this.nation) {
                                    // Pick a new territory target nearby
                                    this.targetPos = this.findNearestUnpaintedArea(influenceGrid, gridSize);
                                    if (!this.targetPos) {
                                        // No unclaimed land nearby - reassign to defend or expand nodes
                                        this.role = null;
                                        this.targetNode = null;
                                        this.targetPos = null;
                                    }
                                }
                            }
                        }
                    }
                    
                    this.vx += objectiveForceX;
                    this.vy += objectiveForceY;
                    
                    // BORDER BIAS - units prefer moving toward contested frontlines/flanks
                    // Check if we're in friendly vs enemy territory to find the border
                    if (!atCaptureNode && influenceGrid && influenceGrid.length > 0) {
                        const gx = Math.floor(this.x / gridSize);
                        const gy = Math.floor(this.y / gridSize);
                        
                        if (gy >= 0 && gy < influenceGrid.length && gx >= 0 && gx < influenceGrid[0].length) {
                            // Sample in 8 directions to find contested/enemy territory
                            let borderDirectionX = 0;
                            let borderDirectionY = 0;
                            let borderSamples = 0;
                            const sampleDist = 3; // Check 3 cells out
                            
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                                const checkGx = gx + Math.round(Math.cos(angle) * sampleDist);
                                const checkGy = gy + Math.round(Math.sin(angle) * sampleDist);
                                
                                if (checkGy >= 0 && checkGy < influenceGrid.length && 
                                    checkGx >= 0 && checkGx < influenceGrid[0].length) {
                                    const cell = influenceGrid[checkGy][checkGx];
                                    
                                    // If cell is contested (low stability) or enemy-controlled, it's a border
                                    const isContested = cell.stability < 0.6;
                                    const isEnemy = cell.nation !== this.nation && cell.nation >= 0;
                                    const isUnclaimed = cell.nation < 0;
                                    
                                    if (isContested || isEnemy || isUnclaimed) {
                                        borderDirectionX += Math.cos(angle);
                                        borderDirectionY += Math.sin(angle);
                                        borderSamples++;
                                    }
                                }
                            }
                            
                            // Apply gentle bias toward borders/flanks
                            if (borderSamples > 0) {
                                const borderLen = Math.sqrt(borderDirectionX * borderDirectionX + borderDirectionY * borderDirectionY);
                                if (borderLen > 0) {
                                    const borderForce = 3.0; // Stronger bias toward contested zones
                                    this.vx += (borderDirectionX / borderLen) * borderForce;
                                    this.vy += (borderDirectionY / borderLen) * borderForce;
                                }
                            }
                        }
                    }
                    
                    // LAND PREFERENCE - units prefer standing on solid ground, not rivers
                    // ARTIFACT CARRIERS EXEMPT - they cross rivers freely to deliver
                    // Check current terrain and nearby options
                    const myTerrain = getTerrainType(this.x, this.y);
                    if (myTerrain === TERRAIN_TYPES.RIVER && !atCaptureNode && !carryingArtifact) {
                        // On river - look for nearby land to step onto
                        let landDirectionX = 0;
                        let landDirectionY = 0;
                        let landSamples = 0;
                        
                        // Sample 8 directions for land tiles
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                            const checkDist = 25; // Check nearby
                            const testX = this.x + Math.cos(angle) * checkDist;
                            const testY = this.y + Math.sin(angle) * checkDist;
                            const testTerrain = getTerrainType(testX, testY);
                            
                            // Prefer passable or rough terrain over rivers
                            if (testTerrain === TERRAIN_TYPES.PASSABLE || testTerrain === TERRAIN_TYPES.ROUGH) {
                                landDirectionX += Math.cos(angle);
                                landDirectionY += Math.sin(angle);
                                landSamples++;
                            }
                        }
                        
                        // Apply gentle bias toward land
                        if (landSamples > 0) {
                            const landLen = Math.sqrt(landDirectionX * landDirectionX + landDirectionY * landDirectionY);
                            if (landLen > 0) {
                                const landForce = 1.5; // Gentle preference for land
                                this.vx += (landDirectionX / landLen) * landForce;
                                this.vy += (landDirectionY / landLen) * landForce;
                            }
                        }
                    }
                    
                    // Check if we're trying to move through enemy lines (backwards engagement prevention)
                    let hasEnemiesBehind = false;
                    if (nearbyEnemies.length > 0 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
                        const moveAngle = Math.atan2(this.vy, this.vx);
                        
                        for (let enemy of nearbyEnemies) {
                            if (enemy.dist < 30) {
                                const enemyAngle = Math.atan2(enemy.dy, enemy.dx);
                                let angleDiff = Math.abs(enemyAngle - moveAngle);
                                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                                
                                // If moving toward enemy (< 90 degrees), it's ahead
                                // If moving away (> 90 degrees), enemy is behind
                                if (angleDiff > Math.PI / 2) {
                                    // Enemy is behind us - don't move toward them!
                                    hasEnemiesBehind = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Stop moving if we have enemies behind us (we've crossed the line)
                    if (hasEnemiesBehind) {
                        this.vx *= 0.3; // Drastically slow down
                        this.vy *= 0.3;
                    }
                    // Receive new orders periodically (less frequent now that connectivity is separate)
                    this.orderTimer += dt;
                    if (this.orderTimer > 2.5) {
                        this.receiveOrders(nodes, allUnits, nations[this.nation], nearbyEnemies);
                        this.orderTimer = 0;
                    }
                    
                    // REAL-TIME STUCK DETECTION - Force reassignment if stuck at uncapturable/overcrowded node
                    // This prevents the "syphon" effect where units pile into nodes without capturing
                    if (this.targetNode && this.targetNode.owner !== this.nation) {
                        const distToTarget = Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y);
                        
                        // If we're close to target node (within capture range) but not capturing it
                        if (distToTarget < 60) {
                            // CRITICAL CHECK: Is another nation already capturing this node?
                            // If node.capturingNation is set and it's not us, we can NEVER make progress!
                            const alreadyBeingCaptured = this.targetNode.capturingNation >= 0 && 
                                                        this.targetNode.capturingNation !== this.nation;
                            
                            // Count units at this node for overcrowding check
                            let unitsAtNode = 0;
                            for (const unit of allUnits) {
                                const d = Math.hypot(unit.x - this.targetNode.x, unit.y - this.targetNode.y);
                                if (d < 60 && unit.nation === this.nation) {
                                    unitsAtNode++;
                                }
                            }
                            
                            // IMMEDIATE REASSIGNMENT: Node locked by another nation OR 4+ units already here
                            // Don't wait - leave NOW to prevent syphon
                            if (alreadyBeingCaptured || unitsAtNode >= 4) {
                                this.targetNode = null;
                                this.targetPos = null;
                                this.stuckAtNodeTimer = 0;
                                this.orderTimer = 2.6; // Trigger immediate re-order
                                
                                // Strong push away from locked/overcrowded node
                                const awayAngle = Math.random() * Math.PI * 2;
                                this.vx += Math.cos(awayAngle) * 4.0;
                                this.vy += Math.sin(awayAngle) * 4.0;
                            } else {
                                // Track how long we've been near without progress
                                if (!this.stuckAtNodeTimer) this.stuckAtNodeTimer = 0;
                                this.stuckAtNodeTimer += dt;
                                
                                // After 2 seconds stuck near a node, check if we should move on
                                // Reduced from 3s to prevent syphon clustering
                                if (this.stuckAtNodeTimer > 2.0) {
                                    const targetOwner = this.targetNode.owner;
                                    let shouldReassign = false;
                                    
                                    // CASE 1: Enemy or ally nodes - check diplomatic relations
                                    if (targetOwner >= 0) {
                                        const myNation = nations[this.nation];
                                        
                                        // Check diplomatic relations
                                        const myStance = myNation.diplomaticRelations[targetOwner];
                                        const theirStance = nations[targetOwner]?.diplomaticRelations[this.nation];
                                        const areAllies = myStance === DIPLOMATIC_STANCE.ALLIED || 
                                                        theirStance === DIPLOMATIC_STANCE.ALLIED;
                                        
                                        if (areAllies) {
                                            shouldReassign = true;
                                        }
                                        
                                        // Check if heavily defended (only if not already reassigning)
                                        if (!shouldReassign) {
                                            let defenderCount = 0;
                                            let attackerCount = 0;
                                            for (const unit of allUnits) {
                                                const d = Math.hypot(unit.x - this.targetNode.x, unit.y - this.targetNode.y);
                                                if (d < 70) {
                                                    if (unit.nation === targetOwner) defenderCount++;
                                                    else if (unit.nation === this.nation) attackerCount++;
                                                }
                                            }
                                            
                                            const heavilyDefended = defenderCount >= attackerCount + 2;
                                            if (heavilyDefended) {
                                                shouldReassign = true;
                                            }
                                        }
                                    }
                                    // CASE 2: Neutral nodes - prevent overcrowding/syphon effect
                                    else {
                                        // If 2+ units stuck at neutral node for 2s, reassign extras
                                        // Lowered threshold to disperse faster
                                        if (unitsAtNode >= 2) {
                                            shouldReassign = true;
                                        }
                                    }
                                    
                                    if (shouldReassign) {
                                        // FORCE REASSIGNMENT - this node is uncapturable or overcrowded
                                        this.targetNode = null;
                                        this.targetPos = null;
                                        this.stuckAtNodeTimer = 0;
                                        this.orderTimer = 2.6; // Trigger immediate re-order
                                        
                                        // Move away from the stuck position with stronger force
                                        const awayAngle = Math.random() * Math.PI * 2;
                                        this.vx += Math.cos(awayAngle) * 3.5;
                                        this.vy += Math.sin(awayAngle) * 3.5;
                                    }
                                }
                            }
                        } else {
                            // Not stuck - reset timer
                            this.stuckAtNodeTimer = 0;
                        }
                    } else {
                        // No problematic target - reset timer
                        this.stuckAtNodeTimer = 0;
                    }
                    
                    // If cut off from capital/support - EMERGENCY retreat to reconnect!
                    let reconnectForceX = 0;
                    let reconnectForceY = 0;
                    if (!this.connectedToCapital) {
                        // Try to reconnect to nearest friendly node or capital
                        const reconnectTarget = this.nearestFriendlyNode || nations[this.nation].capital;
                        if (reconnectTarget) {
                            const dx = reconnectTarget.x - this.x;
                            const dy = reconnectTarget.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                reconnectForceX = (dx / dist) * 1.0; // Strong pull to reconnect
                                reconnectForceY = (dy / dist) * 1.0;
                            }
                        }
                    }
                    
                    this.vx += reconnectForceX;
                    this.vy += reconnectForceY;
                    
                    // OPPORTUNISTIC NODE CAPTURE - seek nearby undefended capturable nodes
                    // Units dynamically switch to closer opportunities instead of marching past them
                    // COMMITMENT - stick with target for minimum time to avoid twitching
                    // SKIP if carrying artifact - artifact delivery is absolute priority!
                    if (!carryingArtifact && !atCaptureNode && this.orderTimer > 1.0 && this.targetCommitmentTime > 0.8) {
                        let bestOpportunity = null;
                        let bestOpportunityDist = 100; // Only consider nodes within 100 units
                        
                        for (const node of nodes) {
                            // Check if we can capture this node (diplomatic stance check)
                            if (node.owner === this.nation) continue; // Skip friendly nodes
                            
                            // Check diplomatic stance allows capture
                            const myNation = nations[this.nation];
                            if (node.owner >= 0 && myNation && myNation.diplomaticRelations) {
                                const stance = myNation.diplomaticRelations[node.owner];
                                // Can only capture if undefined (hostile/unmet) or at WAR
                                if (stance !== undefined && stance !== DIPLOMATIC_STANCE.WAR) {
                                    continue; // Can't capture NEUTRAL, ALLIED, etc.
                                }
                            }
                            
                            const dx = node.x - this.x;
                            const dy = node.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Only consider nearby nodes
                            if (dist >= bestOpportunityDist) continue;
                            
                            // Count how many units are already targeting this node
                            let defendersCount = 0;
                            for (const unit of allUnits) {
                                if (unit.targetNode === node) {
                                    defendersCount++;
                                }
                            }
                            
                            // Skip if already crowded (5+ units heading there)
                            if (defendersCount >= 5) continue;
                            
                            // Found a better opportunity!
                            bestOpportunity = node;
                            bestOpportunityDist = dist;
                        }
                        
                        // Switch to opportunistic target if found AND significantly better
                        // Require 30% improvement to avoid constant switching
                        const currentTargetDist = this.targetNode ? 
                            Math.hypot(this.targetNode.x - this.x, this.targetNode.y - this.y) : Infinity;
                        
                        if (bestOpportunity && bestOpportunityDist < currentTargetDist * 0.7) {
                            this.targetNode = bestOpportunity;
                            this.targetX = bestOpportunity.x;
                            this.targetY = bestOpportunity.y;
                            this.targetCommitmentTime = 0; // Reset commitment timer
                        }
                    }
                    
                    // Track how long we've been committed to current target
                    this.targetCommitmentTime += dt;
                    
                    // FRONTLINE RUSH - if no capturable nodes nearby, bee line to active combat zones
                    // Mountains bottleneck movement, so units need to push through to reinforce
                    // COMMITMENT - only re-evaluate frontline every 2 seconds to avoid indecision
                    // SKIP if carrying artifact - no combat detours!
                    let frontlineRushX = 0;
                    let frontlineRushY = 0;
                    if (!carryingArtifact && !atCaptureNode && this.orderTimer > 2.0) { // Only check every 2+ seconds
                        // Check if there are any capturable nodes within reinforcement range
                        let nearbyCapturableNodes = 0;
                        const searchRadius = 180;
                        
                        for (const node of nodes) {
                            if (node.owner === this.nation) continue;
                            
                            const myNation = nations[this.nation];
                            if (node.owner >= 0 && myNation && myNation.diplomaticRelations) {
                                const stance = myNation.diplomaticRelations[node.owner];
                                if (stance !== undefined && stance !== DIPLOMATIC_STANCE.WAR) continue;
                            }
                            
                            const dx = node.x - this.x;
                            const dy = node.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < searchRadius) {
                                nearbyCapturableNodes++;
                            }
                        }
                        
                        // No local objectives - find the frontline and rush there!
                        if (nearbyCapturableNodes === 0) {
                            // Find nearest enemy or ally in combat
                            let nearestFrontline = null;
                            let nearestFrontlineDist = Infinity;
                            
                            for (const unit of allUnits) {
                                if (unit === this) continue;
                                
                                // Look for our allies in combat OR enemy units (the frontline)
                                const isFrontlineUnit = (unit.nation === this.nation && unit.inBattle) || 
                                                       (unit.nation !== this.nation);
                                
                                if (isFrontlineUnit) {
                                    const dx = unit.x - this.x;
                                    const dy = unit.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < nearestFrontlineDist) {
                                        nearestFrontlineDist = dist;
                                        nearestFrontline = unit;
                                    }
                                }
                            }
                            
                            // Rush toward the frontline with strong force
                            if (nearestFrontline && nearestFrontlineDist > 60) {
                                const dx = nearestFrontline.x - this.x;
                                const dy = nearestFrontline.y - this.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist > 0) {
                                    const rushForce = 12.0; // Increased from 8.0 - very strong pull to frontline
                                    frontlineRushX = (dx / dist) * rushForce;
                                    frontlineRushY = (dy / dist) * rushForce;
                                }
                            }
                        }
                    }
                    
                    this.vx += frontlineRushX;
                    this.vy += frontlineRushY;
                    
                    // ARTIFACT ATTRACTION - units gravitate toward nearby unclaimed artifacts
                    // This makes units actively seek artifacts instead of passively capturing them
                    let artifactAttractionX = 0;
                    let artifactAttractionY = 0;
                    if (!carryingArtifact && this.role !== 'captureArtifact') {
                        // Find nearest unclaimed artifact within 200 units
                        let nearestArtifact = null;
                        let nearestDist = 200; // Search radius
                        
                        for (const artifact of artifacts) {
                            if (artifact.capturedBy >= 0 || !artifact.movable || !artifact.hasSpawned) continue; // Skip captured, facilities, or unspawned
                            
                            const dist = Math.hypot(artifact.x - this.x, artifact.y - this.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestArtifact = artifact;
                            }
                        }
                        
                        if (nearestArtifact) {
                            // Pull toward nearby artifact - medium priority
                            const dx = nearestArtifact.x - this.x;
                            const dy = nearestArtifact.y - this.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist > 0) {
                                const pullStrength = 8.0; // Strong enough to compete with node attraction
                                artifactAttractionX = (dx / dist) * pullStrength;
                                artifactAttractionY = (dy / dist) * pullStrength;
                            }
                        }
                    }
                    
                    this.vx += artifactAttractionX;
                    this.vy += artifactAttractionY;
                    
                    // RIVER REPULSION - units avoid standing on rivers (slows movement)
                    // ARTIFACT CARRIERS EXEMPT - they cross rivers freely to complete delivery mission
                    let riverRepulsionX = 0;
                    let riverRepulsionY = 0;
                    const currentTerrain = getTerrainType(this.x, this.y);
                    
                    if (currentTerrain === TERRAIN_TYPES.RIVER && !carryingArtifact) {
                        // We're ON a river - find nearest non-river terrain to escape to
                        const searchRadius = 60;
                        let bestEscapeX = 0;
                        let bestEscapeY = 0;
                        let foundEscape = false;
                        
                        // Sample in 8 directions to find escape route
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                            const checkDist = 30;
                            const checkX = this.x + Math.cos(angle) * checkDist;
                            const checkY = this.y + Math.sin(angle) * checkDist;
                            const checkTerrain = getTerrainType(checkX, checkY);
                            
                            // Head toward passable or rough terrain (not river, not mountain)
                            if (checkTerrain === TERRAIN_TYPES.PASSABLE || checkTerrain === TERRAIN_TYPES.ROUGH) {
                                bestEscapeX = Math.cos(angle);
                                bestEscapeY = Math.sin(angle);
                                foundEscape = true;
                                break; // Take first escape route found
                            }
                        }
                        
                        if (foundEscape) {
                            // Strong repulsion to get off river quickly
                            const repulsionStrength = 6.0;
                            riverRepulsionX = bestEscapeX * repulsionStrength;
                            riverRepulsionY = bestEscapeY * repulsionStrength;
                        }
                    }
                    
                    this.vx += riverRepulsionX;
                    this.vy += riverRepulsionY;
                    
                    // SUPPRESS ALL TACTICAL FORCES WHEN CAPTURING A NODE - prevents orbiting
                    // ALSO suppress when carrying artifact - carriers have ONE job: deliver to storage
                    if (!carryingArtifact && !atCaptureNode) {
                        
                        // REINFORCEMENT - assist allies in combat (optimized with spatial grid)
                        let reinforceForceX = 0;
                        let reinforceForceY = 0;
                        const reinforceRadius = 80;
                        
                        for (let ally of nearbyAllies) {
                            // Is this ally in combat?
                            if ((ally.unit.inBattle || ally.unit.isLocked) && ally.dist < reinforceRadius) {
                                // Use spatial grid to count nearby units instead of filtering all units
                                const allyNeighbors = getNearbyUnits(ally.unit.x, ally.unit.y, 40);
                                let enemiesNearAlly = 0;
                                let friendliesNearAlly = 0;
                                
                                for (let neighbor of allyNeighbors) {
                                    if (Math.hypot(neighbor.x - ally.unit.x, neighbor.y - ally.unit.y) < 40) {
                                        if (neighbor.nation !== this.nation) {
                                            enemiesNearAlly++;
                                        } else {
                                            friendliesNearAlly++;
                                        }
                                    }
                                }
                                
                                // Reinforce if ally is outnumbered
                                if (enemiesNearAlly > 0 && friendliesNearAlly <= enemiesNearAlly + 2) {
                                    const dx = ally.unit.x - this.x;
                                    const dy = ally.unit.y - this.y;
                                    const dist = ally.dist;
                                    
                                    if (dist > 0) {
                                        const urgency = enemiesNearAlly / Math.max(1, friendliesNearAlly);
                                        reinforceForceX += (dx / dist) * 2.0 * urgency; // Reduced from 3.5 for slower pace
                                        reinforceForceY += (dy / dist) * 2.0 * urgency;
                                    }
                                }
                            }
                        }
                        
                        this.vx += reinforceForceX;
                        this.vy += reinforceForceY;
                        
                        // FLANKING BEHAVIOR - go around enemy formations, not through them
                        let flankForceX = 0;
                        let flankForceY = 0;
                        
                        if (nearbyEnemies.length >= 2) { // Reduced from 3 to 2 - activate sooner
                            // Detect enemy formation - find center and edges
                            let avgEnemyX = 0, avgEnemyY = 0;
                            for (let e of nearbyEnemies) {
                                avgEnemyX += e.unit.x;
                                avgEnemyY += e.unit.y;
                            }
                            avgEnemyX /= nearbyEnemies.length;
                            avgEnemyY /= nearbyEnemies.length;
                        // Vector from enemy center to me
                        const fromCenterX = this.x - avgEnemyX;
                        const fromCenterY = this.y - avgEnemyY;
                            const fromCenterDist = Math.sqrt(fromCenterX * fromCenterX + fromCenterY * fromCenterY);
                            
                            if (fromCenterDist > 0 && fromCenterDist < 90) { // Increased from 60 to 90 - longer range
                                // I'm near enemy formation - find a flank
                                // Perpendicular to the line toward me = flank direction
                                const perpX = -fromCenterY / fromCenterDist;
                                const perpY = fromCenterX / fromCenterDist;
                                
                                // Check both flank directions, pick less crowded one
                                let leftFlankCrowding = 0;
                                let rightFlankCrowding = 0;
                            
                            for (let e of nearbyEnemies) {
                                const leftDot = (e.unit.x - this.x) * perpX + (e.unit.y - this.y) * perpY;
                                const rightDot = (e.unit.x - this.x) * (-perpX) + (e.unit.y - this.y) * (-perpY);
                                if (leftDot > 0) leftFlankCrowding++;
                                if (rightDot > 0) rightFlankCrowding++;
                                }
                                
                                // Move toward less crowded flank - INCREASED PRIORITY
                                if (leftFlankCrowding < rightFlankCrowding) {
                                    flankForceX = perpX * 3.5; // Increased from 1.5 to 3.5
                                    flankForceY = perpY * 3.5;
                                } else {
                                    flankForceX = -perpX * 3.5; // Increased from 1.5 to 3.5
                                    flankForceY = -perpY * 3.5;
                                }
                            }
                            }
                        
                        this.vx += flankForceX;
                        this.vy += flankForceY;
                        
                        // PRESSURE CENTER REPULSION - DISABLED for performance
                        // (was filtering all units per owned node - extremely expensive)
                        
                        // EXPANSION PRESSURE - DISABLED for performance
                        // (objective force already handles movement toward targets)
                        
                        // TERRITORIAL BOUNDARY FORCE - strong elastic pull back to friendly territory
                        let boundaryForceX = 0;
                        let boundaryForceY = 0;
                    
                    // Check if we're in enemy or neutral territory
                    if (gx >= 0 && gx < influenceGrid[0].length && gy >= 0 && gy < influenceGrid.length) {
                            const cell = influenceGrid[gy][gx];
                            const inEnemyTerritory = cell.nation >= 0 && cell.nation !== this.nation;
                            const inNeutralTerritory = cell.nation === -1;
                            
                            if (inEnemyTerritory || inNeutralTerritory) {
                                // Find nearest friendly territory
                                let nearestFriendlyCell = null;
                                let nearestDist = Infinity;
                                
                                const searchRadius = 15;
                                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                    const checkY = gy + dy;
                                    const checkX = gx + dx;
                                    
                                    if (checkY >= 0 && checkY < influenceGrid.length &&
                                        checkX >= 0 && checkX < influenceGrid[0].length) {
                                        const checkCell = influenceGrid[checkY][checkX];
                                        if (checkCell.nation === this.nation && checkCell.strength > 0.3) {
                                            const dist = Math.sqrt(dx * dx + dy * dy);
                                            if (dist < nearestDist) {
                                                nearestDist = dist;
                                                nearestFriendlyCell = { x: checkX * gridSize + gridSize/2, y: checkY * gridSize + gridSize/2 };
                                            }
                                        }
                                        }
                                    }
                                }
                                
                                // Pull back to friendly territory
                                if (nearestFriendlyCell) {
                                    const dx = nearestFriendlyCell.x - this.x;
                                    const dy = nearestFriendlyCell.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist > 0) {
                                        // Stronger force the deeper we are in enemy territory
                                        const pullStrength = inEnemyTerritory ? 1.5 : 0.8;
                                        boundaryForceX = (dx / dist) * pullStrength;
                                        boundaryForceY = (dy / dist) * pullStrength;
                                    }
                                }
                            }
                            }
                        
                        this.vx += boundaryForceX;
                        this.vy += boundaryForceY;
                        
                        // PERIPHERY PRESSURE - units seek edges but PRIORITIZE NODE OBJECTIVES
                        // Nodes are critical: production, defense, territory, contiguity
                        let peripheryForceX = 0;
                        let peripheryForceY = 0;
                    
                    // If we have a node target, pull toward it BUT heavily penalized if far from home
                    if (this.targetNode) {
                            const dx = this.targetNode.x - this.x;
                            const dy = this.targetNode.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > 50) {
                                // Check distance from friendly territory
                                const myNation = nations[this.nation];
                                const friendlyNodes = nodes.filter(n => n.owner === this.nation);
                                let distFromFriendlyTerritory = Infinity;
                                
                                if (friendlyNodes.length > 0) {
                                    const nearest = this.findClosest(friendlyNodes);
                                    distFromFriendlyTerritory = Math.hypot(this.x - nearest.x, this.y - nearest.y);
                                } else if (myNation.capital) {
                                    distFromFriendlyTerritory = Math.hypot(this.x - myNation.capital.x, this.y - myNation.capital.y);
                                    }
                                
                                // Elastic band effect - massive penalty for being far from home
                                // POWER PROJECTION DIFFICULTY - very hard to control distant nodes
                                let territoryPenalty = 1.0;
                                if (distFromFriendlyTerritory > 200) {
                                    territoryPenalty = 0.05; // 95% reduction - nearly impossible
                                } else if (distFromFriendlyTerritory > 150) {
                                    territoryPenalty = 0.1; // 90% reduction - very difficult
                                } else if (distFromFriendlyTerritory > 100) {
                                    territoryPenalty = 0.2; // 80% reduction - difficult
                                } else if (distFromFriendlyTerritory > 60) {
                                    territoryPenalty = 0.4; // 60% reduction - moderate penalty
                                    }
                                
                                // Weak pull toward objectives, strong penalty for distance
                                // Natural noise-based value distribution - creates organic strategic hotspots
                                const noiseBias = getPositionValueNoise(this.targetNode.x, this.targetNode.y);
                                
                                const nodeValue = (this.targetNode.isCapital ? 1.2 : 0.8) * noiseBias;
                                peripheryForceX = (dx / dist) * 0.6 * nodeValue * territoryPenalty; // Reduced from 1.5
                                peripheryForceY = (dy / dist) * 0.6 * nodeValue * territoryPenalty;
                            }
                            } else {
                            // No node target - seek periphery/enemies
                            const hasEnemiesNearby = nearbyEnemies.length > 0;
                            
                            if (!hasEnemiesNearby) {
                                // Not at edge - find it
                                let nearestBorderDist = Infinity;
                                let borderDirectionX = 0;
                                let borderDirectionY = 0;
                            
                            // Sample directions to find enemy territory
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                const sampleDist = 150;
                                
                                for (let unit of allUnits) {
                                    if (unit.nation !== this.nation) {
                                        const toUnit = Math.atan2(unit.y - this.y, unit.x - this.x);
                                        let angleDiff = Math.abs(toUnit - angle);
                                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                                        
                                        if (angleDiff < Math.PI / 6) {
                                            const dist = Math.hypot(unit.x - this.x, unit.y - this.y);
                                            if (dist < nearestBorderDist) {
                                                nearestBorderDist = dist;
                                                borderDirectionX = Math.cos(angle);
                                                borderDirectionY = Math.sin(angle);
                                            }
                                        }
                                    }
                                    }
                                }
                                
                                // Push toward border (reduced from 3.5 to allow node seeking)
                                if (nearestBorderDist < Infinity) {
                                    const distancePenalty = Math.min(nearestBorderDist / 100, 1.5);
                                    peripheryForceX = borderDirectionX * 1.2 * distancePenalty;
                                    peripheryForceY = borderDirectionY * 1.2 * distancePenalty;
                                    } else {
                                    // No enemies - spread to least crowded direction
                                    let bestAngle = Math.random() * Math.PI * 2;
                                    let minCrowd = Infinity;
                                    
                                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                        let crowdCount = 0;
                                    for (let ally of nearbyAllies) {
                                        const allyAngle = Math.atan2(ally.unit.y - this.y, ally.unit.x - this.x);
                                        let diff = Math.abs(allyAngle - angle);
                                        if (diff > Math.PI) diff = 2 * Math.PI - diff;
                                        if (diff < Math.PI / 4) crowdCount++;
                                    }
                                    if (crowdCount < minCrowd) {
                                        minCrowd = crowdCount;
                                        bestAngle = angle;
                                    }
                                    }
                                    
                                    peripheryForceX = Math.cos(bestAngle) * 0.8;
                                    peripheryForceY = Math.sin(bestAngle) * 0.8;
                                }
                                } else {
                                // At edge - form line facing enemies
                                let avgEnemyX = 0, avgEnemyY = 0;
                                for (let e of nearbyEnemies) {
                                    avgEnemyX += e.unit.x;
                                    avgEnemyY += e.unit.y;
                                }
                                avgEnemyX /= nearbyEnemies.length;
                                avgEnemyY /= nearbyEnemies.length;
                                
                                const toEnemyAngle = Math.atan2(avgEnemyY - this.y, avgEnemyX - this.x);
                                peripheryForceX = Math.cos(toEnemyAngle) * 0.3;
                                peripheryForceY = Math.sin(toEnemyAngle) * 0.3;
                            }
                            }
                        
                        this.vx += peripheryForceX;
                        this.vy += peripheryForceY;
                        
                        // TERRITORY CONTROL PRESSURE - gentle spreading (periphery force is primary)
                        let territoryForceX = 0;
                        let territoryForceY = 0;
                    
                    // Push away from concentrated friendly areas, but gently
                    const nearbyFriendlyDensity = nearbyAllies.length;
                    if (nearbyFriendlyDensity > 6) { // Higher threshold
                        // Too crowded - spread out toward empty space
                        let avgFriendlyX = 0, avgFriendlyY = 0;
                        for (let ally of nearbyAllies) {
                            avgFriendlyX += ally.unit.x;
                            avgFriendlyY += ally.unit.y;
                        }
                            avgFriendlyX /= nearbyAllies.length;
                            avgFriendlyY /= nearbyAllies.length;
                            
                            const awayX = this.x - avgFriendlyX;
                            const awayY = this.y - avgFriendlyY;
                            const awayDist = Math.sqrt(awayX * awayX + awayY * awayY);
                            
                            if (awayDist > 0) {
                                // Reduced to 0.4 - more deliberate, less gas-like
                                territoryForceX = (awayX / awayDist) * 0.4;
                                territoryForceY = (awayY / awayDist) * 0.4;
                            }
                            }
                        
                        this.vx += territoryForceX;
                        this.vy += territoryForceY;
                        
                        // MAXIMUM SPREADING - units need to breathe and cover territory
                        // ALWAYS spread when near allies, but stronger when active
                        // SUPPRESS only when capturing nodes to prevent orbits
                        let spreadingForceX = 0;
                        let spreadingForceY = 0;
                        
                        // Spread if NOT capturing (capturing uses collision for spacing instead)
                            if (!atCaptureNode) {
                            // Strong repulsion from nearby allies to maximize coverage
                            const spreadRadius = 70;
                            const closeAllies = nearbyAllies.filter(a => a.dist < spreadRadius);
                            if (closeAllies.length > 0) {
                                // Active force when enemies nearby or expanding
                                const hasForwardPressure = nearbyEnemies.length > 0 || (this.targetNode && this.targetNode.owner !== this.nation);
                                    const spreadStrength = hasForwardPressure ? 1.2 : 0.8; // Strong when active, gentle when garrisoning
                                
                                // Push away from ALL nearby allies
                                for (let ally of closeAllies) {
                                    const dx = this.x - ally.unit.x;
                                    const dy = this.y - ally.unit.y;
                                    const dist = ally.dist;
                                    if (dist > 0) {
                                        const force = (spreadRadius - dist) / spreadRadius;
                                        spreadingForceX += (dx / dist) * force * spreadStrength;
                                        spreadingForceY += (dy / dist) * force * spreadStrength;
                                    }
                                }
                            }
                            }
                        
                        this.vx += spreadingForceX;
                        this.vy += spreadingForceY;
                        
                        // CAPITAL REPULSION - capitals aggressively push units away toward battle
                        // This prevents units from clustering near spawn and forces them to expand
                        // DISABLED when unclaimed artifacts nearby - need units to stick around and capture them!
                        let capitalPushX = 0;
                        let capitalPushY = 0;
                        const myCapital = nations[this.nation].capital;
                        if (myCapital && !atCaptureNode) {
                            // Check for unclaimed artifacts near capital (within 150 units)
                            const artifactsNearCapital = artifacts.filter(a => 
                                a.capturedBy === -1 && 
                                a.movable &&
                                Math.hypot(a.x - myCapital.x, a.y - myCapital.y) < 150
                            );
                            
                            // Only push away if NO artifacts to capture near capital
                            if (artifactsNearCapital.length === 0) {
                                const toCapitalX = myCapital.x - this.x;
                                const toCapitalY = myCapital.y - this.y;
                                    const distToCapital = Math.hypot(toCapitalX, toCapitalY);
                                
                                // Strong push when close to capital, fades at distance
                                if (distToCapital < 300) {
                                    // Push AWAY from capital toward frontline
                                    const pushStrength = 4.0; // Very strong push
                                    const distFactor = (300 - distToCapital) / 300; // Stronger when closer
                                    capitalPushX = -(toCapitalX / distToCapital) * pushStrength * distFactor;
                                    capitalPushY = -(toCapitalY / distToCapital) * pushStrength * distFactor;
                                }
                            }
                        }
                        
                        this.vx += capitalPushX;
                        this.vy += capitalPushY;
                        
                        // AMPHIBIOUS MECHANICS - detect water using world map
                        const onWater = !isLand(this.x, this.y);
                        
                        // Auto embark/disembark
                        if (onWater && !this.onBoat) {
                            this.onBoat = true;
                            this.boatTimer = 0;
                        } else if (!onWater && this.onBoat) {
                            this.onBoat = false;
                        }
                        
                        // No terrain avoidance needed - world map handles it
                    
                    // REAR THREAT DETECTION - detect enemies behind our line
                    let rearGuardForceX = 0;
                    let rearGuardForceY = 0;
                    
                    // Check if there are enemies between us and our capital/nodes
                    const capital = nations[this.nation].capital;
                    if (capital && nearbyEnemies.length > 0) {
                        const toCapitalX = capital.x - this.x;
                        const toCapitalY = capital.y - this.y;
                        const capitalDist = Math.sqrt(toCapitalX * toCapitalX + toCapitalY * toCapitalY);
                        
                        // Check each nearby enemy to see if they're "behind" us (closer to capital)
                        for (let enemy of nearbyEnemies) {
                            const enemyToCapitalDist = Math.hypot(capital.x - enemy.unit.x, capital.y - enemy.unit.y);
                            
                            // If enemy is behind us (closer to capital), this is a breakthrough!
                            if (enemyToCapitalDist < capitalDist - 20) {
                                // Pull back toward capital to block the threat
                                const pullStrength = 1.5;
                                if (capitalDist > 0) {
                                    rearGuardForceX += (toCapitalX / capitalDist) * pullStrength;
                                    rearGuardForceY += (toCapitalY / capitalDist) * pullStrength;
                                }
                            }
                        }
                    }
                    
                    // Also check if nearby allies are being flanked - OPTIMIZED
                    // Use spatial grid instead of filtering all units
                    for (let ally of nearbyAllies) {
                        if (ally.dist < 40) {
                            const neighbors = getNearbyUnits(ally.unit.x, ally.unit.y, 30);
                            let alliesAroundThem = 0;
                            let enemiesAroundThem = 0;
                            
                            for (let u of neighbors) {
                                const dist = Math.hypot(u.x - ally.unit.x, u.y - ally.unit.y);
                                if (dist < 30) {
                                    if (u.nation === this.nation) {
                                        alliesAroundThem++;
                                    } else {
                                        enemiesAroundThem++;
                                    }
                                }
                            }
                            
                            // If ally is outnumbered, move to support
                            if (enemiesAroundThem > alliesAroundThem + 1) {
                                const toAllyX = ally.unit.x - this.x;
                                const toAllyY = ally.unit.y - this.y;
                                const allyDist = ally.dist;
                                if (allyDist > 0) {
                                    rearGuardForceX += (toAllyX / allyDist) * 0.8;
                                    rearGuardForceY += (toAllyY / allyDist) * 0.8;
                                }
                            }
                        }
                    }
                    
                    this.vx += rearGuardForceX;
                    this.vy += rearGuardForceY;
                    
                    // Detect if on frontline (near enemies) - use pre-calculated nearbyEnemies
                    // BUT NOT if we're near mountains - real frontlines are in open terrain
                    let enemiesNearby = 0;
                    for (let e of nearbyEnemies) {
                        if (e.dist < 80) {
                            enemiesNearby++;
                            if (enemiesNearby >= 1) break; // Early exit
                        }
                    }
                    
                    // Check if we're too close to mountains - if so, NOT a valid frontline position
                    const currentTerrain = getTerrainType(this.x, this.y);
                    let nearMountains = false;
                    if (currentTerrain === TERRAIN_TYPES.MOUNTAIN) {
                        nearMountains = true;
                    } else {
                        // Check surrounding area for mountains
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                            const checkX = this.x + Math.cos(angle) * 30;
                            const checkY = this.y + Math.sin(angle) * 30;
                            if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                                nearMountains = true;
                                break;
                            }
                        }
                    }
                    
                    // Only mark as frontline if enemies nearby AND not near mountains
                    this.onFrontline = enemiesNearby > 0 && !nearMountains;
                    
                    // Border solidification - units on frontline hold position
                    let borderHoldForceX = 0;
                    let borderHoldForceY = 0;
                    if (this.onFrontline && this.role === 'border' && nearbyAllies.length >= 2) {
                        // Form solid defensive line with nearby allies
                        const holdStrength = 0.4;
                        // Resist movement away from current position when on border
                        borderHoldForceX = -this.vx * holdStrength;
                        borderHoldForceY = -this.vy * holdStrength;
                    }
                    
                    this.vx += borderHoldForceX;
                    this.vy += borderHoldForceY;
                    
                    // Cohesion - units prefer to stick together (War of Dots style)
                    // SUPPRESS when capturing nodes to prevent orbiting
                    // SUPPRESS when near mountains - don't cluster at mountain edges
                    // SUPPRESS for artifact carriers - they have ONE job: deliver artifact
                    const isCarryingArtifactCohesion = artifacts.find(a => a.carrier === this);
                    let cohesionX = 0;
                    let cohesionY = 0;
                    let alignmentX = 0;
                    let alignmentY = 0;
                    
                    if (nearbyAllies.length > 0 && !atCaptureNode && !nearMountains && !isCarryingArtifactCohesion) {
                        const cohesionRadius = 80; // Increased from 50
                        const targetAllies = nearbyAllies.filter(a => a.dist < cohesionRadius);
                        
                        if (targetAllies.length > 0) {
                            // Move toward center of mass of nearby allies
                            let centerX = 0, centerY = 0;
                            let avgVx = 0, avgVy = 0;
                            for (let ally of targetAllies) {
                                centerX += ally.unit.x;
                                centerY += ally.unit.y;
                                avgVx += ally.unit.vx;
                                avgVy += ally.unit.vy;
                            }
                            centerX /= targetAllies.length;
                            centerY /= targetAllies.length;
                            avgVx /= targetAllies.length;
                            avgVy /= targetAllies.length;
                            
                            const toCenterX = centerX - this.x;
                            const toCenterY = centerY - this.y;
                            const centerDist = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                            
                            if (centerDist > 15) {
                                cohesionX = (toCenterX / centerDist) * 0.6; // Reduced from 1.2 to prevent clustering
                                cohesionY = (toCenterY / centerDist) * 0.6;
                            }
                            
                            // Alignment - match velocity of neighbors (flocking)
                            // INCREASED to create tighter formations and lines
                            alignmentX = (avgVx - this.vx) * 0.8; // Increased from 0.2 - strong alignment
                            alignmentY = (avgVy - this.vy) * 0.8;
                        }
                    }
                    
                    // Apply cohesion - weaker for offensive units to allow flanking maneuvers
                    let cohesionMultiplier = this.role === 'offensive' ? 0.5 : 1.0;
                    
                    this.vx += cohesionX * cohesionMultiplier;
                    this.vy += cohesionY * cohesionMultiplier;
                    this.vx += alignmentX;
                    this.vy += alignmentY;
                    
                    // CHOKEPOINT DETECTION - detect narrow passages between mountains
                    // Force units to spread laterally instead of bunching
                    let chokepointSpreadX = 0;
                    let chokepointSpreadY = 0;
                    
                    const currentSpeed = Math.hypot(this.vx, this.vy);
                    if (nearbyAllies.length >= 3 && currentSpeed > 0.1) {
                        // Check if surrounded by mountains on sides (indicating chokepoint/narrow passage)
                        const moveAngle = Math.atan2(this.vy, this.vx);
                        const leftAngle = moveAngle + Math.PI / 2;
                        const rightAngle = moveAngle - Math.PI / 2;
                        
                        // Check left and right for mountains
                        const checkDist = 30;
                        const leftX = this.x + Math.cos(leftAngle) * checkDist;
                        const leftY = this.y + Math.sin(leftAngle) * checkDist;
                        const rightX = this.x + Math.cos(rightAngle) * checkDist;
                        const rightY = this.y + Math.sin(rightAngle) * checkDist;
                        
                        const leftBlocked = getTerrainType(leftX, leftY) === TERRAIN_TYPES.MOUNTAIN;
                        const rightBlocked = getTerrainType(rightX, rightY) === TERRAIN_TYPES.MOUNTAIN;
                        
                        // If in a narrow passage with many allies, spread laterally
                        if (leftBlocked || rightBlocked) {
                            // Count how crowded we are
                            const crowdedAllies = nearbyAllies.filter(a => a.dist < 25).length;
                            
                            if (crowdedAllies >= 2) {
                                // Spread to the open side
                                if (leftBlocked && !rightBlocked) {
                                    // Spread right
                                    chokepointSpreadX += Math.cos(rightAngle) * 2.5;
                                    chokepointSpreadY += Math.sin(rightAngle) * 2.5;
                                } else if (rightBlocked && !leftBlocked) {
                                    // Spread left
                                    chokepointSpreadX += Math.cos(leftAngle) * 2.5;
                                    chokepointSpreadY += Math.sin(leftAngle) * 2.5;
                                } else if (leftBlocked && rightBlocked) {
                                    // Both sides blocked - spread away from nearest ally
                                    const nearest = nearbyAllies[0];
                                    const awayX = this.x - nearest.unit.x;
                                    const awayY = this.y - nearest.unit.y;
                                    const awayDist = Math.hypot(awayX, awayY);
                                    if (awayDist > 0) {
                                        chokepointSpreadX += (awayX / awayDist) * 1.5;
                                        chokepointSpreadY += (awayY / awayDist) * 1.5;
                                    }
                                }
                            }
                        }
                    }
                    
                    this.vx += chokepointSpreadX;
                    this.vy += chokepointSpreadY;
                    
                    // FRONTLINE FORMATION - units form lines by aligning laterally with neighbors
                    // Only activate when actually on the frontline (near enemies)
                    let lineFormationX = 0;
                    let lineFormationY = 0;
                    
                    if (nearbyAllies.length >= 2 && !atCaptureNode && this.onFrontline && nearbyEnemies.length > 0) {
                        // Find the average movement direction of nearby allies
                        let avgDirX = 0, avgDirY = 0;
                        let dirCount = 0;
                        for (let ally of nearbyAllies) {
                            if (ally.dist < 60) {
                                const speed = Math.hypot(ally.unit.vx, ally.unit.vy);
                                if (speed > 0.5) {
                                    avgDirX += ally.unit.vx / speed;
                                    avgDirY += ally.unit.vy / speed;
                                    dirCount++;
                                }
                            }
                        }
                        
                        if (dirCount > 0) {
                            avgDirX /= dirCount;
                            avgDirY /= dirCount;
                            const avgDirMag = Math.hypot(avgDirX, avgDirY);
                        
                        if (avgDirMag > 0.5) {
                            // Normalize average direction
                            avgDirX /= avgDirMag;
                            avgDirY /= avgDirMag;
                            
                            // Perpendicular to movement = line formation axis
                            const perpX = -avgDirY;
                            const perpY = avgDirX;
                            
                            // Find lateral displacement from nearest allies
                            let lateralOffset = 0;
                            let lateralCount = 0;
                            for (let ally of nearbyAllies) {
                                if (ally.dist < 50) {
                                const toAllyX = ally.unit.x - this.x;
                                const toAllyY = ally.unit.y - this.y;
                                // Project onto perpendicular axis
                                const lateral = toAllyX * perpX + toAllyY * perpY;
                                lateralOffset += lateral;
                                lateralCount++;
                            }
                            }
                            
                            if (lateralCount > 0) {
                                lateralOffset /= lateralCount;
                                // Spread out laterally to form line (avoid bunching)
                                if (Math.abs(lateralOffset) < 25) {
                                    lineFormationX = perpX * lateralOffset * 0.3;
                                    lineFormationY = perpY * lateralOffset * 0.3;
                                }
                            }
                        }
                        }
                    }
                    
                    this.vx += lineFormationX;
                    this.vy += lineFormationY;
                    
                    } // End of !atCaptureNode tactical forces suppression
                    
                } // End of non-locked/non-battle strategic movement block
                
                // TERRAIN RESISTANCE - foot soldiers, not fluid
                const baseDampening = 0.85;
                this.vx *= baseDampening;
                this.vy *= baseDampening;
                
                // Additional dampening for units in battle (but not locked - those are handled earlier)
                if (this.inBattle && !this.isLocked) {
                    this.vx *= 0.05;
                    this.vy *= 0.05;
                }
                
                // CUT OFF MOVEMENT PENALTY - isolated units move very slowly
                if (isCutOff) {
                    this.vx *= 0.3; // 70% speed reduction
                    this.vy *= 0.3;
                }
                
                // Speed limit - deliberate foot soldier movement
                let maxSpeed = this.morale < 0.3 ? 1.5 : 0.7; // Reduced from 2.0/1.0 for slower pacing
                
                // ARTIFACT CARRIER SPEED BOOST - units securing valuable items move much faster!
                // (using carryingArtifact from earlier in function)
                if (carryingArtifact) {
                    maxSpeed *= 2.0; // 2x speed boost (reduced from 3.5x for pacing)
                }
                
                // CAPITAL PROXIMITY SPEED BOOST - units near capital move faster (supply lines)
                // Units further from capital slow down (extended supply lines)
                const capital = nations[this.nation].capital;
                if (capital) {
                    const distToCapital = Math.hypot(this.x - capital.x, this.y - capital.y);
                    const maxDist = 800; // Reference distance
                    
                    if (distToCapital < maxDist * 0.3) {
                        // Very close to capital (within 30% radius) = 1.5x speed
                        maxSpeed *= 1.5; // Reduced from 2.5x
                    } else if (distToCapital < maxDist * 0.5) {
                        // Close to capital (30-50% radius) = 1.3x speed
                        maxSpeed *= 1.3; // Reduced from 2.0x
                    } else if (distToCapital < maxDist * 0.7) {
                        // Medium distance (50-70% radius) = 1.15x speed
                        maxSpeed *= 1.15; // Reduced from 1.5x
                    } else if (distToCapital < maxDist) {
                        // Far from capital (70-100% radius) = 1.05x speed
                        maxSpeed *= 1.05; // Reduced from 1.2x
                    }
                    // Beyond maxDist = normal speed (no bonus)
                }
                
                // Removed boat speed bonus - was causing units to prefer water routes around mountains
                // if (this.onBoat) maxSpeed *= 1.8;
                if (this.isLocked) maxSpeed = 2.0; // Allow movement to maintain spacing
                
                // ARTIFACT SPEED BONUSES - apply to max speed cap (NOT to velocity directly)
                // This prevents exponential stacking when buffs are active
                const bonuses = getArtifactBonuses(this.nation);
                maxSpeed *= bonuses.unitSpeed; // Strategic Plans, etc. modify the speed cap
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }
                
                // TERRAIN-AWARE PATHFINDING - guide units around mountains via tips
                // Units detect mountain orientation and flow toward ends, then around
                // ARTIFACT CARRIERS: Skip mountain repulsion - they phase through
                const isCarryingArtifactRepel = artifacts.find(a => a.carrier === this);
                let mountainRepelX = 0;
                let mountainRepelY = 0;
                
                if (speed > 0.1 && !this.isLocked && !this.inBattle && !isCarryingArtifactRepel) {
                    const currentTerrain = getTerrainType(this.x, this.y);
                    
                    // Detect mountains in all directions
                    const checkRadius = 20;
                    const mountainDirections = [];
                    
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const testX = this.x + Math.cos(angle) * checkRadius;
                        const testY = this.y + Math.sin(angle) * checkRadius;
                        
                        if (getTerrainType(testX, testY) === TERRAIN_TYPES.MOUNTAIN) {
                            mountainDirections.push({ angle, x: testX, y: testY });
                        }
                    }
                    
                    if (mountainDirections.length > 0) {
                        // Find the mountain "spine" direction by checking perpendicular samples
                        // The spine runs along the longest axis of mountain detection
                        let spineAngle = 0;
                        let maxSpineStrength = 0;
                        
                        for (let testAngle = 0; testAngle < Math.PI; testAngle += Math.PI / 16) {
                            // Check how many mountains align with this potential spine direction
                            let spineStrength = 0;
                            
                            for (let mtn of mountainDirections) {
                                // Calculate alignment with this spine direction
                                const alignment = Math.abs(Math.cos(mtn.angle - testAngle));
                                spineStrength += alignment;
                            }
                            
                            if (spineStrength > maxSpineStrength) {
                                maxSpineStrength = spineStrength;
                                spineAngle = testAngle;
                            }
                        }
                        
                        // Spine direction identified - now find which tip is closer
                        const leftTipAngle = spineAngle;
                        const rightTipAngle = spineAngle + Math.PI;
                        
                        // Sample along both directions to find open passages
                        let leftClearDist = 0;
                        let rightClearDist = 0;
                        
                        for (let dist = checkRadius; dist <= checkRadius * 3; dist += 20) {
                            if (leftClearDist === 0) {
                                const testX = this.x + Math.cos(leftTipAngle) * dist;
                                const testY = this.y + Math.sin(leftTipAngle) * dist;
                                if (getTerrainType(testX, testY) !== TERRAIN_TYPES.MOUNTAIN) {
                                    leftClearDist = dist;
                                }
                            }
                            
                            if (rightClearDist === 0) {
                                const testX = this.x + Math.cos(rightTipAngle) * dist;
                                const testY = this.y + Math.sin(rightTipAngle) * dist;
                                if (getTerrainType(testX, testY) !== TERRAIN_TYPES.MOUNTAIN) {
                                    rightClearDist = dist;
                                }
                            }
                        }
                        
                        // Choose the direction that gets clear sooner (closer tip)
                        const preferredAngle = (leftClearDist > 0 && (rightClearDist === 0 || leftClearDist < rightClearDist)) 
                            ? leftTipAngle 
                            : rightTipAngle;
                        
                        // Guide unit toward the tip and away from mountain
                        const guidanceStrength = 4.0;
                        mountainRepelX += Math.cos(preferredAngle) * guidanceStrength;
                        mountainRepelY += Math.sin(preferredAngle) * guidanceStrength;
                    
                    // Also add perpendicular repulsion from nearby mountains (reduced to allow tighter passage)
                    for (let mtn of mountainDirections) {
                        const repelStrength = 0.5;
                        const toMountain = mtn.angle;
                        mountainRepelX -= Math.cos(toMountain) * repelStrength;
                        mountainRepelY -= Math.sin(toMountain) * repelStrength;
                    }
                }
                
            // ENHANCED JITTER DETECTION - detect stuck units by movement oscillation
            // Decrease cooldown timer
            if (this.jitterCooldown > 0) {
                this.jitterCooldown -= dt;
            }
            
            // ALWAYS track position for jitter detection (not just on mountains)
            if (this.jitterCooldown <= 0) {
                // Track position samples to detect jittering
                this.jitterPositions.push({ x: this.x, y: this.y, vx: this.vx, vy: this.vy, time: performance.now() });
                // Keep only last 1.5 seconds of positions for better pattern detection
                this.jitterPositions = this.jitterPositions.filter(p => performance.now() - p.time < 1500);
                
                // JITTER DETECTION: Look for oscillation patterns indicating stuck unit
                if (this.jitterPositions.length >= 15) { // Need more samples for reliable detection
                    const avgX = this.jitterPositions.reduce((sum, p) => sum + p.x, 0) / this.jitterPositions.length;
                    const avgY = this.jitterPositions.reduce((sum, p) => sum + p.y, 0) / this.jitterPositions.length;
                    const maxDist = Math.max(...this.jitterPositions.map(p => Math.hypot(p.x - avgX, p.y - avgY)));
                    
                    // VELOCITY OSCILLATION: Check if velocity is changing direction frequently (stuck behavior)
                    let directionChanges = 0;
                    for (let i = 1; i < this.jitterPositions.length - 1; i++) {
                        const prev = this.jitterPositions[i - 1];
                        const curr = this.jitterPositions[i];
                        const next = this.jitterPositions[i + 1];
                        
                        // Check if velocity direction changed significantly
                        const prevAngle = Math.atan2(prev.vy, prev.vx);
                        const currAngle = Math.atan2(curr.vy, curr.vx);
                        const nextAngle = Math.atan2(next.vy, next.vx);
                        
                        // Detect direction reversal (angle change > 90 degrees)
                        let angleDiff1 = Math.abs(currAngle - prevAngle);
                        let angleDiff2 = Math.abs(nextAngle - currAngle);
                        if (angleDiff1 > Math.PI) angleDiff1 = Math.PI * 2 - angleDiff1;
                        if (angleDiff2 > Math.PI) angleDiff2 = Math.PI * 2 - angleDiff2;
                        
                        if (angleDiff1 > Math.PI / 2 || angleDiff2 > Math.PI / 2) {
                            directionChanges++;
                        }
                    }
                    
                    // STUCK DETECTION: Multiple direction changes + small movement radius = jittering
                    // EXCLUDE COMBAT: Don't trigger for units engaged in battle (natural jitter from fighting)
                // EXCLUDE ARTIFACT CARRIERS: They phase through terrain and don't need jitter rescue
                const isJittering = directionChanges >= 5 && maxDist < 5;
                const isInCombat = this.inBattle || this.engagingEnemy;
                const isCarryingArtifactJitter = artifacts.find(a => a.carrier === this);
                
                if (isJittering && !isInCombat && !isCarryingArtifactJitter) {
                    // Unit is stuck - determine rescue action (artifact carriers already handled above)
                    const moveAngle = Math.atan2(this.vy, this.vx);
                            // Try both left and right perpendicular, pick the one that's more passable
                            const perpAngleLeft = moveAngle + Math.PI / 2; // 90 degrees left
                            const perpAngleRight = moveAngle - Math.PI / 2; // 90 degrees right
                            const skipDist = 60; // Jump 60 units laterally
                            
                            const leftX = this.x + Math.cos(perpAngleLeft) * skipDist;
                            const leftY = this.y + Math.sin(perpAngleLeft) * skipDist;
                            const rightX = this.x + Math.cos(perpAngleRight) * skipDist;
                            const rightY = this.y + Math.sin(perpAngleRight) * skipDist;
                            
                            // Clamp to bounds
                            const boundedLeftX = Math.max(0, Math.min(canvas.width * WORLD_SCALE, leftX));
                            const boundedLeftY = Math.max(0, Math.min(canvas.height * WORLD_SCALE, leftY));
                            const boundedRightX = Math.max(0, Math.min(canvas.width * WORLD_SCALE, rightX));
                            const boundedRightY = Math.max(0, Math.min(canvas.height * WORLD_SCALE, rightY));
                            
                            // Check terrain at both destinations
                            const leftTerrain = getTerrainType(boundedLeftX, boundedLeftY);
                            const rightTerrain = getTerrainType(boundedRightX, boundedRightY);
                            
                            let newX, newY;
                            if (leftTerrain !== TERRAIN_TYPES.MOUNTAIN && rightTerrain === TERRAIN_TYPES.MOUNTAIN) {
                                // Left is clear, right is blocked - go left
                                newX = boundedLeftX;
                                newY = boundedLeftY;
                            } else if (rightTerrain !== TERRAIN_TYPES.MOUNTAIN && leftTerrain === TERRAIN_TYPES.MOUNTAIN) {
                                // Right is clear, left is blocked - go right
                                newX = boundedRightX;
                                newY = boundedRightY;
                            } else if (leftTerrain !== TERRAIN_TYPES.MOUNTAIN && rightTerrain !== TERRAIN_TYPES.MOUNTAIN) {
                                // Both clear - pick randomly
                                if (Math.random() < 0.5) {
                                    newX = boundedLeftX;
                                    newY = boundedLeftY;
                                } else {
                                    newX = boundedRightX;
                                    newY = boundedRightY;
                                }
                            } else {
                                // Both blocked - try forward as fallback
                                const forwardX = this.x + Math.cos(moveAngle) * 50;
                                const forwardY = this.y + Math.sin(moveAngle) * 50;
                                newX = Math.max(0, Math.min(canvas.width * WORLD_SCALE, forwardX));
                                newY = Math.max(0, Math.min(canvas.height * WORLD_SCALE, forwardY));
                            }
                            
                            // Check if destination is valid
                            const destTerrain = getTerrainType(newX, newY);
                            if (destTerrain !== TERRAIN_TYPES.MOUNTAIN) {
                                // LATERAL TRANSPORT JUMP - teleport around the mountain
                                this.x = newX;
                                this.y = newY;
                                this.jitterCooldown = 2.0; // Short cooldown before next action
                                this.jitterPositions = [];
                                return; // Skip missile launch
                            }
                            
                            // Can't jump (surrounded by mountains) - try missile launch instead
                            const nation = nations[this.nation];
                            
                            // JITTERY MOUNTAIN UNITS - Launch as missiles to NEARBY strategic targets
                            // Priority: Closest superweapons > Closest units > Closest enemy nodes > Closest unclaimed nodes
                            const allTargets = [];
                            
                            // 1. Enemy superweapons near our capital (HIGHEST PRIORITY)
                            superweapons.forEach(sw => {
                                const swOwnerNation = nations[sw.ownerNation];
                                if (sw.ownerNation !== this.nation && swOwnerNation && !swOwnerNation.capitulated && !swOwnerNation.resurrectionImmunity && !swOwnerNation.evacuationImmunity) {
                                    const dist = Math.hypot(sw.x - this.x, sw.y - this.y);
                                    const distToCapital = nation.capital ? Math.hypot(sw.x - nation.capital.x, sw.y - nation.capital.y) : Infinity;
                                    // Only target superweapons threatening our space (within 600 units of capital or this unit)
                                    if (dist > 100 && (dist < 600 || distToCapital < 600)) {
                                        allTargets.push({ 
                                            x: sw.x, 
                                            y: sw.y, 
                                            dist: dist,
                                            priority: 100 // Highest priority
                                        });
                                    }
                                }
                            });
                            
                            // 2. Regular enemy units (nearby threats)
                            nations.forEach(n => {
                                if (n.id !== this.nation && !n.capitulated && !n.resurrectionImmunity && !n.evacuationImmunity) {
                                    n.units.forEach(u => {
                                        const dist = Math.hypot(u.x - this.x, u.y - this.y);
                                        if (dist > 100 && dist < 500) { // Keep it local
                                            allTargets.push({ 
                                                x: u.x, 
                                                y: u.y, 
                                                dist: dist,
                                                priority: 80
                                            });
                                        }
                                    });
                                }
                            });
                            
                            // 3. Enemy nodes (nearby enemy territory) - skip nodes owned by immune nations
                            nodes.forEach(n => {
                                if (n.owner >= 0 && n.owner !== this.nation) {
                                    const ownerNation = nations[n.owner];
                                    if (!ownerNation || ownerNation.resurrectionImmunity || ownerNation.evacuationImmunity) return; // Skip immune nations
                                    
                                    const dist = Math.hypot(n.x - this.x, n.y - this.y);
                                    if (dist > 100 && dist < 500) {
                                        allTargets.push({ 
                                            x: n.x, 
                                            y: n.y, 
                                            dist: dist,
                                            priority: n.crypticName ? 50 : 40 // Special nodes slightly higher
                                        });
                                    }
                                }
                            });
                            
                            // 4. Uncontrolled nodes (expansion - only nearby)
                            nodes.forEach(n => {
                                if (n.owner === -1) {
                                    const dist = Math.hypot(n.x - this.x, n.y - this.y);
                                    if (dist > 100 && dist < 450) { // Shorter range for unclaimed
                                        allTargets.push({ 
                                            x: n.x, 
                                            y: n.y, 
                                            dist: dist,
                                            priority: 30 // Lower priority
                                        });
                                    }
                                }
                            });
                            
                            // 60% chance to launch (increased from 40%)
                            if (allTargets.length > 0 && Math.random() < 0.6) {
                                // Sort by priority FIRST (threats), then by distance (closest within priority tier)
                                allTargets.sort((a, b) => {
                                    if (a.priority !== b.priority) return b.priority - a.priority; // Higher priority first
                                    return a.dist - b.dist; // NEAREST within same priority
                                });
                                
                                const target = allTargets[0];
                                
                                // Calculate launch trajectory
                                const dx = target.x - this.x;
                                const dy = target.y - this.y;
                                const dist = Math.hypot(dx, dy);
                                const flightTime = 3.0;
                                
                                this.launchVelocity.x = dx / flightTime;
                                this.launchVelocity.y = dy / flightTime;
                                this.launchHeight = Math.min(dist * 0.8, 600);
                                
                                this.isAirborne = true;
                                this.airborneTimer = 0;
                                this.impactSoundPlayed = false;
                                
                                Audio.playMissileLaunch(this.x, this.y);
                            } else {
                                // No targets, just add to artillery
                                if (!nation.artilleryMagazine) nation.artilleryMagazine = 0;
                                nation.artilleryMagazine++;
                            }
                            
                            // Clear jitter to prevent spam
                            this.jitterPositions = [];
                            this.nearMountainTimer = 0;
                            this.jitterCooldown = 20.0; // Long cooldown before checking again
                        }
                    }
                }
            }
        
        this.vx += mountainRepelX;
        this.vy += mountainRepelY;
        
        // CAPITAL MISSILE SYSTEM - launch at uncontrolled nodes from capitals (frequently) or special nodes (rarely)
        if (!this.isAirborne && this.jitterCooldown <= 0 && this.capitalMissileCooldown <= 0) {
            const nation = nations[this.nation];
            const capital = nation ? nation.capital : null;
            
            // Check all conditions before attempting launch
            const gameTime = game.startTime ? (performance.now() - game.startTime) / 1000 : 0;
            const canLaunchYet = gameTime >= 60; // Wait 60 seconds before missiles can fire
            
            // Check nation-specific missile cooldown (for resurrected nations)
            const nationMissileCooldown = nation && nation.missileLaunchCooldown ? nation.missileLaunchCooldown : 0;
            
            // Only nations with 3+ nodes can launch missiles (prevents tiny nations spamming)
            const nodeCount = nodes.filter(n => n.owner === this.nation).length;
            const isLargeEnough = nodeCount >= 3;
            
            if (canLaunchYet && nationMissileCooldown <= 0 && isLargeEnough) {
                // Determine which type of node we're near
                const nearCapital = capital && Math.hypot(this.x - capital.x, this.y - capital.y) < 50;
                const nearSpecialNode = !nearCapital && nodes.find(n => 
                    n.owner === this.nation && 
                    n.crypticName && 
                    Math.hypot(this.x - n.x, this.y - n.y) < 50
                );
                
                // Only launch if near a valid node
                if (nearCapital || nearSpecialNode) {
                    // Different launch chances: capitals more frequent, special nodes less frequent
                    const launchChance = nearCapital ? 0.06 : 0.03; // 6% for capitals, 3% for special nodes (increased)
                    
                    if (Math.random() < launchChance) {
                        // Find targets with priority: superweapons > units > enemy nodes > unclaimed nodes
                        const allTargets = [];
                        
                        // 1. Enemy superweapons near our territory (HIGHEST PRIORITY)
                        superweapons.forEach(sw => {
                            const swOwnerNation = nations[sw.ownerNation];
                            if (sw.ownerNation !== this.nation && swOwnerNation && !swOwnerNation.capitulated && !swOwnerNation.resurrectionImmunity && !swOwnerNation.evacuationImmunity) {
                                const dist = Math.hypot(sw.x - this.x, sw.y - this.y);
                                if (dist < 600) {
                                    allTargets.push({ 
                                        x: sw.x, 
                                        y: sw.y, 
                                        dist: dist,
                                        priority: 100
                                    });
                                }
                            }
                        });
                        
                        // 2. Regular enemy units (nearby threats)
                        nations.forEach(n => {
                            if (n.id !== this.nation && !n.capitulated && !n.resurrectionImmunity && !n.evacuationImmunity) {
                                n.units.forEach(u => {
                                    const dist = Math.hypot(u.x - this.x, u.y - this.y);
                                    if (dist < 500) {
                                        allTargets.push({ 
                                            x: u.x, 
                                            y: u.y, 
                                            dist: dist,
                                            priority: 80
                                        });
                                    }
                                });
                            }
                        });
                        
                        // 3. Enemy nodes (contested territory) - skip nodes owned by nations with immunity
                        nodes.forEach(n => {
                            if (n.owner >= 0 && n.owner !== this.nation) {
                                const ownerNation = nations[n.owner];
                                if (!ownerNation || ownerNation.resurrectionImmunity || ownerNation.evacuationImmunity) return; // Skip immune nations
                                
                                const dist = Math.hypot(n.x - this.x, n.y - this.y);
                                if (dist < 500) {
                                    allTargets.push({ 
                                        x: n.x, 
                                        y: n.y, 
                                        dist: dist,
                                        priority: n.crypticName ? 50 : 40
                                    });
                                }
                            }
                        });
                        
                        // 4. Uncontrolled nodes (expansion - lower priority)
                        nodes.filter(n => n.owner === -1).forEach(n => {
                            const dist = Math.hypot(n.x - this.x, n.y - this.y);
                            if (dist < 400) {
                                allTargets.push({ 
                                    x: n.x, 
                                    y: n.y, 
                                    dist: dist,
                                    priority: 30
                                });
                            }
                        });
                        
                        // Launch at best target
                        if (allTargets.length > 0) {
                            // Sort by priority (highest first), then by distance (NEAREST first)
                            allTargets.sort((a, b) => {
                                if (a.priority !== b.priority) return b.priority - a.priority;
                                return a.dist - b.dist; // NEAREST within same priority
                            });
                            
                            const bestTarget = allTargets[0];
                            
                            // Calculate launch velocity toward target (NO TELEPORTING - launch from current position)
                            const dx = bestTarget.x - this.x;
                            const dy = bestTarget.y - this.y;
                            const dist = Math.hypot(dx, dy);
                            const flightTime = 3.0;
                            
                            this.launchVelocity.x = dx / flightTime;
                            this.launchVelocity.y = dy / flightTime;
                            this.launchHeight = Math.min(dist * 0.8, 500);
                            
                            // Enter airborne mode
                            this.isAirborne = true;
                            this.airborneTimer = 0;
                            this.impactSoundPlayed = false;
                            
                            // Play missile launch sound
                            Audio.playMissileLaunch(this.x, this.y);
                            
                            // Set cooldowns
                            this.capitalMissileCooldown = 12.0;
                            this.jitterCooldown = 10.0;
                            
                            // Clear jitter tracking
                            this.jitterPositions = [];
                        }
                    }
                }
            }
        }
        
        // Update capital missile cooldown
        if (this.capitalMissileCooldown > 0) {
            this.capitalMissileCooldown -= dt;
        }
        
        // AIRBORNE PARABOLIC FLIGHT - units launched from capital
        if (this.isAirborne) {
            this.airborneTimer += dt;
            const flightDuration = 3.0;
            
            // Play impact sound early so falling sound plays during descent and thump at landing
            // Impact sound is 0.4s total (0.25s fall + 0.15s thump)
            // Play at 2.75s so thump happens at 3.0s landing
            if (!this.impactSoundPlayed && this.airborneTimer >= 2.75) {
                this.impactSoundPlayed = true;
                Audio.playMissileImpact(this.x, this.y);
            }
            
            if (this.airborneTimer >= flightDuration) {
                // Landing
                this.isAirborne = false;
                this.airborneTimer = 0;
                // Continue with normal movement
            } else {
                // Parabolic trajectory
                const progress = this.airborneTimer / flightDuration;
                // Parabola: y = -4h(x)(x-1) where h is max height
                const heightMultiplier = -4 * progress * (progress - 1); // 0 at start, 1 at peak, 0 at end
                
                // Move horizontally at constant velocity
                this.vx = this.launchVelocity.x;
                this.vy = this.launchVelocity.y;
                
                // No terrain effects while airborne
                // Multiply by dt instead of gameSpeed to maintain correct flight physics
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Skip all other movement logic while airborne
                return;
            }
        }
        
        // Apply terrain speed modifier (mountains slow you down if you ignore repulsion)
        // ARTIFACT CARRIERS: Phase through terrain but are slowed when crossing mountains
        const isCarryingArtifactForTerrain = artifacts.find(a => a.carrier === this);
        const currentTerrainForSpeed = getTerrainType(this.x, this.y);
        
        if (isCarryingArtifactForTerrain) {
            // Artifact carriers phase through but are slowed on mountains
            if (currentTerrainForSpeed === TERRAIN_TYPES.MOUNTAIN) {
                this.vx *= 0.3; // Heavy slowdown while crossing mountains
                this.vy *= 0.3;
            }
        } else {
            // Regular units - normal terrain penalties
            if (currentTerrainForSpeed !== TERRAIN_TYPES.MOUNTAIN) {
                const terrainMultiplier = getTerrainSpeedMultiplier(this.x, this.y, this.vx, this.vy);
                this.vx *= terrainMultiplier;
                this.vy *= terrainMultiplier;
            } else {
                // On mountain = moderate slowdown to allow sliding off
                this.vx *= 0.5;
                this.vy *= 0.5;
            }
        }
            
                // Artifact speed bonuses now applied to maxSpeed cap earlier (line ~7690)
                // This prevents exponential stacking every frame
            // Track distance traveled this frame
            const distThisFrame = Math.hypot(this.x - this.lastPosX, this.y - this.lastPosY);
            this.distanceTraveled += distThisFrame;
            this.lastPosX = this.x;
            this.lastPosY = this.y;
            
            // Drain stamina based on speed (sprinting is tiring)
            const currentSpeed = Math.hypot(this.vx, this.vy);
            if (currentSpeed > 8) {
                // Sprinting - rapid stamina drain
                this.stamina = Math.max(0, this.stamina - dt * 15);
            } else if (currentSpeed > 3) {
                // Marching - moderate drain
                this.stamina = Math.max(0, this.stamina - dt * 5);
            } else if (currentSpeed > 0.5) {
                // Walking - slow drain
                this.stamina = Math.max(0, this.stamina - dt * 1);
            }
            
            // Regenerate stamina - faster at friendly nodes, slower in the field
            const nearNode = nodes.find(n => n.owner === this.nation && Math.hypot(n.x - this.x, n.y - this.y) < 60);
            if (nearNode) {
                // At friendly node - rapid recovery
                this.stamina = Math.min(100, this.stamina + dt * 18);
            } else if (currentSpeed < 0.5) {
                // Stationary in field - moderate recovery
                    this.stamina = Math.min(100, this.stamina + dt * 2);
                }
                
                // Apply stamina penalty to movement speed - gradual degradation
                if (this.stamina < 50) {
                    // Tired - gradual slowdown from 50 stamina down
                    const fatigueMultiplier = 0.5 + (this.stamina / 50) * 0.5; // 50%-100% speed
                    this.vx *= fatigueMultiplier;
                    this.vy *= fatigueMultiplier;
                }
                
                // COMBAT JITTER - visual activity when engaged
                // Don't jitter if capturing a node
                let isCapturingNode = false;
                for (let node of nodes) {
                    const distToNode = Math.hypot(this.x - node.x, this.y - node.y);
                    if (distToNode < 40 && node.capturingNation === this.nation) {
                        isCapturingNode = true;
                        break;
                    }
                }
                
                if (this.isLocked && !isCapturingNode) {
                    const jitterStrength = 0.8;
                    this.x += (Math.random() - 0.5) * jitterStrength;
                    this.y += (Math.random() - 0.5) * jitterStrength;
                }
                
                // STUCK DETECTION - if barely moving, add random jitter
                // Enhanced to detect maze/corner traps and escape more aggressively
                const movement = Math.hypot(this.x - this.lastX, this.y - this.lastY);
                if (movement < 0.5 && this.targetNode) {
                    this.stuckCounter++;
                    
                    // Escalating escape attempts
                    if (this.stuckCounter > 30) {
                        // Very stuck - clear target and reassign
                        this.targetNode = null;
                        this.waypointNode = null;
                        this.stuckCounter = 0;
                    } else if (this.stuckCounter > 20) {
                        // Moderately stuck - strong random push in any direction
                        const escapeAngle = Math.random() * Math.PI * 2;
                        this.vx += Math.cos(escapeAngle) * 5.0;
                        this.vy += Math.sin(escapeAngle) * 5.0;
                    } else if (this.stuckCounter > 10) {
                        // Slightly stuck - try moving perpendicular to current direction
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        const perpAngle = currentAngle + (Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2);
                        this.vx += Math.cos(perpAngle) * 3.0;
                        this.vy += Math.sin(perpAngle) * 3.0;
                    }
                } else {
                    this.stuckCounter = 0;
                }
                this.lastX = this.x;
                this.lastY = this.y;
                
                // MOVE - apply velocity to position (framerate-dependent for original speed)
                const newX = this.x + this.vx * gameSpeed;
                const newY = this.y + this.vy * gameSpeed;
                
                // Artifact carriers PHASE THROUGH mountains - no checks, just move
                const isCarryingArtifact = artifacts.find(a => a.carrier === this);
                if (isCarryingArtifact) {
                    // Direct movement - ignore all terrain
                    this.x = newX;
                    this.y = newY;
                } else {
                    // Normal movement for non-artifact carriers
                    this.x = newX;
                    this.y = newY;
                }
                
                // Clamp to boundaries
                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));
                
                // Boundaries already clamped above after movement
            }
            
            draw() {
                const baseColor = nations[this.nation].color;
                
                // Airborne units - draw with shadow and larger size
                if (this.isAirborne) {
                    const progress = this.airborneTimer / 3.0;
                    const heightMultiplier = -4 * progress * (progress - 1);
                    const currentHeight = this.launchHeight * heightMultiplier;
                    const shadowOffset = currentHeight * 0.3;
                    
                    // Draw shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x + shadowOffset, this.y + shadowOffset, 3, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw airborne unit (larger and elevated)
                    ctx.fillStyle = baseColor;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - currentHeight * 0.1, 3, 0, Math.PI * 2); // Slight visual elevation
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    return;
                }
                
                // Simple, efficient rendering - no flash effects
                // Unit body - fixed size for performance
                const size = this.inBattle ? 2.5 : 2; // Slightly larger when engaged
                ctx.fillStyle = baseColor;
                ctx.globalAlpha = this.inBattle ? 1.0 : 0.8; // Full opacity when engaged
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                // Minimal visual indicators for performance
                // All state is conveyed through the influence grid and borders
            }
        }
        
        // Spatial partitioning for unit proximity queries (performance)
        const spatialGridSize = 80; // Larger cells for unit queries
        let spatialGrid = new Map();
        
        function getSpatialKey(x, y) {
            return `${Math.floor(x / spatialGridSize)},${Math.floor(y / spatialGridSize)}`;
        }
        
        function updateSpatialGrid(allUnits) {
            spatialGrid.clear();
            allUnits.forEach(unit => {
                const key = getSpatialKey(unit.x, unit.y);
                if (!spatialGrid.has(key)) spatialGrid.set(key, []);
                spatialGrid.get(key).push(unit);
            });
        }
        
        function getNearbyUnits(x, y, radius, includeSuperweapons = false) {
            const nearby = [];
            const cellRadius = Math.ceil(radius / spatialGridSize);
            const centerX = Math.floor(x / spatialGridSize);
            const centerY = Math.floor(y / spatialGridSize);
            
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    const key = `${centerX + dx},${centerY + dy}`;
                    const units = spatialGrid.get(key);
                    if (units) nearby.push(...units);
                }
            }

            if (includeSuperweapons) {
                superweapons.forEach(sw => {
                    const dist = Math.hypot(sw.x - x, sw.y - y);
                    if (dist <= radius) {
                        nearby.push(sw);
                    }
                });
            }
            return nearby;
        }
        
        // Influence grid for territory calculation
        const gridSize = 10; // Smaller cells = higher fidelity frontlines (was 20)
        let influenceGrid = [];
        
        function initGrid() {
            const cols = Math.ceil((canvas.width * WORLD_SCALE) / gridSize);
            const rows = Math.ceil((canvas.height * WORLD_SCALE) / gridSize);
            influenceGrid = Array(rows).fill(null).map(() => 
                Array(cols).fill(null).map(() => ({ 
                    nation: -1, 
                    strength: 0, 
                    stability: 0 
                }))
            );
        }
        
        function updateInfluenceGrid(dt) {
            // First pass: accumulate influence from all units (including enemy counter-influence)
            const tempInfluence = [];
            
            // Initialize temp grid
            for (let y = 0; y < influenceGrid.length; y++) {
                tempInfluence[y] = [];
                for (let x = 0; x < influenceGrid[y].length; x++) {
                    tempInfluence[y][x] = {};
                    // Track influence per nation
                    nations.forEach(nation => {
                        tempInfluence[y][x][nation.id] = 0;
                    });
                }
            }
            
            // Accumulate influence from each unit
            nations.forEach(nation => {
                // Allow capitulated nations with units to show influence (resistance)
                // Also preserve influence if nation still owns nodes (even without units)
                const ownsNodes = nodes.some(n => n.owner === nation.id);
                if (nation.units.length === 0 && !ownsNodes) return;
                
                nation.units.forEach(unit => {
                    // Skip airborne units (missiles in flight) - they don't project influence
                    if (unit.isAirborne) return;
                    
                    const gx = Math.floor(unit.x / gridSize);
                    const gy = Math.floor(unit.y / gridSize);
                    // Influence trail is 0.75x engagement range (half previous)
                    const engagementRange = 50; // Must match unit engagement range
                    const radius = Math.ceil(engagementRange * 0.75 / gridSize); // ~6 grid cells
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = gx + dx;
                            const ny = gy + dy;
                            
                            if (ny >= 0 && ny < influenceGrid.length && 
                                nx >= 0 && nx < influenceGrid[0].length) {
                                const distSq = dx * dx + dy * dy;
                                
                                if (distSq <= radius * radius) {
                                    // Falloff based on distance
                                    const influence = 1.0 - (Math.sqrt(distSq) / radius) * 0.5;
                                    tempInfluence[ny][nx][nation.id] += influence;
                                }
                            }
                        }
                    }
                });
                
                // If nation has no units but owns nodes, project influence from owned nodes
                if (nation.units.length === 0 && ownsNodes) {
                    nodes.filter(n => n.owner === nation.id).forEach(node => {
                        const gx = Math.floor(node.x / gridSize);
                        const gy = Math.floor(node.y / gridSize);
                        const radius = 3; // Smaller radius for node-only influence
                        
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = gx + dx;
                                const ny = gy + dy;
                                
                                if (ny >= 0 && ny < influenceGrid.length && 
                                    nx >= 0 && nx < influenceGrid[0].length) {
                                    const distSq = dx * dx + dy * dy;
                                    
                                    if (distSq <= radius * radius) {
                                        // Falloff based on distance
                                        const influence = 0.5 * (1.0 - (Math.sqrt(distSq) / radius) * 0.5);
                                        tempInfluence[ny][nx][nation.id] += influence;
                                    }
                                }
                            }
                        }
                    });
                }
            });
            
            // Second pass: resolve contested cells - strongest influence wins
            for (let y = 0; y < influenceGrid.length; y++) {
                for (let x = 0; x < influenceGrid[y].length; x++) {
                    const cell = influenceGrid[y][x];
                    const influences = tempInfluence[y][x];
                    
                    // Find strongest influence
                    let maxInfluence = 0;
                    let dominantNation = -1;
                    
                    nations.forEach(nation => {
                        if (influences[nation.id] > maxInfluence) {
                            maxInfluence = influences[nation.id];
                            dominantNation = nation.id;
                        }
                    });
                    
                    // Update cell if there's a clear dominant influence
                    if (maxInfluence > 0.3) { // Threshold to claim territory
                        cell.nation = dominantNation;
                        cell.strength = Math.min(1.0, maxInfluence);
                        if (cell.stability < 1.0) {
                            cell.stability = Math.min(1.0, cell.stability + 0.05);
                        }
                    } else if (maxInfluence > 0) {
                        // Weak influence - decay existing claim
                        const decayRate = dt * 0.05; // Trail fades over ~2 seconds
                        cell.strength = Math.max(0, cell.strength - decayRate);
                        cell.stability = Math.max(0, cell.stability - decayRate * 0.5);
                        
                        // Clear cell if strength drops too low
                        if (cell.strength < 0.1) {
                            cell.nation = -1;
                            cell.strength = 0;
                            cell.stability = 0;
                        }
                    } else {
                        // No influence at all - faster decay
                        const decayRate = dt * 0.01; // Fade over ~1 second
                        cell.strength = Math.max(0, cell.strength - decayRate);
                        cell.stability = Math.max(0, cell.stability - decayRate * 0.5);
                        
                        // Clear cell if strength drops too low
                        if (cell.strength < 0.1) {
                            cell.nation = -1;
                            cell.strength = 0;
                            cell.stability = 0;
                        }
                    }
                }
            }
            
            // Grow stability for established territory slowly
            const stabilityGrowth = dt * 0.000001; // Double decay rate
            for (let y = 0; y < influenceGrid.length; y++) {
                for (let x = 0; x < influenceGrid[y].length; x++) {
                    const cell = influenceGrid[y][x];
                    if (cell.nation >= 0 && cell.strength > 0.5 && cell.stability < 2.0) {
                        cell.stability = Math.min(2.0, cell.stability + stabilityGrowth);
                    }
                }
            }
        }
        
        function drawInfluenceGrid() {
            // Batch rendering by nation for better performance
            nations.forEach(nation => {
                // Show influence for capitulated nations with units (resistance)
                if (nation.units.length === 0) return;
                
                ctx.fillStyle = nation.color;
                
                for (let y = 0; y < influenceGrid.length; y++) {
                    for (let x = 0; x < influenceGrid[y].length; x++) {
                        const cell = influenceGrid[y][x];
                        if (cell.nation === nation.id && cell.strength > 0.2) {
                            // Alpha based on stability
                            const alpha = 0.1 + (cell.stability * 0.15);
                            ctx.globalAlpha = alpha;
                            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        }
                    }
                }
            });
            ctx.globalAlpha = 1.0;
        }
        
        function drawBorders() {
            // Draw distinct frontlines between nations
            // Only draw borders at mountain tips or canvas edges (not along mountain faces)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.9;
            
            for (let y = 0; y < influenceGrid.length; y++) {
                for (let x = 0; x < influenceGrid[y].length; x++) {
                    const cell = influenceGrid[y][x];
                    if (cell.nation >= 0) {
                        // Check adjacent cells for borders
                        const px = x * gridSize;
                        const py = y * gridSize;
                        
                        // Check if current position is on/near a mountain
                        const onMountain = getTerrainType(px, py) === TERRAIN_TYPES.MOUNTAIN;
                        
                        // Right border
                        if (x + 1 < influenceGrid[y].length) {
                            const right = influenceGrid[y][x + 1];
                            if (right.nation >= 0 && right.nation !== cell.nation) {
                                const rightMountain = getTerrainType(px + gridSize, py) === TERRAIN_TYPES.MOUNTAIN;
                                
                                // Only draw if:
                                // 1. At canvas edge (right edge)
                                // 2. At mountain tip (one side is mountain, other is not)
                                // 3. Both sides are clear of mountains
                                const atEdge = (x + 1 >= influenceGrid[y].length - 1);
                                const atMountainTip = (onMountain && !rightMountain) || (!onMountain && rightMountain);
                                const bothClear = !onMountain && !rightMountain;
                                
                                if (atEdge || atMountainTip || bothClear) {
                                    ctx.beginPath();
                                    ctx.moveTo(px + gridSize, py);
                                    ctx.lineTo(px + gridSize, py + gridSize);
                                    ctx.stroke();
                                }
                            }
                        }
                        
                        // Bottom border
                        if (y + 1 < influenceGrid.length) {
                            const bottom = influenceGrid[y + 1][x];
                            if (bottom.nation >= 0 && bottom.nation !== cell.nation) {
                                const bottomMountain = getTerrainType(px, py + gridSize) === TERRAIN_TYPES.MOUNTAIN;
                                
                                // Only draw if:
                                // 1. At canvas edge (bottom edge)
                                // 2. At mountain tip (one side is mountain, other is not)
                                // 3. Both sides are clear of mountains
                                const atEdge = (y + 1 >= influenceGrid.length - 1);
                                const atMountainTip = (onMountain && !bottomMountain) || (!onMountain && bottomMountain);
                                const bothClear = !onMountain && !bottomMountain;
                                
                                if (atEdge || atMountainTip || bothClear) {
                                    ctx.beginPath();
                                    ctx.moveTo(px, py + gridSize);
                                    ctx.lineTo(px + gridSize, py + gridSize);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                }
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // Initialize
        generateTerrain(); // Generate procedural terrain features
        initGrid();
        
        // Helper to find valid land position
        function findValidLandPosition(attempts = 100) {
            for (let i = 0; i < attempts; i++) {
                const x = Math.random() * canvas.width * WORLD_SCALE;
                const y = Math.random() * canvas.height * WORLD_SCALE;
                if (isLand(x, y)) {
                    return { x, y };
                }
            }
            // Fallback to center if nothing found
            return { x: (canvas.width * WORLD_SCALE) / 2, y: (canvas.height * WORLD_SCALE) / 2 };
        }
        
        // Generate starting positions - maximize distance between capitals
        // FAIR POSITIONING: Use elliptical distribution to normalize distances on rectangular canvas
        // This ensures all nations have equal strategic positioning regardless of canvas aspect ratio
        const capitalPositions = [];
        
        nations.forEach((nation, i) => {
            let bestPos = null;
            let bestMinDist = 0;
            
            // Calculate normalized dimensions for elliptical sampling
            const centerX = (canvas.width * WORLD_SCALE) / 2;
            const centerY = (canvas.height * WORLD_SCALE) / 2;
            const margin = 150;
            const radiusX = (canvas.width * WORLD_SCALE / 2) - margin; // Horizontal radius
            const radiusY = (canvas.height * WORLD_SCALE / 2) - margin; // Vertical radius
            
            // Try many random positions and pick the one farthest from other capitals
            for (let attempt = 0; attempt < 200; attempt++) {
                // Sample from ellipse using polar coordinates - ensures fair distribution
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * 0.9; // 0.9 keeps positions away from very center
                
                // Convert to elliptical coordinates (normalizes rectangular canvas)
                const testX = centerX + Math.cos(angle) * radius * radiusX;
                const testY = centerY + Math.sin(angle) * radius * radiusY;
                
                if (isLand(testX, testY)) {
                    // Calculate minimum distance to any existing capital
                    let minDist = Infinity;
                    for (let existingPos of capitalPositions) {
                        const dx = testX - existingPos.x;
                        const dy = testY - existingPos.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        minDist = Math.min(minDist, dist);
                    }
                    
                    // Keep position if it's farther from others
                    if (minDist > bestMinDist) {
                        bestMinDist = minDist;
                        bestPos = { x: testX, y: testY };
                    }
                }
            }
            
            // Fallback if no valid position found
            if (!bestPos) bestPos = findValidLandPosition();
            
            capitalPositions.push(bestPos);
            
            // Create capital
            const capitalNode = new Node(bestPos.x, bestPos.y, true);
            capitalNode.owner = nation.id;
            capitalNode.controlStrength = 1.0;
            nodes.push(capitalNode);
            nation.capital = capitalNode;
            
            // Create 2 nearby economic nodes on land - NEUTRAL at start
            for (let j = 0; j < 2; j++) {
                let nodePos = null;
                for (let attempt = 0; attempt < 50; attempt++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 120 + Math.random() * 80;
                    let testX = bestPos.x + Math.cos(angle) * dist;
                    let testY = bestPos.y + Math.sin(angle) * dist;
                    
                    // Constrain to canvas bounds
                    const margin = 100;
                    testX = Math.max(margin, Math.min(canvas.width * WORLD_SCALE - margin, testX));
                    testY = Math.max(margin, Math.min(canvas.height * WORLD_SCALE - margin, testY));
                    
                    if (isGoodNodeLocation(testX, testY)) {
                        // Check spacing from existing nodes
                        const tooClose = nodes.some(n => 
                            Math.hypot(n.x - testX, n.y - testY) < 100
                        );
                        
                        if (!tooClose) {
                            nodePos = { x: testX, y: testY };
                            break;
                        }
                    }
                }
                
                if (nodePos) {
                    const node = new Node(nodePos.x, nodePos.y, false);
                    // Leave as neutral - anyone can capture
                    nodes.push(node);
                }
            }
            
            // Starting units - spawn initial force at capital (doubled for faster action)
            for (let i = 0; i < 40; i++) {
                // Find valid spawn position
                let spawnX, spawnY, attempts = 0;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 20 + Math.random() * 30;
                    spawnX = bestPos.x + Math.cos(angle) * dist;
                    spawnY = bestPos.y + Math.sin(angle) * dist;
                    attempts++;
                } while (!isPassable(spawnX, spawnY) && attempts < 20);
                
                // Only spawn if valid
                if (isPassable(spawnX, spawnY)) {
                    const unit = new Unit(spawnX, spawnY, nation.id);
                    nation.units.push(unit);
                }
            }
        });
        
        // Simple noise function for organic node distribution
        function simpleNoise(x, y, seed) {
            const n = Math.sin(x * 0.013 + seed) * Math.cos(y * 0.011 + seed) + 
                      Math.sin(x * 0.007 - seed) * Math.cos(y * 0.009 - seed);
            return (n + 2) / 4; // Normalize to 0-1
        }
        
        // Generate neutral nodes using noise-based sampling - fill entire map
        const nodesTarget = 50; // Target number of neutral nodes
        const noiseSeed = Math.random() * 100;
        let neutralNodesCreated = 0;
        
        // Create a grid of potential positions weighted by noise
        const nodeGridSize = 80; // Grid cell size for node placement
        const potentialPositions = [];
        
        for (let gx = 0; gx < canvas.width * WORLD_SCALE; gx += nodeGridSize) {
            for (let gy = 0; gy < canvas.height * WORLD_SCALE; gy += nodeGridSize) {
                // Random offset within grid cell, but constrain to safe area
                const margin = 100;
                let testX = gx + Math.random() * nodeGridSize;
                let testY = gy + Math.random() * nodeGridSize;
                
                // Keep nodes away from edges
                testX = Math.max(margin, Math.min(canvas.width * WORLD_SCALE - margin, testX));
                testY = Math.max(margin, Math.min(canvas.height * WORLD_SCALE - margin, testY));
                
                if (isGoodNodeLocation(testX, testY)) {
                    const noiseValue = simpleNoise(testX, testY, noiseSeed);
                    // Use noise as priority weight
                    potentialPositions.push({
                        x: testX,
                        y: testY,
                        priority: noiseValue
                    });
                }
            }
        }
        
        // Sort by noise priority and place nodes with spacing
        potentialPositions.sort((a, b) => b.priority - a.priority);
        
        for (let pos of potentialPositions) {
            if (neutralNodesCreated >= nodesTarget) break;
            
            // Check minimum spacing from all existing nodes (30 unit buffer)
            const tooClose = nodes.some(n => 
                Math.hypot(n.x - pos.x, n.y - pos.y) < 30
            );
            
            if (!tooClose) {
                const newNode = new Node(pos.x, pos.y, false);
                nodes.push(newNode);
                neutralNodesCreated++;
            }
        }
        
        // Global unit cap
        const MAX_TOTAL_UNITS = 800; // 4 nations × 200 optimal units = proper frontline density
        
        // Spawn special artifacts on the map
        // NOTE: spear is a nested item - spawns when Safe is unlocked
        // GUARANTEED SPAWNS - ensure critical items appear exactly once
        const guaranteedArtifacts = [
            'lab', 'lab_key', 'safe', 'safe_key', 
            'reactor', 'access_card', 'prototype', 'auth_code',
            'keycode', 'weapon', 'plans', 'data'
        ];
        
        for (let artifactType of guaranteedArtifacts) {
            let artifactPos = null;
            for (let attempt = 0; attempt < 500; attempt++) {
                const testX = 200 + Math.random() * (canvas.width * WORLD_SCALE - 400);
                const testY = 200 + Math.random() * (canvas.height * WORLD_SCALE - 400);
                
                if (isGoodNodeLocation(testX, testY)) {
                    // Check distance from capitals (min 250 units away - reduced)
                    const farFromCapitals = capitalPositions.every(cap => 
                        Math.hypot(cap.x - testX, cap.y - testY) > 250
                    );
                    
                    // Check distance from other artifacts (min 100 units - reduced for better success)
                    const farFromArtifacts = artifacts.every(art =>
                        Math.hypot(art.x - testX, art.y - testY) > 100
                    );
                    
                    if (farFromCapitals && farFromArtifacts) {
                        artifactPos = { x: testX, y: testY };
                        break;
                    }
                }
            }
            
            if (artifactPos) {
                const artifact = new SpecialArtifact(artifactPos.x, artifactPos.y, artifactType);
                artifact.spawnTime = 0; // Track from game start
                artifacts.push(artifact);
                console.log(`Spawned artifact: ${artifactType} at (${Math.floor(artifactPos.x)}, ${Math.floor(artifactPos.y)})`);
            } else {
                console.warn(`FAILED to spawn critical artifact: ${artifactType}`);
            }
        }
        
        // Game state object
        const game = {
            respawnTimer: undefined,
            respawnDelay: 40,
            resurrectionInProgress: false,
            resurrectionBlockTimer: 0,
            resurrectionBlockDelay: 40.0, // 10 second delay after 3+ nations alive
            paused: true, // Start paused until first click
            hasStarted: false, // Track if welcome message has been played
            startTime: null, // Track when game actually starts (after unpause)
            // IMPACT SYSTEM - tracks world destruction and triggers apocalyptic reset
            impactCount: 0, // Total impacts this session
            lastImpactCheck: 0, // Time of last destruction check
            impactCheckInterval: 5.0, // Check every 5 seconds
            destructionThreshold: 25, // Number of craters to trigger impact
            impactInProgress: false, // Currently executing impact sequence
            impactTimer: 0, // Timer for impact animation
            crossSpires: [] // Monuments to the fallen
        };
        
        // ===== AI DEBUG LOG SYSTEM =====
        // This log tracks key AI decisions for analysis and debugging
        // Format: timestamp, event type, data
        const aiDebugLog = [];
        const MAX_LOG_ENTRIES = 1000; // Keep last 1000 events
        
        function logAIEvent(category, message, data = {}) {
            const timestamp = performance.now();
            const entry = {
                time: timestamp,
                category: category, // 'redistribution', 'capital', 'artifact', 'combat', etc.
                message: message,
                data: data
            };
            
            aiDebugLog.push(entry);
            
            // Keep log size manageable
            if (aiDebugLog.length > MAX_LOG_ENTRIES) {
                aiDebugLog.shift(); // Remove oldest entry
            }
            
            // Also log to console with formatted tag
            console.log(`[AI-${category.toUpperCase()}] ${message}`, data);
        }
        
        function downloadAILog() {
            const logText = aiDebugLog.map(entry => {
                const timeStr = (entry.time / 1000).toFixed(2);
                const dataStr = Object.keys(entry.data).length > 0 ? JSON.stringify(entry.data) : '';
                return `[${timeStr}s] [${entry.category}] ${entry.message} ${dataStr}`;
            }).join('\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-debug-log-${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Downloaded AI log with ${aiDebugLog.length} entries`);
        }
        
        // Add keyboard shortcut: Press 'L' to download log
        document.addEventListener('keydown', (e) => {
            if (e.key === 'l' || e.key === 'L') {
                downloadAILog();
            }
            // Game speed controls
            if (e.key === 'ArrowLeft') {
                const step = e.shiftKey ? 1.0 : 0.1; // Shift for 1.0x jumps, normal for 0.1x
                gameSpeed = Math.max(0.05, gameSpeed - step);
                gameSpeed = Math.round(gameSpeed * 100) / 100; // Round to 2 decimals
                speedChangeFlash = 1.0; // Trigger flash
                console.log(`[GAME SPEED] Decreased to ${gameSpeed.toFixed(2)}x (${e.shiftKey ? 'SHIFT: Large step' : 'Normal step'})`);
                logAIEvent('game', 'Speed decreased', { speed: gameSpeed });
            }
            if (e.key === 'ArrowRight') {
                const step = e.shiftKey ? 1.0 : 0.1; // Shift for 1.0x jumps, normal for 0.1x
                gameSpeed = Math.min(5.0, gameSpeed + step);
                gameSpeed = Math.round(gameSpeed * 100) / 100; // Round to 2 decimals
                speedChangeFlash = 1.0; // Trigger flash
                console.log(`[GAME SPEED] Increased to ${gameSpeed.toFixed(2)}x (${e.shiftKey ? 'SHIFT: Large step' : 'Normal step'})`);
                logAIEvent('game', 'Speed increased', { speed: gameSpeed });
            }
        });
        
        // Log game start
        logAIEvent('game', 'Game initialized', { timestamp: new Date().toISOString() });
        // ===== END AI DEBUG LOG SYSTEM =====
        
        // Game loop with performance optimizations
        let lastTime = performance.now();
        let frameCount = 0;
        let lastConnectivityCheck = 0;
        let lastFpsUpdate = 0;
        let fps = 0;
        let frameTimeSum = 0;
        let frameTimeCount = 0;
        let gameSpeed = 1.0; // Game speed multiplier (0.05 to 5.0)
        let speedChangeFlash = 0; // Flash effect when speed changes
        
        function gameLoop() {
            const now = performance.now();
            const frameTime = (now - lastTime) / 1000;
            const dt = game.paused ? 0 : Math.min(frameTime, 0.1) * gameSpeed; // Apply speed multiplier to timestep
            lastTime = now;
            frameCount++;
            
            // Debug logging every 60 frames (about once per second)
            if (frameCount % 60 === 0) {
                console.log('Game loop running - paused:', game.paused, 'speed:', gameSpeed.toFixed(2), 'dt:', dt.toFixed(4), 'units:', nations.reduce((sum, n) => sum + n.units.length, 0));
            }
            
            // Track FPS
            frameTimeSum += frameTime * 1000;
            frameTimeCount++;
            if (now - lastFpsUpdate > 1000) {
                fps = Math.round(1000 / (frameTimeSum / frameTimeCount));
                frameTimeSum = 0;
                frameTimeCount = 0;
                lastFpsUpdate = now;
            }
            
            // Decay speed change flash
            if (speedChangeFlash > 0) {
                speedChangeFlash -= dt * 2; // Fade over 0.5 seconds
            }
            
            // Skip all game logic if paused
            if (!game.paused) {
                // Update crater ages for cooling effect
                craters.forEach(crater => {
                    crater.age = (Date.now() - crater.createdAt) / 1000; // Age in seconds
                });
                
                // === IMPACT SYSTEM - Check for world destruction ===
                game.lastImpactCheck += dt;
                if (game.lastImpactCheck >= game.impactCheckInterval && !game.impactInProgress) {
                    game.lastImpactCheck = 0;
                    
                    // Count total destruction markers (craters from nuclear detonations)
                    const destructionLevel = craters.length;
                    
                    if (destructionLevel >= game.destructionThreshold) {
                        // TRIGGER IMPACT EVENT
                        game.impactInProgress = true;
                        game.impactTimer = 0;
                        game.impactCount++;
                        
                        console.log(`🌍 IMPACT EVENT ${game.impactCount} TRIGGERED - Destruction level: ${destructionLevel}`);
                        logGameEvent('impact', `Impact ${game.impactCount} triggered`, { craters: destructionLevel, priority: 'critical' });
                        
                        // ANNOUNCER: Impact warning
                        Audio.announce(`Impact event detected. All life ceases. You start anew.`, 'critical');
                        
                        // Visual/audio effect at impact
                        Audio.playImpactEvent();
                    }
                }
                
                // Execute impact sequence (pauses normal game logic)
                if (game.impactInProgress) {
                    game.impactTimer += dt;
                    
                    // Pause all normal game updates during impact
                    // Only impact sequence runs
                    
                    // Phase 1: Conversion (0-3 seconds) - convert all units to cross spires
                    if (game.impactTimer < 3.0) {
                        // FIRST TIME: Save survivors before conversion starts
                        if (!game.impactSurvivors) {
                            game.impactSurvivors = [];
                            nations.forEach(nation => {
                                if (nation.units.length > 0) {
                                    // Save 1-2 units per nation as survivors
                                    const survivorCount = Math.min(2, nation.units.length);
                                    const survivors = [];
                                    
                                    for (let i = 0; i < survivorCount; i++) {
                                        const unit = nation.units[i];
                                        survivors.push({
                                            x: unit.x,
                                            y: unit.y,
                                            nationId: nation.id,
                                            health: unit.health,
                                            strength: unit.strength,
                                            veterancy: unit.veterancy
                                        });
                                    }
                                    
                                    game.impactSurvivors.push(...survivors);
                                }
                            });
                            console.log(`🌍 IMPACT: Saved ${game.impactSurvivors.length} survivors`);
                        }
                        
                        // Gradually convert units (but skip the saved survivors)
                        const conversionRate = dt * 50; // Convert ~50 units per second
                        nations.forEach(nation => {
                            const unitsToConvert = Math.min(nation.units.length, Math.ceil(conversionRate));
                            for (let i = 0; i < unitsToConvert; i++) {
                                const unit = nation.units[i];
                                if (unit) {
                                    // Create cross spire at unit location
                                    game.crossSpires.push({
                                        x: unit.x,
                                        y: unit.y,
                                        createdAt: Date.now(),
                                        nation: nation.id,
                                        color: nation.color
                                    });
                                }
                            }
                            nation.units.splice(0, unitsToConvert);
                        });
                        
                        // Convert superweapons too
                        superweapons.forEach((sw, idx) => {
                            game.crossSpires.push({
                                x: sw.x,
                                y: sw.y,
                                createdAt: Date.now(),
                                nation: sw.owner,
                                color: nations[sw.owner].color,
                                large: true // Superweapon spires are larger
                            });
                        });
                        superweapons.length = 0;
                    }
                    
                    // Phase 2: Reset (3-5 seconds) - wipe everything and restart
                    if (game.impactTimer >= 3.0 && game.impactTimer < 5.0) {
                        // Clean up expired cross spires (older than 3 seconds)
                        const now = Date.now();
                        game.crossSpires = game.crossSpires.filter(spire => {
                            const age = (now - spire.createdAt) / 1000;
                            return age < 3.0; // Keep only recent ones for fade effect
                        });
                    }
                    
                    // Phase 3: Rebirth (5+ seconds)
                    if (game.impactTimer >= 5.0) {
                        // RESET THE WORLD
                        console.log('🌍 WORLD RESET - Starting anew');
                        
                        // Clear all game state
                        nodes.length = 0;
                        artifacts.length = 0;
                        artillery.length = 0;
                        superweapons.length = 0; // Clear all superweapons
                        detonationEffects.length = 0;
                        craters.length = 0;
                        game.crossSpires.length = 0;
                        
                        // Reset announcer state for clean slate
                        announcerState.lastMassiveBattle = 0;
                        announcerState.lastDominanceAnnounce = 0;
                        announcerState.lastComeback = 0;
                        announcerState.lastStalemate = 0;
                        announcerState.lastCapitalCapture = 0;
                        announcerState.lastSuperweaponBattle = 0;
                        announcerState.lastSuperweaponDeploy = 0;
                        announcerState.lastEstablishment = 0;
                        
                        // Reset nations but keep their identities
                        nations.forEach(nation => {
                            nation.units = [];
                            nation.resources = 500;
                            nation.capitulated = true; // Mark as capitulated until they establish capital
                            nation.eliminated = false;
                            nation.capital = null;
                            nation.resurrectionCount = 0;
                            nation.recentLosses = [];
                            nation.recentWins = [];
                            nation.recentWarCrimes = [];
                            nation.warExhaustion = 0;
                            nation.diplomaticRelations = {};
                            nation.strengthModifier = 1.0;
                            // Clear cached node lists
                            nation.cachedMyNodes = [];
                            nation.cachedUncontrolledNodes = [];
                            nation.cachedThreatenedNodes = [];
                            nation.allianceTrust = {};
                            nation.tributePaying = null;
                            nation.tributeReceiving = [];
                            if (nation.consumedBonuses) {
                                nation.consumedBonuses.dataConsumed = 0;
                                nation.consumedBonuses.reactorConsumed = false;
                            }
                        });
                        
                        // Regenerate world
                        generateTerrain();
                        initGrid();
                        usedCrypticNames = [];
                        
                        // RESTORE SURVIVORS - spawn them at scattered positions
                        const newCapitalPositions = [];
                        if (game.impactSurvivors && game.impactSurvivors.length > 0) {
                            console.log(`🌍 Restoring ${game.impactSurvivors.length} survivors`);
                            
                            game.impactSurvivors.forEach(survivor => {
                                // Find a valid land position near their original location
                                let spawnPos = null;
                                for (let attempt = 0; attempt < 50; attempt++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = Math.random() * 150;
                                    const testX = survivor.x + Math.cos(angle) * dist;
                                    const testY = survivor.y + Math.sin(angle) * dist;
                                    
                                    if (isPassable(testX, testY) && isGoodNodeLocation(testX, testY)) {
                                        spawnPos = { x: testX, y: testY };
                                        break;
                                    }
                                }
                                
                                // Fallback to any valid position
                                if (!spawnPos) {
                                    for (let attempt = 0; attempt < 100; attempt++) {
                                        const testX = Math.random() * canvas.width * WORLD_SCALE;
                                        const testY = Math.random() * canvas.height * WORLD_SCALE;
                                        if (isPassable(testX, testY) && isGoodNodeLocation(testX, testY)) {
                                            spawnPos = { x: testX, y: testY };
                                            break;
                                        }
                                    }
                                }
                                
                                if (spawnPos) {
                                    const unit = new Unit(spawnPos.x, spawnPos.y, survivor.nationId);
                                    // Restore some of their stats
                                    unit.health = Math.max(50, survivor.health);
                                    unit.strength = survivor.strength;
                                    unit.veterancy = Math.min(100, survivor.veterancy + 20); // Survivors gain experience
                                    unit.morale = 0.8; // Slightly shell-shocked
                                    
                                    nations[survivor.nationId].units.push(unit);
                                }
                            });
                            
                            // Clear survivors list
                            game.impactSurvivors = null;
                        }
                        
                        // Regenerate neutral nodes (NO capitals - survivors must establish them)
                        const nodesTarget = 50;
                        const noiseSeed = Math.random() * 100;
                        let neutralNodesCreated = 0;
                        const nodeGridSize = 80;
                        const potentialPositions = [];
                        
                        for (let gx = 0; gx < canvas.width * WORLD_SCALE; gx += nodeGridSize) {
                            for (let gy = 0; gy < canvas.height * WORLD_SCALE; gy += nodeGridSize) {
                                const x = gx + Math.random() * nodeGridSize;
                                const y = gy + Math.random() * nodeGridSize;
                                
                                if (isGoodNodeLocation(x, y)) {
                                    const noise = simpleNoise(x, y, noiseSeed);
                                    if (noise > 0.3) {
                                        potentialPositions.push({ x, y, priority: noise });
                                    }
                                }
                            }
                        }
                        
                        potentialPositions.sort((a, b) => b.priority - a.priority);
                        
                        for (let pos of potentialPositions) {
                            if (neutralNodesCreated >= nodesTarget) break;
                            
                            const tooClose = nodes.some(n => Math.hypot(n.x - pos.x, n.y - pos.y) < 100);
                            if (!tooClose) {
                                const tier = Math.random() < 0.7 ? 1 : (Math.random() < 0.5 ? 0 : 2);
                                const newNode = new Node(pos.x, pos.y, false);
                                newNode.economicTier = tier;
                                const tierMultipliers = [0.5, 1.0, 1.5, 2.5];
                                newNode.resourceMultiplier = tierMultipliers[tier];
                                newNode.owner = -1; // Neutral
                                nodes.push(newNode);
                                neutralNodesCreated++;
                            }
                        }
                        
                        // Respawn artifacts with correct names
                        const guaranteedArtifacts = [
                            'lab_key', 'lab', 'safe_key', 'safe',
                            'reactor', 'access_card', 'prototype', 'auth_code',
                            'keycode', 'weapon', 'plans', 'data'
                        ];
                        
                        for (let artifactType of guaranteedArtifacts) {
                            let artifactPos = null;
                            for (let attempt = 0; attempt < 50; attempt++) {
                                const x = Math.random() * canvas.width * WORLD_SCALE;
                                const y = Math.random() * canvas.height * WORLD_SCALE;
                                
                                if (isGoodNodeLocation(x, y)) {
                                    // Check distance from other artifacts (min 100 units)
                                    const farFromArtifacts = artifacts.every(art =>
                                        Math.hypot(art.x - x, art.y - y) > 100
                                    );
                                    
                                    if (farFromArtifacts) {
                                        artifactPos = { x, y };
                                        break;
                                    }
                                }
                            }
                            
                            if (artifactPos) {
                                const artifact = new SpecialArtifact(artifactPos.x, artifactPos.y, artifactType);
                                artifact.spawnTime = 0;
                                artifacts.push(artifact);
                            }
                        }
                        
                        // End impact sequence
                        game.impactInProgress = false;
                        game.impactTimer = 0;
                        
                        console.log(`🌍 World reborn after Impact ${game.impactCount}`);
                        Audio.announce(`World cycle ${game.impactCount} begins. Survivors must establish new capitals.`, 'high');
                    }
                }
                
                // Process diplomatic evaluations
                processDiplomacy(Date.now());
            
            // Gradual unit spawning DISABLED - nodes now produce all units
            // (Initial spawning removed to let economy-based production handle everything)
            
            // Gather all units
            const allUnits = [];
            nations.forEach(nation => {
                allUnits.push(...nation.units);
            });
            
            // Build spatial grid for efficient proximity queries
            updateSpatialGrid(allUnits);
            
            // Skip normal game logic updates during Impact event
            if (!game.impactInProgress) {
            
            // Population cap is now enforced at spawn time (not by killing units)
            // See node production logic - spawns are blocked when allUnits.length >= MAX_TOTAL_UNITS
            
            // Calculate resistance intensity per nation (avoids O(n²) in node updates)
            const resistanceIntensity = {};
            const totalNodes = nodes.filter(n => n.owner !== -1).length;
            nations.forEach(nation => {
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                if (nodeCount >= 8) { // Reduced from 10 - resistance starts earlier
                    // Initialize resistance buildup timer if not exists
                    if (!nation.resistanceBuildupTime) nation.resistanceBuildupTime = 0;
                    
                    // Resistance builds up over 30 seconds (was 60 - much faster now!)
                    nation.resistanceBuildupTime += dt;
                    const buildupProgress = Math.min(1.0, nation.resistanceBuildupTime / 30.0);
                    
                    // Resistance scales EXPONENTIALLY with map dominance - VERY aggressive near 100%
                    // Calculate their map share (0.0 to 1.0)
                    const mapShare = totalNodes > 0 ? nodeCount / totalNodes : 0;
                    
                    // EXPONENTIAL CURVE: resistance explodes as they approach total control
                    // 50% control = moderate, 75% = strong, 90% = severe, 95%+ = devastating
                    // Formula: exponential growth based on how close to 100% they are
                    const proximityToTotal = mapShare; // 0.0 to 1.0
                    
                    // Exponential curve: (e^(4*mapShare) - 1) / (e^4 - 1) normalized to 0-1, then amplified
                    // This creates gentle growth early, EXPLOSIVE growth near 100%
                    const exponentialFactor = (Math.exp(5 * proximityToTotal) - 1) / (Math.exp(5) - 1);
                    
                    // Base resistance from node count
                    const overextension = Math.max(0, nodeCount - 8); // Adjusted for new threshold
                    
                    // Combine base with exponential dominance penalty
                    // INCREASED multiplier for more aggressive resistance
                    // At 50% control: ~1.5x, 75%: ~5x, 90%: ~25x, 95%: ~60x, 99%: ~145x
                    const baseResistance = overextension * 0.12 * (1 + exponentialFactor * 40); // Increased from 0.08 and 30
                    
                    resistanceIntensity[nation.id] = Math.min(15.0, baseResistance * buildupProgress); // Increased cap from 10 to 15
                } else {
                    resistanceIntensity[nation.id] = 0;
                    nation.resistanceBuildupTime = 0; // Reset when no longer overextended
                }
            });
            
            // UNIT DEFECTION - units at high-resistance nodes may flip to rebellious nations
            // Target ONLY the most overextended nation to prevent map-wide chaos
            // Defections ramp up gradually with resistance intensity
            
            // Initialize resistance spawn cooldown
            if (!game.lastResistanceSpawn) game.lastResistanceSpawn = 0;
            const timeSinceLastSpawn = performance.now() - game.lastResistanceSpawn;
            
            if (Math.random() < 0.15 && timeSinceLastSpawn >= 1000) { // 15% of frames AND 1 second cooldown
                // Find the single most overextended nation
                let mostOverextended = null;
                let maxResistance = 0;
                
                nations.forEach(nation => {
                    const resistance = resistanceIntensity[nation.id] || 0;
                    // Lower threshold - start defections earlier but at very low rates
                    if (resistance > maxResistance && resistance > 0.05) { // Start at 0.05 for earlier resistance
                        maxResistance = resistance;
                        mostOverextended = nation;
                    }
                });
                
                // Only cause defections if there's a clear overextended target
                if (mostOverextended && maxResistance > 0.05) {
                    // Find UNUSED nation templates from the pool (not currently active in the field)
                    // Only count NON-CAPITULATED nations as using their templates
                    const usedTemplateIndices = nations
                        .filter(n => !n.capitulated && n.templateIndex !== undefined)
                        .map(n => n.templateIndex);
                    const availableTemplates = [];
                    
                    for (let i = 0; i < nationColors.length; i++) {
                        if (!usedTemplateIndices.includes(i)) {
                            availableTemplates.push(i);
                        }
                    }
                    
                    // If all 16 nations are active, pick from capitulated nations instead
                    let resistancePool = availableTemplates;
                    if (availableTemplates.length === 0) {
                        // All templates in use - use ELIMINATED nations for resistance (not just capitulated)
                        // EXCLUDE the nation being overextended (can't resist against yourself)
                        const eliminatedIndices = nations
                            .filter(n => n.eliminated && n.templateIndex !== undefined && n.id !== mostOverextended.id)
                            .map(n => n.templateIndex);
                        resistancePool = eliminatedIndices;
                    }
                    
                    if (resistancePool.length > 0) {
                        // TARGETED RESISTANCE - find nodes with WEAKEST imperial control
                        // EXCLUDE capital and nodes near capital (resistance spawns at periphery, not core)
                        const resistanceNodes = nodes.filter(n => {
                            if (n.owner !== mostOverextended.id) return false;
                            if (n === mostOverextended.capital) return false; // Never spawn at capital
                            if (mostOverextended.capital) {
                                const distToCapital = Math.hypot(n.x - mostOverextended.capital.x, n.y - mostOverextended.capital.y);
                                if (distToCapital < 200) return false; // Don't spawn within 200 units of capital
                            }
                            return true;
                        });
                        
                        if (resistanceNodes.length > 0) {
                            // Score each node by weakness (lower control = higher score)
                            const scoredNodes = resistanceNodes.map(node => {
                                let weaknessScore = 0;
                                
                                // Distance from capital (further = MUCH weaker control)
                                if (mostOverextended.capital) {
                                    const distToCapital = Math.hypot(node.x - mostOverextended.capital.x, node.y - mostOverextended.capital.y);
                                    weaknessScore += distToCapital * 0.5; // HEAVILY favor distant nodes (increased from 0.1)
                                }
                                
                                // Count imperial units nearby (fewer = weaker)
                                const imperialUnitsNearby = getNearbyUnits(node.x, node.y, 100)
                                    .filter(u => u.nation === mostOverextended.id).length;
                                weaknessScore += (10 - Math.min(imperialUnitsNearby, 10)) * 50; // Heavily favor low-unit areas
                                
                                // Check influence grid strength at this node
                                const gx = Math.floor(node.x / gridSize);
                                const gy = Math.floor(node.y / gridSize);
                                if (gy >= 0 && gy < influenceGrid.length && gx >= 0 && gx < influenceGrid[0].length) {
                                    const cell = influenceGrid[gy][gx];
                                    if (cell.nation === mostOverextended.id) {
                                        // Lower influence strength = higher weakness
                                        weaknessScore += (1.0 - cell.strength) * 100;
                                    }
                                }
                                
                                return { node, weaknessScore, imperialUnitsNearby };
                            });
                            
                            // Sort by weakness (highest = most vulnerable to resistance)
                            scoredNodes.sort((a, b) => b.weaknessScore - a.weaknessScore);
                            
                            // Pick from top 50% weakest nodes (more targets for resistance)
                            const weakestNodes = scoredNodes.slice(0, Math.max(1, Math.floor(scoredNodes.length * 0.5)));
                            
                            // SPAWN AT MULTIPLE WEAK POINTS - scale with resistance intensity (limited)
                            const numTargets = Math.min(weakestNodes.length, Math.min(3, Math.floor(1 + maxResistance * 0.15))); // 1-3 targets max
                            
                            for (let targetIdx = 0; targetIdx < numTargets; targetIdx++) {
                                const targetNodeData = weakestNodes[Math.floor(Math.random() * weakestNodes.length)];
                                const randomNode = targetNodeData.node;
                                const unitsAtNode = targetNodeData.imperialUnitsNearby;
                            
                            // Defection chance ramps smoothly with resistance
                            // 0.1 resistance = 0.5% chance, 0.5 = 2.5%, 1.0 = 5%, 1.5 = 7.5%
                            const baseDefectionChance = maxResistance * 0.05;
                            
                            if (unitsAtNode > 0) {
                                // Units present at weak point - attempt defection
                                const imperialUnits = mostOverextended.units.filter(u => 
                                    Math.hypot(u.x - randomNode.x, u.y - randomNode.y) < 50
                                );
                                
                                if (imperialUnits.length > 0) {
                                    const randomUnit = imperialUnits[Math.floor(Math.random() * imperialUnits.length)];
                                    
                                    if (Math.random() < baseDefectionChance) {
                                        // Pick random unused nation template for defection
                                        const templateIndex = resistancePool[Math.floor(Math.random() * resistancePool.length)];
                                        
                                        // Check if this nation already exists (from previous resistance spawns)
                                        let resistanceNation = nations.find(n => n.templateIndex === templateIndex);
                                        
                                        // If nation doesn't exist yet, create it
                                        if (!resistanceNation) {
                                            const newNationId = nations.length;
                                            resistanceNation = {
                                                id: newNationId,
                                                name: nationColors[templateIndex].name,
                                                color: nationColors[templateIndex].color,
                                                personality: nationPersonalities[templateIndex],
                                                voice: nationVoices[templateIndex],
                                                templateIndex: templateIndex,
                                                units: [],
                                                capital: null,
                                                capitulated: false,
                                                strengthModifier: 1.0,
                                                resources: 50,
                                                income: 0,
                                                upkeep: 0,
                                                production: 0,
                                                unitQueue: 0,
                                                artilleryMagazine: 0,
                                                queueSpawnTimer: 0,
                                                overpopTimer: 0,
                                                diplomaticRelations: {},
                                                warExhaustion: 0,
                                                totalCasualties: 0,
                                                recentLosses: [],
                                                recentWins: [],
                                                lastDiplomaticEval: 0,
                                                activeOffers: [],
                                                tributePaying: -1,
                                                tributeReceiving: [],
                                                warCrimes: 0,
                                                recentWarCrimes: [],
                                                allianceTrust: {},
                                                lastCapitalEval: 0,
                                                capitalEvacuations: 0,
                                                evacuationCooldown: 0,
                                                superweaponProgress: 0,
                                                superweaponCooldown: 0
                                            };
                                            nations.push(resistanceNation);
                                            
                                            // Initialize diplomatic relations for new nation
                                            nations.forEach(n => {
                                                if (n.id !== resistanceNation.id) {
                                                    resistanceNation.diplomaticRelations[n.id] = undefined; // Can fight
                                                    n.diplomaticRelations[resistanceNation.id] = undefined;
                                                }
                                            });
                                        }
                                        
                                        // Unit defects to resistance nation
                                        const index = mostOverextended.units.indexOf(randomUnit);
                                        if (index > -1) {
                                            mostOverextended.units.splice(index, 1);
                                            randomUnit.nation = resistanceNation.id;
                                            resistanceNation.units.push(randomUnit);
                                        }
                                    }
                                }
                            } else if (maxResistance > 0.3) {
                                // NO units at weakest node - SPAWN resistance fighters!
                                // Only spawn when resistance is significant (>0.3)
                                // Higher resistance = more spawns, controlled growth
                                const spawnChance = Math.max(0, (maxResistance - 0.3) * 0.4); // 0.3 = 0%, 1.0 = 28%, 3.0 = 108% (capped), 10.0 = 388% (capped)
                                
                                if (Math.random() < spawnChance) {
                                    // Pick random unused nation template
                                    const templateIndex = resistancePool[Math.floor(Math.random() * resistancePool.length)];
                                    
                                    // Check if this nation already exists (from previous resistance spawns)
                                    let resistanceNation = nations.find(n => n.templateIndex === templateIndex);
                                    
                                    // If nation doesn't exist yet, create it
                                    if (!resistanceNation) {
                                        const newNationId = nations.length;
                                        resistanceNation = {
                                            id: newNationId,
                                            name: nationColors[templateIndex].name,
                                            color: nationColors[templateIndex].color,
                                            personality: nationPersonalities[templateIndex],
                                            voice: nationVoices[templateIndex],
                                            templateIndex: templateIndex,
                                            units: [],
                                            capital: null,
                                            capitulated: false,
                                            strengthModifier: 1.0,
                                            resources: 50,
                                            income: 0,
                                            upkeep: 0,
                                            production: 0,
                                            unitQueue: 0,
                                            artilleryMagazine: 0,
                                            queueSpawnTimer: 0,
                                            overpopTimer: 0,
                                            diplomaticRelations: {},
                                            warExhaustion: 0,
                                            totalCasualties: 0,
                                            recentLosses: [],
                                            recentWins: [],
                                            lastDiplomaticEval: 0,
                                            activeOffers: [],
                                            tributePaying: -1,
                                            tributeReceiving: [],
                                            warCrimes: 0,
                                            recentWarCrimes: [],
                                            allianceTrust: {},
                                            lastCapitalEval: 0,
                                            capitalEvacuations: 0,
                                            evacuationCooldown: 0,
                                            superweaponProgress: 0,
                                            superweaponCooldown: 0
                                        };
                                        nations.push(resistanceNation);
                                        
                                        // Initialize diplomatic relations for new nation
                                        nations.forEach(n => {
                                            if (n.id !== resistanceNation.id) {
                                                resistanceNation.diplomaticRelations[n.id] = undefined; // Can fight
                                                n.diplomaticRelations[resistanceNation.id] = undefined;
                                            }
                                        });
                                    }
                                    
                                    // Spawn resistance fighter at weakest point
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = 20 + Math.random() * 10;
                                    const spawnX = randomNode.x + Math.cos(angle) * dist;
                                    const spawnY = randomNode.y + Math.sin(angle) * dist;
                                    
                                    const resistanceFighter = new Unit(spawnX, spawnY, resistanceNation.id);
                                    resistanceFighter.jitterCooldown = 10.0;
                                    resistanceFighter.capitalMissileCooldown = 10.0;
                                    resistanceFighter.jitterPositions = [];
                                    // Keep resistance fighters near spawn - garrison role, target nearby node
                                    resistanceFighter.role = 'garrison';
                                    resistanceFighter.targetNode = randomNode;
                                    resistanceFighter.targetCommitmentTime = 20.0; // Stay committed to this node for 20 seconds
                                    resistanceNation.units.push(resistanceFighter);
                                    
                                    // Update spawn cooldown timestamp
                                    game.lastResistanceSpawn = performance.now();
                                    
                                    console.log(`Resistance fighter spawned for ${resistanceNation.name} at weak node (resistance: ${maxResistance.toFixed(2)}, weakness: ${targetNodeData.weaknessScore.toFixed(1)})`);
                                }
                            }
                            } // End of multi-target loop
                        }
                    }
                }
            }
            
            // Update nodes and handle death/respawning
            for (let i = nodes.length - 1; i >= 0; i--) {
                const shouldRemove = nodes[i].update(dt, nations, resistanceIntensity) === false;
                if (shouldRemove) {
                    const dyingNode = nodes[i];
                    
                    // VISUAL/AUDIO: Node explosion when destroyed
                    Audio.playArtillery(dyingNode.x, dyingNode.y);
                    
                    // DROP ALL ARTIFACTS stored at this node
                    artifacts.forEach(artifact => {
                        if (artifact.storedAtNode === dyingNode) {
                            // Release artifact from storage at valid position
                            const validPos = findValidDropPosition(dyingNode.x, dyingNode.y);
                            artifact.x = validPos.x;
                            artifact.y = validPos.y;
                            artifact.storedAtNode = null;
                            artifact.capturedBy = -1; // Becomes unclaimed
                            artifact.captureProgress = 0;
                            // Position stays at node location for pickup
                            
                            // Reset any in-progress tasks
                            artifact.studyProgress = 0;
                            artifact.decryptProgress = 0;
                            artifact.studyingNode = null;
                            artifact.decryptingNode = null;
                        }
                    });
                    
                    // Node died from fatigue - schedule respawn
                    if (!game.respawnTimer) {
                        game.respawnTimer = 0;
                        game.respawnDelay = 5.0; // 5 seconds before new node spawns
                    }
                    nodes.splice(i, 1);
                }
            }
            
            // Remove nodes marked for destruction by superweapons
            for (let i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].markedForDestruction) {
                    const destroyedNode = nodes[i];
                    
                    // DROP ALL ARTIFACTS stored at this node
                    artifacts.forEach(artifact => {
                        if (artifact.storedAtNode === destroyedNode) {
                            // Release artifact from storage at valid position
                            const validPos = findValidDropPosition(destroyedNode.x, destroyedNode.y);
                            artifact.x = validPos.x;
                            artifact.y = validPos.y;
                            artifact.storedAtNode = null;
                            artifact.capturedBy = -1; // Becomes unclaimed
                            artifact.captureProgress = 0;
                            
                            // Reset any in-progress tasks
                            artifact.studyProgress = 0;
                            artifact.decryptProgress = 0;
                            artifact.studyingNode = null;
                            artifact.decryptingNode = null;
                        }
                    });
                    
                    // Schedule respawn
                    if (!game.respawnTimer) {
                        game.respawnTimer = 0;
                        game.respawnDelay = 5.0;
                    }
                    
                    nodes.splice(i, 1);
                }
            }
            
            // Handle node respawning
            if (game.respawnTimer !== undefined) {
                game.respawnTimer += dt;
                if (game.respawnTimer >= game.respawnDelay) {
                    // Find random location without existing nodes
                    let newNodeX, newNodeY, validSpot = false;
                    const margin = 100;
                    
                    for (let attempts = 0; attempts < 10; attempts++) {
                        newNodeX = margin + Math.random() * (canvas.width * WORLD_SCALE - 2 * margin);
                        newNodeY = margin + Math.random() * (canvas.height * WORLD_SCALE - 2 * margin);
                        
                        // Check if valid location (away from mountains)
                        if (!isGoodNodeLocation(newNodeX, newNodeY)) continue;
                        
                        // Check no node exists nearby
                        const tooClose = nodes.some(n => Math.hypot(n.x - newNodeX, n.y - newNodeY) < 150);
                        if (!tooClose) {
                            validSpot = true;
                            break;
                        }
                    }
                    
                    if (validSpot) {
                        const newNode = new Node(newNodeX, newNodeY, false);
                        newNode.isBuilding = true;
                        newNode.buildTimer = 0;
                        nodes.push(newNode);
                        game.respawnTimer = undefined;
                    } else {
                        game.respawnTimer = undefined; // Try again next death
                    }
                }
            }
            
            // Throttle expensive connectivity checks (every 2 seconds)
            if (now - lastConnectivityCheck > 2000) {
                nations.forEach(nation => {
                    nation.units.forEach(unit => {
                        unit.checkConnectivity(nodes, allUnits, nation);
                    });
                });
                lastConnectivityCheck = now;
            }
            
            // CAPITAL RELOCATION - nations annually evaluate and move capital to optimal location
            // Strategic placement balances economic value with safety from threats
            nations.forEach(nation => {
                if (nation.capitulated || !nation.capital) return;
                
                // Initialize timers and counters
                if (!nation.lastCapitalEval) nation.lastCapitalEval = 0;
                if (nation.capitalEvacuations === undefined) nation.capitalEvacuations = 0;
                if (nation.evacuationCooldown === undefined) nation.evacuationCooldown = 0;
                
                nation.lastCapitalEval += dt;
                
                // Decrease evacuation cooldown
                if (nation.evacuationCooldown > 0) {
                    nation.evacuationCooldown -= dt;
                    if (nation.evacuationCooldown <= 0) {
                        nation.evacuationCooldown = 0;
                        nation.capitalEvacuations = 0; // Reset counter when cooldown expires
                    }
                }
                
                // EMERGENCY EVACUATION: Capital under threat, can quickly relocate up to 2 times
                const capitalUnderAttack = nation.capital.capturingNation >= 0;
                const nearbyEnemies = getNearbyUnits(nation.capital.x, nation.capital.y, 150, true);
                const enemyUnits = nearbyEnemies.filter(u => u.nation !== nation.id).length;
                const isUnderThreat = capitalUnderAttack || enemyUnits >= 8;
                
                // Can evacuate if: under threat AND (haven't evacuated twice OR cooldown expired)
                const canEvacuate = isUnderThreat && nation.capitalEvacuations < 2 && nation.evacuationCooldown <= 0;
                
                // Regular evaluation: annually (60 seconds) or emergency evacuation
                const shouldEvaluate = nation.lastCapitalEval >= 60.0 || canEvacuate;
                if (!shouldEvaluate) return;
                
                // Only reset timer on regular evaluation (not emergency)
                if (!canEvacuate) {
                    nation.lastCapitalEval = 0;
                }
                
                // Check if current capital is under threat or there's a better option
                const ownedNodes = nodes.filter(n => n.owner === nation.id);
                if (ownedNodes.length <= 1) return; // Only 1 node, can't relocate
                
                // Calculate optimal node: economic value + strategic safety
                let bestNode = nation.capital;
                let bestScore = -Infinity;
                
                for (let node of ownedNodes) {
                    // ECONOMIC VALUE (0-10 points)
                    const economicValue = (node.economicTier * 2) + node.resourceMultiplier * 2;
                    
                    // SAFETY FACTORS
                    const fatiguePenalty = node.fatigue * 0.2; // High fatigue = contested area
                    const captureRisk = node.capturingNation >= 0 ? 30 : 0; // Currently under attack
                    
                    // Distance from enemies (check for nearby threats)
                    const nearbyUnits = getNearbyUnits(node.x, node.y, 200, true);
                    const enemyCount = nearbyUnits.filter(u => u.nation !== nation.id).length;
                    const threatPenalty = enemyCount * 2; // Each nearby enemy = -2 points
                    
                    // Central positioning (distance from map edges - more defensible)
                    const worldWidth = canvas.width * WORLD_SCALE;
                    const worldHeight = canvas.height * WORLD_SCALE;
                    const distFromEdgeX = Math.min(node.x, worldWidth - node.x);
                    const distFromEdgeY = Math.min(node.y, worldHeight - node.y);
                    const centralityBonus = (distFromEdgeX + distFromEdgeY) / 200; // 0-10 points
                    
                    // Combined score: value + safety + position
                    const score = economicValue + centralityBonus - fatiguePenalty - captureRisk - threatPenalty;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestNode = node;
                    }
                }
                
                // Relocate if best node is significantly better (threshold to prevent constant moving)
                // OR emergency evacuation (lower threshold when under threat)
                const isEmergency = canEvacuate;
                const threshold = isEmergency ? 0 : 5; // Emergency = relocate even if marginally better
                
                if (bestNode !== nation.capital && bestScore > threshold) {
                    // Demote old capital
                    nation.capital.isCapital = false;
                    nation.capital.economicTier = Math.min(2, nation.capital.economicTier);
                    nation.capital.resourceMultiplier = [0.5, 1.0, 1.5, 2.5][nation.capital.economicTier];
                    
                    // Promote new capital
                    bestNode.isCapital = true;
                    bestNode.economicTier = 3;
                    bestNode.resourceMultiplier = 2.5;
                    nation.capital = bestNode;
                    
                    // Play capital move sound (upgrade vs retreat)
                    Audio.playCapitalMove(bestNode.x, bestNode.y, !isEmergency); // Upgrade sound if not emergency
                    
                    // EVACUATION IMMUNITY: Grant 15 seconds of missile immunity during relocation
                    nation.evacuationImmunity = 15.0;
                    
                    // Track evacuation if emergency
                    if (isEmergency) {
                        nation.capitalEvacuations++;
                        if (nation.capitalEvacuations >= 2) {
                            // Start cooldown (120 seconds)
                            nation.evacuationCooldown = 120.0;
                        }
                    }
                    
                    // Give it a cryptic name if it doesn't have one (before announcing)
                    if (!bestNode.crypticName) {
                        const availableNames = crypticNames.filter(cn => !usedCrypticNames.includes(cn.name));
                        if (availableNames.length > 0) {
                            const nameData = availableNames[Math.floor(Math.random() * availableNames.length)];
                            bestNode.crypticName = nameData.name;
                            bestNode.crypticData = nameData;
                            usedCrypticNames.push(nameData.name);
                        }
                    }
                    
                    // Announce strategic relocation with node name
                    const nodeName = bestNode.crypticName || 'a fortified position';
                    const capitalTerm = nation.capitalTerm || 'core';
                    Audio.announce(`${nation.name} ${capitalTerm} moving to ${nodeName}`, 'high', nation.id);
                }
            });
            
            // PROCESS UNIT QUEUE - spawn queued units when population allows (3 at a time with delay)
            nations.forEach(nation => {
                if (nation.capitulated) return;
                
                // Update spawn timer
                nation.queueSpawnTimer += dt;
                
                // RESURRECTION RAMPING: Faster spawn rate that accelerates over time
                const isResurrected = nation.resurrectionImmunity > 0;
                let spawnDelay = 0.5; // Default: 3 units every 0.5 seconds
                let spawnBatchSize = 3;
                
                if (isResurrected) {
                    // Ramp up spawn rate as immunity time passes
                    const immunityProgress = 1.0 - (nation.resurrectionImmunity / 45); // 0.0 to 1.0
                    
                    // Start slow (0.4s delay, 2 units) and ramp to fast (0.15s delay, 5 units)
                    spawnDelay = 0.4 - (immunityProgress * 0.25); // 0.4s → 0.15s
                    spawnBatchSize = Math.floor(2 + immunityProgress * 3); // 2 → 5 units per batch
                }
                
                // Spawn queued units if there's room and timer is ready
                if (nation.unitQueue > 0 && nation.units.length < MAX_UNIT_COUNT && nation.queueSpawnTimer >= spawnDelay) {
                    // Prioritize capital for spawning, fallback to any friendly node
                    let spawnNode = nation.capital && nation.capital.owner === nation.id ? nation.capital : null;
                    
                    // If no capital, use any friendly node
                    if (!spawnNode) {
                        const friendlyNodes = nodes.filter(n => n.owner === nation.id);
                        if (friendlyNodes.length > 0) {
                            spawnNode = friendlyNodes[Math.floor(Math.random() * friendlyNodes.length)];
                        }
                    }
                    
                    if (spawnNode) {
                        
                        // Spawn up to batch size units at once
                        const spawnCount = Math.min(spawnBatchSize, nation.unitQueue, MAX_UNIT_COUNT - nation.units.length);
                        for (let i = 0; i < spawnCount; i++) {
                            // Find valid spawn position
                            let spawnX, spawnY, attempts = 0;
                            do {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 20 + Math.random() * 10;
                                spawnX = spawnNode.x + Math.cos(angle) * dist;
                                spawnY = spawnNode.y + Math.sin(angle) * dist;
                                attempts++;
                            } while (!isPassable(spawnX, spawnY) && attempts < 20);
                            
                            // Only spawn if valid position found
                            if (isPassable(spawnX, spawnY)) {
                                const unit = new Unit(spawnX, spawnY, nation.id);
                                nation.units.push(unit);
                                nation.unitQueue--;
                            }
                        }
                        
                        // Reset timer after spawning
                        nation.queueSpawnTimer = 0;
                    }
                }
                
                // OVERPOPULATION TIMER - track how long nation has been above optimal
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                const OPTIMAL_UNIT_COUNT = Math.max(50, nodeCount * UNITS_PER_NODE);
                const ratio = nation.units.length / OPTIMAL_UNIT_COUNT;
                if (ratio > 1.0) {
                    // Overpopulated - accumulate time
                    nation.overpopTimer += dt;
                } else {
                    // Below optimal - reset timer
                    nation.overpopTimer = Math.max(0, nation.overpopTimer - dt * 2); // Decay twice as fast
                }
                
                // DECAYING STRENGTH MODIFIER - advantage fades if not maintained
                const targetStrength = calculateTargetStrengthModifier(nation);
                const currentStrength = nation.strengthModifier;
                
                // RESURRECTION IMMUNITY: Maintain desperation buff to establish local security
                const hasResurrectionBuff = nation.resurrectionImmunity > 0;
                
                // Decay toward neutral (1.0) over time, but snap to target if target is MORE extreme
                const decayRate = hasResurrectionBuff ? 0.05 : 0.5; // Much slower decay during resurrection immunity
                
                if (targetStrength > 1.0 && targetStrength > currentStrength) {
                    // Underpopulated and getting worse - quickly boost strength
                    nation.strengthModifier = Math.min(targetStrength, currentStrength + dt * 2.0);
                } else if (targetStrength < 1.0 && targetStrength < currentStrength) {
                    // Overpopulated and getting worse - quickly reduce strength
                    nation.strengthModifier = Math.max(targetStrength, currentStrength - dt * 2.0);
                } else {
                    // Improving or stable - decay toward neutral
                    if (currentStrength > 1.0) {
                        // Losing underdog bonus - decay slowly (much slower if resurrected)
                        const minStrength = hasResurrectionBuff ? 1.5 : 1.0; // Keep at least 50% buff during immunity
                        nation.strengthModifier = Math.max(minStrength, currentStrength - dt * decayRate);
                    } else if (currentStrength < 1.0) {
                        // Losing overcrowding penalty - recover slowly
                        nation.strengthModifier = Math.min(1.0, currentStrength + dt * decayRate);
                    }
                }
            });
            
            // SUPERWEAPON DEVELOPMENT - nations build experimental weapons
            // Goal: 3 superweapons (1 deployed, 1 standby, 1 in repair)
            nations.forEach(nation => {
                if (nation.capitulated) return;
                
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                const mySuperweapons = superweapons.filter(sw => sw.ownerNation === nation.id);
                
                // GLOBAL LIMIT: No more than 3 total superweapons on the field at once
                if (superweapons.length >= 3) {
                    // Field is full - don't build more
                    return;
                }
                
                // Count enemy superweapons in the field
                const enemySuperweapons = superweapons.filter(sw => sw.ownerNation !== nation.id);
                
                // DEPLOYMENT RULES:
                // - Default: Only deploy ONE superweapon at a time
                // - Exception: If 2+ enemy superweapons exist, can match their count
                // - Always maintain stagger delay between deployments (lastSuperweaponDeployTime)
                let desiredCount = 1; // Default: one at a time
                if (enemySuperweapons.length >= 2) {
                    desiredCount = Math.min(enemySuperweapons.length, 3); // Match enemies up to max of 3
                }
                
                // Decrease cooldown
                if (nation.superweaponCooldown > 0) {
                    nation.superweaponCooldown -= dt;
                }
                
                // Initialize last deploy time tracker
                if (!nation.lastSuperweaponDeployTime) nation.lastSuperweaponDeployTime = 0;
                
                // Stagger delay: At least 60 seconds between deployments from same nation (increased from 30s)
                const now = performance.now() / 1000;
                const timeSinceLastDeploy = now - nation.lastSuperweaponDeployTime;
                const canDeployTiming = timeSinceLastDeploy > 60 || nation.lastSuperweaponDeployTime === 0;
                
                // Build progress when not on cooldown and below desired count
                if (nation.superweaponCooldown <= 0 && nodeCount >= 3 && mySuperweapons.length < desiredCount && canDeployTiming) {
                    const bonuses = getArtifactBonuses(nation.id);
                    nation.superweaponProgress += dt * 0.5 * bonuses.superweaponBuild; // Artifact bonus speeds up build
                    
                    // Cap at 100% - only deploy when fully charged OR dire emergency
                    nation.superweaponProgress = Math.min(100, nation.superweaponProgress);
                    
                    // Deploy only at 100% charge unless absolute dire circumstances
                    if (nation.superweaponProgress >= 100) {
                        const capital = nation.capital;
                        if (capital) {
                            // Check for DIRE strategic circumstances
                            const capitalUnderAttack = capital.capturingNation >= 0 && capital.captureProgress > 15;
                            const veryLowNodes = nodeCount <= 3;
                            const enemySupersNearby = superweapons.some(sw => 
                                sw.ownerNation !== nation.id && 
                                Math.hypot(sw.x - capital.x, sw.y - capital.y) < 300
                            );
                            const isDireEmergency = capitalUnderAttack || (veryLowNodes && enemySupersNearby);
                            
                            // Only deploy if 100% charged OR dire emergency with 80%+ charge
                            const canDeploy = nation.superweaponProgress >= 100 || (isDireEmergency && nation.superweaponProgress >= 80);
                            
                            if (canDeploy) {
                                // Choose type based on nation characteristics
                                let type = 'prototype';
                                if (nation.personality.aggressive > 0.7) {
                                    type = 'angel';
                                } else if (nation.personality.defensive > 0.6) {
                                    type = 'eva';
                                }
                                
                                const weapon = new Superweapon(capital.x, capital.y, nation.id, type);
                                superweapons.push(weapon);
                                
                                // Play deployment power-up sound
                                Audio.playSuperweaponDeploy(capital.x, capital.y);
                                
                                // ALWAYS ANNOUNCE SUPERWEAPON DEPLOYMENTS - no rate limiting
                                // Get color name from nation color - MUST match exact hex codes from nationColors
                                const colorMap = {
                                    '#FF0000': 'red', '#00FF00': 'green', '#0080FF': 'blue',
                                    '#FFFF00': 'yellow', '#FF00FF': 'magenta', '#00FFFF': 'cyan',
                                    '#FF8000': 'orange', '#8000FF': 'purple', '#FFFFFF': 'white',
                                    '#808080': 'gray', '#FF0080': 'rose', '#00FF80': 'spring',
                                    '#0080C0': 'deep sky', '#C08000': 'iodine', '#80FF00': 'blueburn',
                                    '#C00000': 'blood red'
                                };
                                const colorName = colorMap[nation.color] || 'unknown';
                                
                                // Announce deployment with fleet status (count includes the one just deployed)
                                const myActiveCount = superweapons.filter(sw => sw.ownerNation === nation.id).length;
                                const fleetStatus = myActiveCount === 1 ? 'first unit' : myActiveCount === 2 ? 'second unit' : 'fleet complete';
                                
                                // Announce emergency deployment if not fully charged
                                if (isDireEmergency && nation.superweaponProgress < 100) {
                                    Audio.announce(`EMERGENCY. ${nation.name} deploys ${weapon.name} at ${Math.floor(nation.superweaponProgress)}% charge`, 'high');
                                } else {
                                    Audio.announce(`Pattern ${colorName}. ${nation.name} deploys ${weapon.name}, ${fleetStatus}`, 'high');
                                }
                                Audio.playTensionSiren();
                                
                                nation.superweaponProgress = 0;
                                nation.superweaponCooldown = 420; // 7 minute cooldown (increased from 5 minutes)
                                nation.lastSuperweaponDeployTime = performance.now() / 1000; // Track deployment time for stagger
                            }
                        }
                    }
                }
            });
            
            // Update superweapons FIRST to calculate attackPower for this frame
            // allUnits already declared above, just reassign it here
            allUnits.length = 0;
            allUnits.push(...nations.flatMap(n => n.units));
            for (let i = superweapons.length - 1; i >= 0; i--) {
                const weapon = superweapons[i];
                if (!weapon.update(dt, allUnits)) {
                    // Superweapon destroyed - MASSIVE DETONATION
                    const effect = weapon.detonate(nations, allUnits, superweapons);
                    if (effect) detonationEffects.push(effect);
                    
                    Audio.announce(`${weapon.name} has detonated!`, 'high');
                    superweapons.splice(i, 1);
                }
            }
            
            // Superweapon AI and COMBAT - runs AFTER update so attackPower is calculated
            // PRIORITY: Enemy superweapons > Enemy capitals > Normal units
            superweapons.forEach(weapon => {
                let bestTarget = null;
                let bestPriority = -1;
                let bestDist = Infinity;
                
                // BERSERK MODE: Maximize casualties before detonation
                if (weapon.berserkDeathPhase) {
                    // Find densest cluster of enemy units for maximum kills
                    let bestClusterCenter = null;
                    let bestClusterDensity = 0;
                    
                    nations.forEach(nation => {
                        if (nation.id !== weapon.ownerNation && !nation.capitulated) {
                            nation.units.forEach(unit => {
                                const dist = Math.hypot(unit.x - weapon.x, unit.y - weapon.y);
                                if (dist <= 400) { // Search radius for targets
                                    // Count nearby allies to this unit (cluster density)
                                    let nearbyCount = 0;
                                    nation.units.forEach(other => {
                                        const clusterDist = Math.hypot(unit.x - other.x, unit.y - other.y);
                                        if (clusterDist <= 60) nearbyCount++;
                                    });
                                    
                                    // Prioritize dense clusters - more kills per detonation
                                    if (nearbyCount > bestClusterDensity) {
                                        bestClusterDensity = nearbyCount;
                                        bestClusterCenter = { type: 'unit', obj: unit, dist, density: nearbyCount };
                                    }
                                }
                            });
                        }
                    });
                    
                    if (bestClusterCenter) {
                        bestTarget = bestClusterCenter;
                    }
                } else {
                    // NORMAL MODE: Strategic targeting
                    // Priority 3 (HIGHEST): Enemy superweapons
                    superweapons.forEach(other => {
                        if (other.ownerNation !== weapon.ownerNation) {
                            const dist = Math.hypot(other.x - weapon.x, other.y - weapon.y);
                            if (bestPriority < 3 || (bestPriority === 3 && dist < bestDist)) {
                                bestPriority = 3;
                                bestDist = dist;
                                bestTarget = { type: 'superweapon', obj: other, dist };
                            }
                        }
                    });
                    
                    // Priority 2: Enemy capitals
                    const enemyCapitals = nodes.filter(n => 
                        n.isCapital && 
                        n.owner >= 0 && 
                        n.owner !== weapon.ownerNation
                    );
                    
                    // Priority 2.5: NODES STORING ARTIFACTS (high-value targets)
                    const artifactStorageNodes = nodes.filter(n => {
                        const stored = artifacts.filter(a => a.storedAtNode === n);
                        return stored.length > 0 && n.owner >= 0 && n.owner !== weapon.ownerNation;
                    });
                    
                    artifactStorageNodes.forEach(node => {
                        const dist = Math.hypot(node.x - weapon.x, node.y - weapon.y);
                        if (bestPriority < 2.5 || (bestPriority === 2.5 && dist < bestDist)) {
                            bestPriority = 2.5;
                            bestDist = dist;
                            bestTarget = { type: 'node', obj: node, dist };
                        }
                    });
                    
                    // Priority 2.4: LOCKED FACILITIES containing valuable items (safes, reactors)
                    const lockedFacilities = artifacts.filter(a => {
                        return (a.type === 'safe' || a.type === 'reactor' || a.type === 'lab') &&
                               !a.isUnlocked && 
                               a.capturedBy !== weapon.ownerNation;
                    });
                    
                    lockedFacilities.forEach(facility => {
                        const dist = Math.hypot(facility.x - weapon.x, facility.y - weapon.y);
                        if (bestPriority < 2.4 || (bestPriority === 2.4 && dist < bestDist)) {
                            bestPriority = 2.4;
                            bestDist = dist;
                            bestTarget = { type: 'facility', obj: facility, dist };
                        }
                    });
                    
                    enemyCapitals.forEach(capital => {
                        const dist = Math.hypot(capital.x - weapon.x, capital.y - weapon.y);
                        if (bestPriority < 2 || (bestPriority === 2 && dist < bestDist)) {
                            bestPriority = 2;
                            bestDist = dist;
                            bestTarget = { type: 'capital', obj: capital, dist };
                        }
                    });
                    
                    // Priority 1.5: Enemy cryptic nodes (strategic locations)
                    const enemyCrypticNodes = nodes.filter(n => 
                        !n.isCapital &&
                        n.crypticName && 
                        n.owner >= 0 && 
                        n.owner !== weapon.ownerNation
                    );
                    
                    enemyCrypticNodes.forEach(node => {
                        const dist = Math.hypot(node.x - weapon.x, node.y - weapon.y);
                        if (bestPriority < 1.5 || (bestPriority === 1.5 && dist < bestDist)) {
                            bestPriority = 1.5;
                            bestDist = dist;
                            bestTarget = { type: 'crypticNode', obj: node, dist };
                        }
                    });
                    
                    // Priority 1: Enemy units (engage if no higher priority target)
                    nations.forEach(nation => {
                        if (nation.id !== weapon.ownerNation && !nation.capitulated) {
                            nation.units.forEach(unit => {
                                const dist = Math.hypot(unit.x - weapon.x, unit.y - weapon.y);
                                // Target nearby units more aggressively - superweapons should engage ground forces
                                if (dist <= 250 && (bestPriority < 1 || (bestPriority === 1 && dist < bestDist))) {
                                    bestPriority = 1;
                                    bestDist = dist;
                                    bestTarget = { type: 'unit', obj: unit, dist };
                                }
                            });
                        }
                    });
                }
                
                // Set movement target toward the chosen threat so superweapons advance
                if (bestTarget) {
                    if (bestTarget.obj.x !== undefined && bestTarget.obj.y !== undefined) {
                        weapon.targetX = bestTarget.obj.x;
                        weapon.targetY = bestTarget.obj.y;
                    }
                }

                // COMBAT: Attack if enemy is in range
                // CRITICAL PHASE: Cannot attack when health below 20% (defenseless, attracts swarms)
                // EXCEPTION: Superweapon vs Superweapon combat ignores critical phase (must finish duel)
                const healthPercent = weapon.health / weapon.maxHealth;
                const inCriticalPhase = healthPercent <= 0.2;
                const isSuperweaponDuel = bestTarget && bestTarget.type === 'superweapon';
                
                if (bestTarget && bestTarget.dist <= weapon.attackRange && weapon.attackCooldown <= 0 && (!inCriticalPhase || isSuperweaponDuel)) {
                    const bonuses = getArtifactBonuses(weapon.ownerNation);
                    // Damage is per-shot; cooldown already gates rate, so do not scale by dt
                    let damage = weapon.attackPower * bonuses.superweaponDamage;
                    
                    if (bestTarget.type === 'superweapon') {
                        // PHASED DUEL SYSTEM: Combat unfolds in stages with positioning dynamics
                        const enemy = bestTarget.obj;
                        const distToEnemy = bestTarget.dist;
                        
                        // Initialize momentum if new duel
                        if (weapon.lastDuelOpponent !== enemy) {
                            weapon.duelMomentum = 0;
                            enemy.duelMomentum = 0;
                            weapon.combatState = 'engaging';
                            weapon.combatStateTimer = 0;
                        }
                        
                        // Update combat state timer
                        weapon.combatStateTimer += dt;
                        
                        // Mark duel participants
                        weapon.lastDuelOpponent = enemy;
                        enemy.lastDuelOpponent = weapon;
                        
                        // COMBAT PHASES: Dynamic engage/parry/retreat/advance based on distance and momentum
                        const closeRange = 60; // Lock range for killing blow
                        const midRange = 120; // Personal space boundary
                        const longRange = 200; // Engagement range
                        
                        // Update combat state based on distance and conditions
                        if (distToEnemy < closeRange) {
                            // CLOSE COMBAT: Locked in, preparing for kill
                            weapon.combatState = 'locked';
                        } else if (distToEnemy < midRange) {
                            // MID RANGE: Active parrying and exchanges
                            if (weapon.health < enemy.health * 0.6) {
                                weapon.combatState = 'retreating'; // Losing, pull back
                            } else if (weapon.duelMomentum > 20) {
                                weapon.combatState = 'advancing'; // Winning, press forward
                            } else {
                                weapon.combatState = 'parrying'; // Even match
                            }
                        } else if (distToEnemy < longRange) {
                            weapon.combatState = 'engaging'; // Moving to combat range
                        }
                        
                        // CRITICAL HIT CHANCE: 8% base (reduced from 15%), increases with momentum
                        // Only ONE can crit per exchange to prevent mutual destruction
                        const weaponCritChance = 0.08 + Math.abs(weapon.duelMomentum) * 0.001;
                        const enemyCritChance = 0.08 + Math.abs(enemy.duelMomentum) * 0.001;
                        const weaponCritRoll = Math.random();
                        const enemyCritRoll = Math.random();
                        
                        // Determine who crits - only the one with better roll (asymmetric)
                        let weaponCrit = false;
                        let enemyCrit = false;
                        if (weaponCritRoll < weaponCritChance && enemyCritRoll < enemyCritChance) {
                            // Both rolled crits - only better roll gets it
                            if (weaponCritRoll < enemyCritRoll) {
                                weaponCrit = true;
                            } else {
                                enemyCrit = true;
                            }
                        } else if (weaponCritRoll < weaponCritChance) {
                            weaponCrit = true;
                        } else if (enemyCritRoll < enemyCritChance) {
                            enemyCrit = true;
                        }
                        
                        // MOMENTUM BONUS: Advantage grants 0-50% extra damage
                        const weaponMomentumBonus = 1.0 + Math.max(0, weapon.duelMomentum) * 0.005;
                        const enemyMomentumBonus = 1.0 + Math.max(0, enemy.duelMomentum) * 0.005;
                        
                        // Calculate damage with variance (80-120%)
                        const weaponRoll = 0.8 + Math.random() * 0.4;
                        const enemyRoll = 0.8 + Math.random() * 0.4;
                        
                        let weaponDamage = damage * weaponRoll * weaponMomentumBonus;
                        let enemyDamage = enemy.attackPower * 0.4 * enemyRoll * enemyMomentumBonus;
                        
                        // CRITICAL HIT: 2.0x damage + momentum swing (reduced from 2.5x)
                        if (weaponCrit) {
                            weaponDamage *= 2.0;
                            weapon.duelMomentum = Math.min(100, weapon.duelMomentum + 20);
                            enemy.duelMomentum = Math.max(-100, enemy.duelMomentum - 20);
                            Audio.announce(`${weapon.name} scores critical hit on ${enemy.name}!`, 'high');
                        }
                        if (enemyCrit) {
                            enemyDamage *= 2.0;
                            enemy.duelMomentum = Math.min(100, enemy.duelMomentum + 20);
                            weapon.duelMomentum = Math.max(-100, weapon.duelMomentum - 20);
                            Audio.announce(`${enemy.name} lands critical hit on ${weapon.name}!`, 'high');
                        }
                        
                        // Apply damage
                        enemy.takeDamage(weaponDamage);
                        weapon.takeDamage(enemyDamage);
                        Audio.playHit(weapon.x, weapon.y, 3.0);
                        
                        // WEAPON EFFECTS: Visual attack beams
                        if (!weapon.attackEffect) weapon.attackEffect = { timer: 0 };
                        if (!enemy.attackEffect) enemy.attackEffect = { timer: 0 };
                        
                        weapon.attackEffect = {
                            timer: 0.15, // 150ms flash
                            targetX: enemy.x,
                            targetY: enemy.y,
                            type: weapon.type
                        };
                        
                        enemy.attackEffect = {
                            timer: 0.15,
                            targetX: weapon.x,
                            targetY: weapon.y,
                            type: enemy.type
                        };
                        
                        // BUILD MOMENTUM: Winning builds advantage, losing allows comeback
                        const netDamage = weaponDamage - enemyDamage;
                        if (netDamage > 0) {
                            // Weapon winning - build momentum (reduced from 8 to 6)
                            weapon.duelMomentum = Math.min(100, weapon.duelMomentum + 6);
                            enemy.duelMomentum = Math.max(-100, enemy.duelMomentum - 6);
                        } else if (netDamage < 0) {
                            // Enemy winning - build their momentum
                            enemy.duelMomentum = Math.min(100, enemy.duelMomentum + 6);
                            weapon.duelMomentum = Math.max(-100, weapon.duelMomentum - 6);
                        }
                        
                        // COMEBACK MECHANIC: Desperate last stand at <30% HP grants damage boost
                        const weaponHealthPercent = weapon.health / weapon.maxHealth;
                        const enemyHealthPercent = enemy.health / enemy.maxHealth;
                        if (weaponHealthPercent < 0.3 && weaponHealthPercent > 0) {
                            weapon.attackPower = weapon.baseAttackPower * 1.5; // 50% damage boost when desperate
                        }
                        if (enemyHealthPercent < 0.3 && enemyHealthPercent > 0) {
                            enemy.attackPower = enemy.baseAttackPower * 1.5;
                        }
                        
                        // CLOSE RANGE KILL: Only allow kills when locked at close range
                        const isLockedCombat = weapon.combatState === 'locked' || enemy.combatState === 'locked';
                        
                        if (isLockedCombat && distToEnemy < closeRange) {
                            // KILLING BLOW: Check for death and trigger detonation
                            if (enemy.health <= 0 && weapon.health > 0) {
                                weapon.duelImmunityTimer = 5.0;
                                weapon.duelMomentum = 0;
                                weapon.combatState = 'idle';
                                // Enemy will detonate in their update loop
                            }
                            if (weapon.health <= 0 && enemy.health > 0) {
                                enemy.duelImmunityTimer = 5.0;
                                enemy.duelMomentum = 0;
                                enemy.combatState = 'idle';
                                // Weapon will detonate in their update loop
                            }
                            // If BOTH would die this hit, save the one with momentum advantage
                            if (enemy.health <= 0 && weapon.health <= 0) {
                                if (weapon.duelMomentum > enemy.duelMomentum) {
                                    weapon.health = 50; // Survivor barely lives
                                    weapon.duelImmunityTimer = 5.0;
                                    weapon.combatState = 'retreating';
                                    Audio.announce(`${weapon.name} survives!`, 'high');
                                } else {
                                    enemy.health = 50;
                                    enemy.duelImmunityTimer = 5.0;
                                    enemy.combatState = 'retreating';
                                    Audio.announce(`${enemy.name} survives!`, 'high');
                                }
                            }
                        } else if (!isLockedCombat && (enemy.health <= 0 || weapon.health <= 0)) {
                            // NOT LOCKED: Cannot kill at long range - stabilize at 1 HP
                            if (enemy.health <= 0) {
                                enemy.health = 1;
                                enemy.combatState = 'retreating'; // Force retreat
                            }
                            if (weapon.health <= 0) {
                                weapon.health = 1;
                                weapon.combatState = 'retreating'; // Force retreat
                            }
                        }
                        
                        // Refresh duel immunity for ongoing combat
                        weapon.duelImmunityTimer = Math.max(weapon.duelImmunityTimer, 3.0);
                        enemy.duelImmunityTimer = Math.max(enemy.duelImmunityTimer, 3.0);
                        
                        // Announce superweapon battle (with cooldown)
                        const now = Date.now();
                        if (!weapon.battleAnnounced && now - announcerState.lastSuperweaponBattle > 20000) {
                            Audio.announce(`${weapon.name} engaging ${bestTarget.obj.name}!`, 'high');
                            weapon.battleAnnounced = true;
                            announcerState.lastSuperweaponBattle = now;
                        }
                    } else if (bestTarget.type === 'unit') {
                        // Superweapon vs Unit - devastating area attack that wipes out groups
                        const targetUnit = bestTarget.obj;
                        const targetNation = nations[nations.findIndex(n => n.units.includes(targetUnit))];
                        
                        // Trigger stab animation if wielding spear
                        if (weapon.carriedSpear) {
                            weapon.stabAnimationTimer = 0.3; // 300ms stab animation
                            weapon.stabDirection = Math.atan2(bestTarget.obj.y - weapon.y, bestTarget.obj.x - weapon.x);
                        }
                        
                        // Area damage - superweapon attacks hit multiple units
                        if (targetNation) {
                            const areaRadius = 60; // Larger splash radius - superweapons are devastating
                            targetNation.units.forEach(unit => {
                                const dist = Math.hypot(unit.x - weapon.x, unit.y - weapon.y);
                                if (dist <= areaRadius) {
                                    const falloff = 1.0 - (dist / areaRadius) * 0.5; // 50-100% damage based on distance
                                    unit.health -= damage * falloff * 4.0; // 4x damage to units - truly devastating
                                }
                            });
                        }
                        
                        Audio.playHit(weapon.x, weapon.y, 2.5);
                        
                        // WEAPON EFFECT: Visual attack
                        if (!weapon.attackEffect) weapon.attackEffect = { timer: 0 };
                        weapon.attackEffect = {
                            timer: 0.2, // 200ms flash
                            targetX: targetUnit.x,
                            targetY: targetUnit.y,
                            type: weapon.type
                        };
                        
                        // All nearby units retaliate together (combined arms)
                        let totalRetaliation = 0;
                        if (targetNation) {
                            targetNation.units.forEach(unit => {
                                const dist = Math.hypot(unit.x - weapon.x, unit.y - weapon.y);
                                if (dist <= weapon.attackRange) {
                                    const unitDamage = unit.attackPower || unit.strength * 5;
                                    totalRetaliation += unitDamage * 0.1; // Each unit adds 10% damage
                                }
                            });
                        }
                        weapon.takeDamage(totalRetaliation);
                    } else if (bestTarget.type === 'facility') {
                        // Superweapon attacking locked facility - break it open
                        Audio.playHit(weapon.x, weapon.y, 2.0);
                        
                        const targetFacility = bestTarget.obj;
                        
                        // Superweapons can break into locked facilities (crack them open)
                        if (!targetFacility.isUnlocked) {
                            if (!targetFacility.unlockProgress) targetFacility.unlockProgress = 0;
                            
                            // Fast breach - 10 seconds for superweapon to break in
                            targetFacility.unlockProgress += dt * 10; // 10% per second
                            
                            if (targetFacility.unlockProgress >= 100) {
                                // BREACHED! Facility is forcefully unlocked
                                targetFacility.isUnlocked = true;
                                targetFacility.isSecureLocked = false;
                                targetFacility.crackingNation = undefined;
                                
                                const ownerNation = nations[weapon.ownerNation];
                                if (ownerNation) {
                                    Audio.announce(`${ownerNation.name} superweapon breaches ${targetFacility.name}!`, 'high', weapon.ownerNation);
                                }
                                
                                // Spawn contents if not already spawned
                                if (!targetFacility.hasSpawnedContents) {
                                    if (targetFacility.type === 'lab') {
                                        const data = new SpecialArtifact(targetFacility.x, targetFacility.y, 'data');
                                        data.hasSpawned = true;
                                        artifacts.push(data);
                                    } else if (targetFacility.type === 'safe') {
                                        const existingSpear = artifacts.find(a => a.type === 'spear');
                                        if (!existingSpear) {
                                            const spear = new SpecialArtifact(targetFacility.x, targetFacility.y, 'spear');
                                            spear.containerArtifact = targetFacility;
                                            spear.hasSpawned = true;
                                            artifacts.push(spear);
                                            if (ownerNation) {
                                                Audio.announce(`${ownerNation.name} finds Spear of Longitude inside!`, 'high', weapon.ownerNation);
                                            }
                                        }
                                    } else if (targetFacility.type === 'reactor') {
                                        const proto = new SpecialArtifact(targetFacility.x, targetFacility.y, 'prototype');
                                        proto.containerArtifact = targetFacility;
                                        proto.hasSpawned = true;
                                        artifacts.push(proto);
                                    }
                                    targetFacility.hasSpawnedContents = true;
                                }
                                
                                // Facility becomes neutral after breach
                                targetFacility.capturedBy = -1;
                                targetFacility.captureProgress = 0;
                            }
                        }
                    } else if (bestTarget.type === 'capital') {
                        // Superweapon attacking capital - devastating damage over time
                        Audio.playHit(weapon.x, weapon.y, 2.5);

                        const targetNode = bestTarget.obj;
                        const captureThreshold = targetNode.isCapital ? 36 : 30;
                        let defensiveMultiplier = 1.0;
                        if (targetNode.crypticName === 'Citadel') defensiveMultiplier = 1.4;
                        if (targetNode.crypticName === 'Bastion') defensiveMultiplier = 1.6;
                        const adjustedThreshold = captureThreshold * defensiveMultiplier;

                        // Rapid, devastating structural damage - superweapons destroy capitals quickly
                        targetNode.capturingNation = weapon.ownerNation;
                        targetNode.captureProgress = Math.min(adjustedThreshold, targetNode.captureProgress + 12.0);
                        targetNode.controlStrength = Math.max(0, targetNode.controlStrength - 0.15);
                        targetNode.fatigue = Math.min(100, targetNode.fatigue + 2.0);

                        // When the threshold is reached, DESTROY the capital with detonation
                        if (targetNode.captureProgress >= adjustedThreshold) {
                            const formerOwner = targetNode.owner;
                            const ownerNation = nations[formerOwner];
                            const attackerNation = nations[weapon.ownerNation];
                            
                            // INSTANT CAPITAL DETONATION
                            if (!ownerNation.capitulated) {
                                Audio.announce(`${ownerNation.name} capital destroyed by ${attackerNation.name}'s ${weapon.name}: eliminated`, 'high', weapon.ownerNation);
                            }
                            Audio.playSelfDestruct(targetNode.x, targetNode.y);
                            
                            // Capital detonation effect (same as self-destruct: 30 radius)
                            const capitalDetonationRadius = 30;
                            const capitalDetonationDamage = 150;
                            
                            // Damage nearby units from all nations
                            nations.forEach(nation => {
                                nation.units.forEach(u => {
                                    const dist = Math.hypot(u.x - targetNode.x, u.y - targetNode.y);
                                    if (dist < capitalDetonationRadius) {
                                        const falloff = 1.0 - (dist / capitalDetonationRadius);
                                        u.health -= capitalDetonationDamage * falloff;
                                    }
                                });
                            });
                            
                            // Create visual effect
                            detonationEffects.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: 0,
                                maxRadius: capitalDetonationRadius * 2.0,
                                alpha: 1.0,
                                duration: 3.0,
                                timer: 0,
                                particles: Array.from({ length: 20 }, () => ({
                                    angle: Math.random() * Math.PI * 2,
                                    speed: 60 + Math.random() * 80,
                                    distance: 0,
                                    maxDistance: capitalDetonationRadius * (0.8 + Math.random() * 0.6),
                                    size: 1 + Math.random() * 3,
                                    rotation: Math.random() * Math.PI * 2,
                                    rotationSpeed: (Math.random() - 0.5) * 8
                                }))
                            });
                            
                            // Create crater
                            craters.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: capitalDetonationRadius * 1.2,
                                createdAt: Date.now(),
                                age: 0
                            });
                            
                            // Destroy the capital and capitulate the nation
                            targetNode.owner = -1;
                            targetNode.isCapital = false;
                            targetNode.capturingNation = -1;
                            targetNode.captureProgress = 0;
                            ownerNation.capital = null;
                            ownerNation.capitulated = true;
                            ownerNation.capitulationTime = 0;
                            ownerNation.rebellionTimer = 0;
                            ownerNation.rebellionCooldown = 90.0;
                            // Track elimination count for resurrection queue
                            if (!ownerNation.eliminationCount) ownerNation.eliminationCount = 0;
                            ownerNation.eliminationCount += 1;
                            
                            // Mark node for removal
                            targetNode.markedForDestruction = true;
                        }
                    } else if (bestTarget.type === 'crypticNode') {
                        // Superweapon attacking strategic node - overwhelming firepower
                        Audio.playHit(weapon.x, weapon.y, 2.0);

                        const targetNode = bestTarget.obj;
                        const captureThreshold = 30;
                        let defensiveMultiplier = 1.0;
                        if (targetNode.crypticName === 'Citadel') defensiveMultiplier = 1.4;
                        if (targetNode.crypticName === 'Bastion') defensiveMultiplier = 1.6;
                        const adjustedThreshold = captureThreshold * defensiveMultiplier;

                        // Superweapons rapidly overwhelm strategic nodes with devastating firepower
                        targetNode.capturingNation = weapon.ownerNation;
                        targetNode.captureProgress = Math.min(adjustedThreshold, targetNode.captureProgress + 15.0);
                        targetNode.controlStrength = Math.max(0, targetNode.controlStrength - 0.20);
                        targetNode.fatigue = Math.min(100, targetNode.fatigue + 2.5);

                        // When threshold reached, DESTROY the node with explosion
                        if (targetNode.captureProgress >= adjustedThreshold) {
                            const formerOwner = targetNode.owner;
                            const nodeName = targetNode.crypticName || 'node';
                            const attackerNation = nations[weapon.ownerNation];
                            
                            // Smaller explosion than capital (radius 20 instead of 30)
                            const explosionRadius = 20;
                            const explosionDamage = 100;
                            
                            // Damage nearby units
                            nations.forEach(nation => {
                                nation.units.forEach(u => {
                                    const dist = Math.hypot(u.x - targetNode.x, u.y - targetNode.y);
                                    if (dist < explosionRadius) {
                                        const falloff = 1.0 - (dist / explosionRadius);
                                        u.health -= explosionDamage * falloff;
                                    }
                                });
                            });
                            
                            // Create smaller visual effect
                            detonationEffects.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: 0,
                                maxRadius: explosionRadius * 2.0,
                                alpha: 1.0,
                                duration: 2.0,
                                timer: 0,
                                particles: Array.from({ length: 12 }, () => ({
                                    angle: Math.random() * Math.PI * 2,
                                    speed: 40 + Math.random() * 60,
                                    distance: 0,
                                    maxDistance: explosionRadius * (0.8 + Math.random() * 0.6),
                                    size: 1 + Math.random() * 2,
                                    rotation: Math.random() * Math.PI * 2,
                                    rotationSpeed: (Math.random() - 0.5) * 6
                                }))
                            });
                            
                            // Create smaller crater
                            craters.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: explosionRadius * 1.2,
                                createdAt: Date.now(),
                                age: 0
                            });
                            
                            if (formerOwner >= 0 && formerOwner < nations.length && nations[formerOwner] && attackerNation && !attackerNation.capitulated) {
                                const now = Date.now();
                                if (now - announcerState.lastSuperweaponBattle > 20000) {
                                    Audio.announce(`Our ${weapon.name} destroyed ${nations[formerOwner].name}'s ${nodeName}`, 'high', weapon.ownerNation);
                                    announcerState.lastSuperweaponBattle = now;
                                }
                            }
                            
                            // Mark node for destruction
                            targetNode.markedForDestruction = true;
                        }
                    } else if (bestTarget.type === 'node') {
                        // Superweapon attacking node - high-value target
                        Audio.playHit(weapon.x, weapon.y, 2.0);

                        const targetNode = bestTarget.obj;
                        const captureThreshold = 30;
                        let defensiveMultiplier = 1.0;
                        if (targetNode.crypticName === 'Citadel') defensiveMultiplier = 1.4;
                        if (targetNode.crypticName === 'Bastion') defensiveMultiplier = 1.6;
                        const adjustedThreshold = captureThreshold * defensiveMultiplier;

                        // Rapid damage to overwhelm nodes
                        targetNode.capturingNation = weapon.ownerNation;
                        targetNode.captureProgress = Math.min(adjustedThreshold, targetNode.captureProgress + 15.0);
                        targetNode.controlStrength = Math.max(0, targetNode.controlStrength - 0.20);
                        targetNode.fatigue = Math.min(100, targetNode.fatigue + 2.5);

                        // When threshold reached, DESTROY the node
                        if (targetNode.captureProgress >= adjustedThreshold) {
                            const formerOwner = targetNode.owner;
                            const attackerNation = nations[weapon.ownerNation];
                            
                            // Smaller explosion (radius 20)
                            const explosionRadius = 20;
                            const explosionDamage = 100;
                            
                            // Damage nearby units
                            nations.forEach(nation => {
                                nation.units.forEach(u => {
                                    const dist = Math.hypot(u.x - targetNode.x, u.y - targetNode.y);
                                    if (dist < explosionRadius) {
                                        const falloff = 1.0 - (dist / explosionRadius);
                                        u.health -= explosionDamage * falloff;
                                    }
                                });
                            });
                            
                            // Create smaller visual effect
                            detonationEffects.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: 0,
                                maxRadius: explosionRadius * 2.0,
                                alpha: 1.0,
                                duration: 2.0,
                                timer: 0,
                                particles: Array.from({ length: 12 }, () => ({
                                    angle: Math.random() * Math.PI * 2,
                                    speed: 40 + Math.random() * 60,
                                    distance: 0,
                                    maxDistance: explosionRadius * (0.8 + Math.random() * 0.6),
                                    size: 1 + Math.random() * 2,
                                    rotation: Math.random() * Math.PI * 2,
                                    rotationSpeed: (Math.random() - 0.5) * 6
                                }))
                            });
                            
                            // Create smaller crater
                            craters.push({
                                x: targetNode.x,
                                y: targetNode.y,
                                radius: explosionRadius * 1.2,
                                createdAt: Date.now(),
                                age: 0
                            });
                            
                            // Mark node for destruction
                            targetNode.markedForDestruction = true;
                        }
                    }
                    
                    weapon.attackCooldown = 2.5; // Slower combat - was 1.0
                }
            });
            
            // Update and draw detonation effects
            for (let i = detonationEffects.length - 1; i >= 0; i--) {
                const effect = detonationEffects[i];
                effect.timer += dt;
                
                if (effect.timer >= effect.duration) {
                    detonationEffects.splice(i, 1);
                } else {
                    const progress = effect.timer / effect.duration;
                    
                    // Multi-stage expansion
                    if (progress < 0.1) {
                        // Initial flash - instant bright expansion
                        effect.radius = effect.maxRadius * 0.3 * (progress / 0.1);
                        effect.alpha = 1.5; // Overbright flash
                    } else if (progress < 0.25) {
                        // Shockwave ring - rapid expansion
                        const ringProgress = (progress - 0.1) / 0.15;
                        effect.radius = effect.maxRadius * (0.3 + 0.7 * ringProgress);
                        effect.alpha = 1.2 - ringProgress * 0.4;
                    } else {
                        // Fireball - slow expansion and fade
                        const fireProgress = (progress - 0.25) / 0.75;
                        effect.radius = effect.maxRadius * (1.0 + fireProgress * 0.3);
                        effect.alpha = 0.8 - fireProgress * 0.8;
                    }
                    
                    // Update debris particles
                    if (effect.particles) {
                        effect.particles.forEach(p => {
                            if (p.distance < p.maxDistance) {
                                p.distance += p.speed * dt;
                                p.rotation += p.rotationSpeed * dt;
                            }
                        });
                    }
                }
            }
            
            // Store for rendering later
            game.detonationEffects = detonationEffects;
            
            // Update artifacts with degradation system
            const currentTime = performance.now() / 1000;
            artifacts.forEach(artifact => {
                // DEGRADATION SYSTEM - Research Data and Blueprints degrade over time
                if (artifact.degradationTime > 0) {
                    if (!artifact.createdAt || artifact.createdAt === 0) {
                        artifact.createdAt = currentTime;
                    }
                    
                    const age = currentTime - artifact.createdAt;
                    const degradationThreshold1 = artifact.degradationTime * 0.67; // 2/3 through
                    const degradationThreshold2 = artifact.degradationTime; // End
                    
                    if (age >= degradationThreshold2 && artifact.degradationStage < 2) {
                        // TRASH - worthless now
                        artifact.degradationStage = 2;
                        artifact.qualityMultiplier = 0.0;
                        const trashNames = { 'data': 'Outdated Data (trash)', 'blueprint': 'Obsolete Blueprint (trash)', 'plans': 'Obsolete Plans (trash)' };
                        artifact.name = trashNames[artifact.type] || 'Obsolete Item (trash)';
                        artifact.color = '#444444';
                        artifact.shouldRemove = true; // Mark for removal
                        
                        if (artifact.capturedBy >= 0) {
                            const nation = nations[artifact.capturedBy];
                            if (nation) {
                                const announceNames = { 'data': 'Research Data', 'blueprint': 'Advanced Blueprint', 'plans': 'Strategic Plans' };
                                const itemName = announceNames[artifact.type] || 'Artifact';
                                const verb = itemName.includes('Data') || itemName.includes('Plans') ? 'have' : 'has';
                                Audio.announce(`${itemName} ${verb} become outdated`, 'low', artifact.capturedBy);
                            }
                        }
                    } else if (age >= degradationThreshold1 && artifact.degradationStage < 1) {
                        // DEGRADED - reduced quality
                        artifact.degradationStage = 1;
                        artifact.qualityMultiplier = 0.5;
                        const baseNames = { 'data': 'Research Data', 'blueprint': 'Advanced Blueprint', 'plans': 'Strategic Plans' };
                        const baseName = baseNames[artifact.type] || 'Artifact';
                        artifact.name = baseName + ' (degraded)';
                        artifact.color = '#666666';
                        
                        if (artifact.capturedBy >= 0 && artifact.storedAtNode) { // Only announce if captured and stored
                            const nation = nations[artifact.capturedBy];
                            if (nation && !artifact.degradedAnnounced) {
                                artifact.degradedAnnounced = true;
                                const degradeVerb = baseName.includes('Data') || baseName.includes('Plans') ? 'are' : 'is';
                                Audio.announce(`${baseName} ${degradeVerb} degrading`, 'low', artifact.capturedBy);
                            }
                        }
                    }
                }
                
                artifact.update(dt);
            });
            
            // Remove consumed/degraded artifacts
            artifacts = artifacts.filter(a => !a.shouldRemove);
            
            // === ARTIFACT GENERATION at special nodes ===
            nodes.forEach(node => {
                if (node.owner >= 0 && node.crypticData) {
                    const nation = nations[node.owner];
                    if (!nation || nation.capitulated) return;
                    
                    // Initialize generation timer if needed
                    if (!node.artifactGenerationTimer) node.artifactGenerationTimer = 0;
                    
                    // Check if Keycode is decrypted (for Blueprint generation)
                    const keycodeDecrypted = artifacts.some(a => 
                        a.type === 'keycode' && 
                        a.capturedBy === node.owner && 
                        a.isDecrypted
                    );
                    
                    // Generate artifacts based on node buff type
                    if (node.crypticData.buff === 'Movement Hub') {
                        // Nexus generates Strategic Plans every 2.5 minutes
                        node.artifactGenerationTimer += dt;
                        if (node.artifactGenerationTimer >= 150) {
                            node.artifactGenerationTimer = 0;
                            artifacts.push(new SpecialArtifact(node.x, node.y, 'plans'));
                            Audio.announce(`${nation.name} generates Strategic Plans at ${node.crypticName}`, 'medium', node.owner);
                        }
                    } else if (node.crypticData.buff === 'Efficiency' && keycodeDecrypted) {
                        // Forge generates Advanced Blueprint every 3 minutes (ONLY if Keycode is decrypted)
                        node.artifactGenerationTimer += dt;
                        if (node.artifactGenerationTimer >= 180) {
                            node.artifactGenerationTimer = 0;
                            artifacts.push(new SpecialArtifact(node.x, node.y, 'blueprint'));
                            Audio.announce(`${nation.name} generates Advanced Blueprint at ${node.crypticName}`, 'medium', node.owner);
                        }
                    }
                    // Note: Lab (Research Data generation) is handled inside Lab artifact update
                }
            });
            
            // FATIGUE SYSTEM DISABLED - was causing crashes
            // Nations fight to the bitter end without fatigue collapse
            
            // Artillery available to all nations - frequency decreases as more strikes are active
            nations.forEach(nation => {
                if (nation.capitulated) return;
                
                const unitCount = nation.units.length;
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                
                // Everyone gets artillery, but frequency/power/accuracy scales with population
                if (nodeCount > 0 && unitCount > 0) {
                    // Initialize magazine if needed
                    if (!nation.artilleryMagazine) nation.artilleryMagazine = 0;
                    
                    // Calculate population ratio based on dynamic optimal
                    const OPTIMAL_UNIT_COUNT = Math.max(50, nodeCount * UNITS_PER_NODE);
                    const popRatio = unitCount / OPTIMAL_UNIT_COUNT;
                    
                    // MAGAZINE BONUS: More stuck units = more artillery available
                    // Each unit in magazine adds 10% to fire rate, capped at +200%
                    const magazineBonus = Math.min(2.0, nation.artilleryMagazine * 0.1);
                    
                    // FRONTLINE STABILITY: Check if frontlines are stable (not much movement)
                    // More stable = more artillery (dug-in warfare)
                    let stabilityBonus = 0;
                    let totalMovement = 0;
                    for (let unit of nation.units) {
                        totalMovement += Math.hypot(unit.vx, unit.vy);
                    }
                    const avgMovement = totalMovement / Math.max(1, nation.units.length);
                    // Low movement (< 0.3) = frontline is stable, up to +100% artillery
                    if (avgMovement < 0.3) {
                        stabilityBonus = (0.3 - avgMovement) / 0.3; // 0-1.0
                    }
                    
                    // FREQUENCY: Low pop = MUCH more frequent (inverse squared), High pop = less frequent
                    // At 50 units (0.5 ratio): 4.0x frequency (was 2.0x)
                    // At 100 units (1.0 ratio): 1.0x frequency
                    // At 200 units (2.0 ratio): 0.25x frequency (was 0.5x)
                    const frequencyMultiplier = 1.0 / (popRatio * popRatio);
                    
                    // ACCURACY: Low pop = VERY inaccurate/spread out, High pop = precise
                    // At 50 units: 120 unit inaccuracy radius (doubled from 60)
                    // At 100 units: 60 unit inaccuracy radius (doubled from 30)
                    // At 200 units: 30 unit inaccuracy radius (doubled from 15)
                    const baseInaccuracy = 60 / popRatio;
                    
                    // DAMAGE: Low pop = POWERFUL (inverse), High pop = weaker
                    // At 50 units: 2.0x damage (was 0.5x)
                    // At 100 units: 1.0x damage
                    // At 200 units: 0.5x damage (was 2.0x)
                    const damageMultiplier = 1.0 / popRatio;
                    
                    const baseRate = 0.5; // Base rate - reduced from 3 to 0.5 to reduce spam
                    // Apply magazine and stability bonuses
                    const strikeChance = dt * baseRate * frequencyMultiplier * (1 + magazineBonus + stabilityBonus);
                    
                    if (Math.random() < strikeChance) {
                        // Find enemy units near this nation's frontline - use cached nodes
                        const myNodes = nation.cachedMyNodes || [];
                        if (myNodes.length === 0) return;
                        
                        // Pick a random owned node to support
                        const defendNode = myNodes[Math.floor(Math.random() * myNodes.length)];
                        const searchRadius = 150;
                        
                        // Find enemy units near this node that are on the frontline
                        let enemyTargets = [];
                        nations.forEach(enemyNation => {
                            if (enemyNation.id === nation.id || enemyNation.capitulated) return;
                            
                            enemyNation.units.forEach(unit => {
                                const dist = Math.hypot(unit.x - defendNode.x, unit.y - defendNode.y);
                                if (dist < searchRadius) {
                                    // Check if this enemy unit is near the frontline (has friendly units in detection range)
                                    let isNearFrontline = false;
                                    const frontlineRadius = 100; // Wider detection for frontline proximity
                                    
                                    for (let friendlyUnit of nation.units) {
                                        const engageDist = Math.hypot(friendlyUnit.x - unit.x, friendlyUnit.y - unit.y);
                                        if (engageDist < frontlineRadius) {
                                            isNearFrontline = true;
                                            break;
                                        }
                                    }
                                    
                                    // Only target enemies near the frontline
                                    if (isNearFrontline) {
                                        enemyTargets.push({ unit, nation: enemyNation.id });
                                    }
                                }
                            });
                        });
                        
                        // Strike a random enemy concentration with population-scaled parameters
                        // Safety checks scale with population - low pop more reckless, high pop cautious
                        if (enemyTargets.length > 0) {
                            const target = enemyTargets[Math.floor(Math.random() * enemyTargets.length)];
                            
                            // VULNERABILITY: Lab intel leak makes artillery 20% more accurate against you
                            let inaccuracy = baseInaccuracy;
                            const targetArtifactBonuses = getArtifactBonuses(target.nation);
                            if (targetArtifactBonuses.intelLeak) {
                                inaccuracy *= 0.8; // 20% more accurate (smaller spread)
                            }
                            
                            const blastRadius = 25;
                            
                            // Find closest friendly to target
                            let closestFriendlyDist = Infinity;
                            for (let friendlyUnit of nation.units) {
                                const distToBlast = Math.hypot(friendlyUnit.x - target.unit.x, friendlyUnit.y - target.unit.y);
                                if (distToBlast < closestFriendlyDist) {
                                    closestFriendlyDist = distToBlast;
                                }
                            }
                            
                            // Minimum safe distance based on population
                            // Low pop (50 units): only blast radius (25 units) - very risky
                            // Normal pop (100 units): blast radius + quarter inaccuracy (40 units)
                            // High pop (200 units): blast radius + half inaccuracy (55 units) - very safe
                            const safetyMargin = inaccuracy * 0.25; // Quarter instead of half
                            const minSafeDistance = blastRadius + safetyMargin;
                            
                            // Check if artillery would fire over mountains (blocked)
                            const capitalX = nation.capital ? nation.capital.x : 0;
                            const capitalY = nation.capital ? nation.capital.y : 0;
                            const targetX = target.unit.x;
                            const targetY = target.unit.y;
                            const dx = targetX - capitalX;
                            const dy = targetY - capitalY;
                            const distance = Math.hypot(dx, dy);
                            
                            // Check 10 points along trajectory for mountains
                            let mountainBlocked = false;
                            for (let i = 1; i < 10; i++) {
                                const t = i / 10;
                                const checkX = capitalX + dx * t;
                                const checkY = capitalY + dy * t;
                                if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                                    mountainBlocked = true;
                                    break;
                                }
                            }
                            
                            // Fire if safe enough AND not blocked by mountains
                            if (closestFriendlyDist > minSafeDistance && !mountainBlocked) {
                                artillery.push(new Artillery(
                                    target.unit.x, 
                                    target.unit.y, 
                                    nation.id, 
                                    target.nation,
                                    damageMultiplier,
                                    inaccuracy
                                ));
                                
                                // Consume one unit from artillery magazine
                                if (nation.artilleryMagazine > 0) {
                                    nation.artilleryMagazine--;
                                }
                            }
                        }
                    }
                }
            });
            
            // Update artillery
            for (let i = artillery.length - 1; i >= 0; i--) {
                if (!artillery[i].update(dt, nations)) {
                    artillery.splice(i, 1);
                }
            }
            
            // Check for capitulation
            const capitulatedThisFrame = [];
            nations.forEach(nation => {
                // Decrement resurrection immunity
                if (nation.resurrectionImmunity > 0) {
                    nation.resurrectionImmunity = Math.max(0, nation.resurrectionImmunity - dt);
                }
                
                // Decrement evacuation immunity
                if (nation.evacuationImmunity > 0) {
                    nation.evacuationImmunity = Math.max(0, nation.evacuationImmunity - dt);
                }
                
                // Decrement missile launch cooldown
                if (nation.missileLaunchCooldown > 0) {
                    nation.missileLaunchCooldown = Math.max(0, nation.missileLaunchCooldown - dt);
                }
                
                // Can't capitulate during resurrection immunity
                if (!nation.capitulated && nation.capital && nation.capital.owner !== nation.id && nation.resurrectionImmunity <= 0) {
                    // Capital has fallen!
                    const captorNation = nation.capital.owner;
                    nation.capitulated = true;
                    capitulatedThisFrame.push(nation.name);
                    
                    // DROP ALL CARRIED ARTIFACTS and transfer ownership
                    let capturedArtifacts = [];
                    artifacts.forEach(artifact => {
                        if (artifact.capturedBy === nation.id) {
                            // Drop if being carried - CLEAR BOTH PROPERTIES
                            if (artifact.carrier) {
                                if (artifact.type === 'spear' && artifact.carrier.carriedSpear === artifact) {
                                    artifact.carrier.carriedSpear = null;
                                }
                                artifact.carrier = null;
                                // Artifact remains at current position (where carrier died)
                            }
                            
                            // Transfer ownership
                            artifact.capturedBy = (captorNation >= 0 && nations[captorNation] && !nations[captorNation].capitulated) 
                                ? captorNation 
                                : -1;
                            artifact.hasAnnounced = false;
                            artifact.captureProgress = 0;
                            
                            // Update node inventory if stored
                            if (artifact.storedAtNode) {
                                // Ownership transfer happens automatically via node capture
                                // Node inventory stays with the node
                            }
                            
                            capturedArtifacts.push(artifact.name);
                        }
                    });
                    
                    // Announce captured inventory only if captor is valid
                    if (captorNation >= 0 && captorNation < nations.length && nations[captorNation] && !nations[captorNation].capitulated && capturedArtifacts.length > 0) {
                        const captorName = nations[captorNation].name;
                        if (capturedArtifacts.length === 1) {
                            Audio.announce(`${captorName} seizes ${nation.name}'s ${capturedArtifacts[0]}`, 'high', captorNation);
                        } else {
                            Audio.announce(`${captorName} seizes ${nation.name}'s arsenal: ${capturedArtifacts.length} artifacts`, 'high', captorNation);
                        }
                    }
                    
                    // Remove all pending announcements from this nation
                    // Filter out announcements that start with this nation's name (they're the subject)
                    announcerState.priorityQueue = announcerState.priorityQueue.filter(text => 
                        typeof text === 'string' && !text.startsWith(nation.name)
                    );
                    announcerState.normalQueue = announcerState.normalQueue.filter(text => 
                        typeof text === 'string' && !text.startsWith(nation.name)
                    );
                    
                    // All owned nodes go neutral
                    nodes.forEach(node => {
                        if (node.owner === nation.id) {
                            node.owner = -1;
                            node.controlStrength = 0;
                            node.capturingNation = -1;
                            node.captureProgress = 0;
                        }
                    });
                    
                    // Remaining units lose morale
                    nation.units.forEach(unit => {
                        unit.morale = 0.2;
                    });
                }
                
                // Final elimination - capitulated with no units left
                if (nation.capitulated && nation.units.length === 0) {
                    // Nation is completely eliminated - no resurrection possible
                    nation.eliminated = true;
                }
            });
            
            // Announce capitulations - concatenate if multiple
            if (capitulatedThisFrame.length > 0) {
                let announcement = '';
                if (capitulatedThisFrame.length === 1) {
                    announcement = `${capitulatedThisFrame[0]} has been eliminated`;
                } else if (capitulatedThisFrame.length === 2) {
                    announcement = `${capitulatedThisFrame[0]} and ${capitulatedThisFrame[1]} eliminated`;
                } else {
                    // 3+ nations
                    const lastNation = capitulatedThisFrame.pop();
                    announcement = `${capitulatedThisFrame.join(', ')}, and ${lastNation} eliminated`;
                }
                
                Audio.announce(announcement, 'high');
            }
            
            // RESURRECTION SYSTEM - capitulated nations can return from the ashes
            // Higher chance when one nation dominates (70%+ nodes)
            const survivingNations = nations.filter(n => !n.capitulated && !n.eliminated);
            const capitulatedNations = nations.filter(n => n.capitulated && !n.eliminated);
            
            if (capitulatedNations.length > 0 && survivingNations.length > 0) {
                // Calculate dominance - find nation with most nodes
                let maxNodePercent = 0;
                survivingNations.forEach(nation => {
                    const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                    const percent = nodeCount / nodes.length;
                    if (percent > maxNodePercent) maxNodePercent = percent;
                });
                
                // Resurrection chance scales with dominance and time capitulated
                // QUEUE PRIORITY: Longest-dead nation gets resurrected first (FIFO, not LIFO)
                capitulatedNations.forEach(nation => {
                    if (!nation.capitulationTime) nation.capitulationTime = 0;
                    nation.capitulationTime += dt;
                    if (!nation.eliminationCount) nation.eliminationCount = 0;
                    if (!nation.resurrectionCount) nation.resurrectionCount = 0;
                });
                
                // Find the nation that has been dead the longest and is eligible for resurrection
                const MAX_RESURRECTIONS = 2; // Limit to 2 resurrections (3 total lives)
                let eligibleNations = capitulatedNations.filter(nation => {
                    const minimumDeathTime = 90 + (nation.eliminationCount * 60);
                    return nation.resurrectionCount < MAX_RESURRECTIONS && nation.capitulationTime >= minimumDeathTime;
                });
                
                // Sort by capitulationTime descending (longest dead first)
                eligibleNations.sort((a, b) => b.capitulationTime - a.capitulationTime);
                
                // Only consider the longest-dead nation for resurrection
                if (eligibleNations.length > 0) {
                    const nation = eligibleNations[0];
                    
                    // Base resurrection chance: 0.2% per second after minimum time
                    // Bonus: +0.5% per second for each 5% dominance over 80%
                    // At 80% dominance: 0.2% per second (rare, ~8 minutes average)
                    // At 85% dominance: 0.7% per second (~2.5 minutes average)
                    // At 90% dominance: 1.2% per second (~1.5 minutes average)
                    // At 95% dominance: 1.7% per second (~1 minute average)
                    
                    let resurrectionChance = 0.002; // 0.2% base (reduced from 0.5%)
                    if (maxNodePercent > 0.8) {
                        const dominanceBonus = (maxNodePercent - 0.8) * 20; // 0.5% per 5% over 80%
                        resurrectionChance += dominanceBonus * 0.005;
                    }
                    
                    // Roll for resurrection (only for longest-dead eligible nation)
                    if (Math.random() < resurrectionChance * dt) {
                        // RESURRECT! Find a neutral node or capture an edge node
                        const neutralNodes = nodes.filter(n => n.owner === -1);
                        let resurrectionNode = null;
                        
                        if (neutralNodes.length > 0) {
                            // Prefer neutral nodes on the edges
                            const edgeNodes = neutralNodes.filter(n => {
                                const worldWidth = canvas.width * WORLD_SCALE;
                                const worldHeight = canvas.height * WORLD_SCALE;
                                const distFromEdge = Math.min(n.x, worldWidth - n.x, n.y, worldHeight - n.y);
                                return distFromEdge < 200;
                            });
                            
                            resurrectionNode = edgeNodes.length > 0 
                                ? edgeNodes[Math.floor(Math.random() * edgeNodes.length)]
                                : neutralNodes[Math.floor(Math.random() * neutralNodes.length)];
                        } else {
                            // No neutral nodes - take a random node from the weakest nation
                            const weakestNation = activeNations.reduce((min, n) => {
                                const minNodes = nodes.filter(node => node.owner === min.id).length;
                                const nNodes = nodes.filter(node => node.owner === n.id).length;
                                return nNodes < minNodes ? n : min;
                            });
                            
                            const weakestNodes = nodes.filter(n => n.owner === weakestNation.id);
                            if (weakestNodes.length > 0) {
                                resurrectionNode = weakestNodes[Math.floor(Math.random() * weakestNodes.length)];
                            }
                        }
                        
                        if (resurrectionNode && resurrectionNode.x !== undefined && resurrectionNode.y !== undefined) {
                            // Claim the resurrection node
                            resurrectionNode.owner = nation.id;
                            resurrectionNode.controlStrength = 100;
                            resurrectionNode.isCapital = true;
                            resurrectionNode.economicTier = 3;
                            resurrectionNode.resourceMultiplier = 2.5;
                            resurrectionNode.capturingNation = -1;
                            resurrectionNode.captureProgress = 0;
                            
                            // Drop carried artifacts and release ownership - resurrected nations start fresh
                            artifacts.forEach(artifact => {
                                if (artifact.capturedBy === nation.id) {
                                    // CLEAR BOTH PROPERTIES
                                    if (artifact.type === 'spear' && artifact.carrier) {
                                        if (artifact.carrier.carriedSpear === artifact) {
                                            artifact.carrier.carriedSpear = null;
                                        }
                                    }
                                    artifact.carrier = null; // Drop if being carried
                                    artifact.capturedBy = -1;
                                    artifact.captureProgress = 0;
                                    artifact.hasAnnounced = false;
                                    
                                    // Remove from stored nodes (artifacts stay at node location but become unclaimed)
                                    if (artifact.storedAtNode) {
                                        const idx = artifact.storedAtNode.inventory.indexOf(artifact.type);
                                        if (idx >= 0) artifact.storedAtNode.inventory.splice(idx, 1);
                                        artifact.storedAtNode = null;
                                    }
                                }
                            });
                            
                            // Restore nation
                            nation.capitulated = false;
                            nation.capital = resurrectionNode;
                            nation.capitulationTime = 0;
                            nation.resurrectionImmunity = 60; // 60 seconds of immunity
                            nation.resources = 500; // Starting resources
                            nation.resurrectionCount++; // Increment resurrection counter
                            
                            // Spawn initial defense force (15 units)
                            let spawnedCount = 0;
                            for (let i = 0; i < 15 && spawnedCount < 15; i++) {
                                const angle = (i / 15) * Math.PI * 2;
                                const dist = 30 + Math.random() * 20;
                                const spawnX = resurrectionNode.x + Math.cos(angle) * dist;
                                const spawnY = resurrectionNode.y + Math.sin(angle) * dist;
                                
                                // Validate spawn position is within world bounds and passable
                                const worldWidth = canvas.width * WORLD_SCALE;
                                const worldHeight = canvas.height * WORLD_SCALE;
                                
                                if (spawnX >= 0 && spawnX < worldWidth && 
                                    spawnY >= 0 && spawnY < worldHeight && 
                                    isPassable(spawnX, spawnY)) {
                                    const unit = new Unit(spawnX, spawnY, nation.id);
                                    nation.units.push(unit);
                                    spawnedCount++;
                                }
                            }
                            
                            // Announce dramatic return
                            const nodeName = resurrectionNode.crypticName || 'the frontier';
                            Audio.announce(`${nation.name} rises from the ashes at ${nodeName}!`, 'high');
                            Audio.playTensionSiren();
                            
                            // Play capital move sound (resurrection is an upgrade/rebirth)
                            Audio.playCapitalMove(resurrectionNode.x, resurrectionNode.y, true);
                        }
                    }
                }
            }
            
            // Economic system update
            nations.forEach(nation => {
                if (nation.capitulated) return;
                
                // ARTIFACT REDISTRIBUTION - winning empires distribute artifacts to cryptic nodes
                // This prevents hoarding at capital and creates opportunities for raids
                if (!nation.redistributionTimer) nation.redistributionTimer = 0;
                nation.redistributionTimer += dt;
                
                if (nation.redistributionTimer >= 30) { // Check every 30 seconds
                    nation.redistributionTimer = 0;
                    
                    if (nation.capital) {
                        // Count artifacts at capital
                        const artifactsAtCapital = artifacts.filter(a => 
                            a.storedAtNode === nation.capital && 
                            a.movable && 
                            !a.carrier &&
                            a.capturedBy === nation.id
                        );
                        
                        if (artifactsAtCapital.length >= 3) { // Too many at capital
                            // Find cryptic nodes to redistribute to
                            const crypticNodes = nodes.filter(n => 
                                n.owner === nation.id && 
                                n.crypticName && 
                                n !== nation.capital
                            );
                            
                            if (crypticNodes.length > 0) {
                                // Move oldest artifact to least-stocked cryptic node
                                artifactsAtCapital.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
                                const artifactToMove = artifactsAtCapital[0];
                                
                                // Find cryptic node with fewest artifacts
                                const nodeCounts = crypticNodes.map(n => ({
                                    node: n,
                                    count: artifacts.filter(a => a.storedAtNode === n).length
                                }));
                                nodeCounts.sort((a, b) => a.count - b.count);
                                const targetNode = nodeCounts[0].node;
                                
                                // Assign unit to redistribute - prioritize idle units, but allow reassignment of wanderers
                                const nearbyUnits = getNearbyUnits(nation.capital.x, nation.capital.y, 100)
                                    .filter(u => u.nation === nation.id && (!u.role || u.role === 'wander' || u.role === 'nodeGuardian'));
                                
                                if (nearbyUnits.length > 0) {
                                    const unit = nearbyUnits[0];
                                    unit.role = 'redistributeArtifact';
                                    unit.targetNode = targetNode; // SET TARGET NODE for redistribution
                                    artifactToMove.carrier = unit;
                                    artifactToMove.storedAtNode = null;
                                    
                                    // LOG REDISTRIBUTION EVENT
                                    logAIEvent('redistribution', `Nation ${nation.id} redistributing artifact`, {
                                        nationId: nation.id,
                                        artifactType: artifactToMove.type,
                                        from: 'capital',
                                        to: targetNode.crypticName || 'cryptic node',
                                        availableCrypticNodes: crypticNodes.length,
                                        capitalInventoryCount: artifactsAtCapital.length
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Calculate income from territory
                let territoryIncome = 0;
                let territoryCells = 0;
                if (influenceGrid && influenceGrid.length > 0) {
                    influenceGrid.forEach(row => {
                        row.forEach(cell => {
                            if (cell.nation === nation.id && cell.strength > 0.3) {
                                territoryCells++;
                                territoryIncome += TERRITORY_INCOME_RATE * dt * cell.stability;
                            }
                        });
                    });
                }
                
                // Calculate income from nodes
                let nodeIncome = 0;
                let nodeCount = 0;
                nodes.forEach(node => {
                    if (node.owner === nation.id) {
                        nodeCount++;
                        const baseIncome = node.isCapital ? NODE_INCOME_CAPITAL : NODE_INCOME_BASE;
                        let incomeMultiplier = node.resourceMultiplier;
                        
                        // VAULT buff: +30% resource income
                        if (node.crypticName === 'Vault') {
                            incomeMultiplier *= 1.3;
                        }
                        
                        nodeIncome += baseIncome * incomeMultiplier * dt;
                        
                        // STRATEGIC ARTIFACT GENERATION - certain nodes produce intelligence/data over time
                        // Archives and Sanctums generate Research Data
                        if (node.crypticName === 'Archive' || node.crypticName === 'Sanctum') {
                            if (!node.dataGenerationTimer) node.dataGenerationTimer = 0;
                            node.dataGenerationTimer += dt;
                            
                            if (node.dataGenerationTimer >= 60) { // Every 60 seconds
                                node.dataGenerationTimer = 0;
                                const dataArtifact = artifacts.find(a => a.type === 'data' && a.capturedBy === -1);
                                if (dataArtifact) {
                                    dataArtifact.x = node.x + (Math.random() - 0.5) * 40;
                                    dataArtifact.y = node.y + (Math.random() - 0.5) * 40;
                                    dataArtifact.captureProgress = 0;
                                    dataArtifact.createdAt = performance.now() / 1000; // Set creation time for degradation
                                    dataArtifact.degradationStage = 0; // Reset to fresh
                                    dataArtifact.qualityMultiplier = 1.0;
                                    Audio.announce(`Research Data have been detected at ${node.crypticName}`, 'normal');
                                }
                            }
                        }
                        
                        // Spires and Zeniths generate Authorization Codes
                        if (node.crypticName === 'Spire' || node.crypticName === 'Zenith') {
                            if (!node.authGenerationTimer) node.authGenerationTimer = 0;
                            node.authGenerationTimer += dt;
                            
                            if (node.authGenerationTimer >= 90) { // Every 90 seconds
                                node.authGenerationTimer = 0;
                                const authArtifact = artifacts.find(a => a.type === 'auth_code' && a.capturedBy === -1);
                                if (authArtifact) {
                                    authArtifact.x = node.x + (Math.random() - 0.5) * 40;
                                    authArtifact.y = node.y + (Math.random() - 0.5) * 40;
                                    authArtifact.captureProgress = 0;
                                    Audio.announce(`Authorization Code generated at ${node.crypticName}`, 'normal');
                                }
                            }
                        }
                        
                        // Forges and Apexes develop Advanced Blueprints
                        if (node.crypticName === 'Forge' || node.crypticName === 'Apex') {
                            if (!node.blueprintGenerationTimer) node.blueprintGenerationTimer = 0;
                            node.blueprintGenerationTimer += dt;
                            
                            if (node.blueprintGenerationTimer >= 120) { // Every 120 seconds
                                node.blueprintGenerationTimer = 0;
                                const blueprintArtifact = artifacts.find(a => a.type === 'blueprint' && a.capturedBy === -1);
                                if (blueprintArtifact) {
                                    blueprintArtifact.x = node.x + (Math.random() - 0.5) * 40;
                                    blueprintArtifact.y = node.y + (Math.random() - 0.5) * 40;
                                    blueprintArtifact.captureProgress = 0;
                                    blueprintArtifact.createdAt = performance.now() / 1000; // Set creation time for degradation
                                    blueprintArtifact.degradationStage = 0; // Reset to fresh
                                    blueprintArtifact.qualityMultiplier = 1.0;
                                    Audio.announce(`Advanced Blueprint has been developed at ${node.crypticName}`, 'normal');
                                }
                            }
                        }
                    }
                });
                
                nation.income = dt > 0 ? (territoryIncome + nodeIncome) / dt : 0; // Store as per-second rate
                
                // Apply artifact bonuses to income
                const bonuses = getArtifactBonuses(nation.id);
                nation.income *= bonuses.resourceIncome;
                
                // Calculate upkeep costs - scales with unit experience/veterancy
                // More experienced units cost more to maintain (1.0x to 2.0x based on veterancy)
                let totalUpkeep = 0;
                nation.units.forEach(unit => {
                    const veterancyMultiplier = 1.0 + (unit.veterancy / 100) * 1.0; // 1.0x at 0 vet, 2.0x at 100 vet
                    totalUpkeep += UNIT_UPKEEP * veterancyMultiplier;
                });
                
                // Reduce upkeep for newly resurrected nations (economic recovery period)
                if (nation.upkeepReduction > 0) {
                    totalUpkeep *= 0.5; // 50% upkeep reduction
                    nation.upkeepReduction = Math.max(0, nation.upkeepReduction - dt);
                }
                
                nation.upkeep = totalUpkeep;
                
                // Apply economic changes
                const netIncome = nation.income - nation.upkeep;
                const resourcesBefore = nation.resources;
                
                nation.resources = Math.min(MAX_RESOURCES, nation.resources + netIncome * dt);
                
                // Tribute payments - tributaries pay 20% of income to overlord
                if (nation.tributePaying >= 0) {
                    const tributeAmount = nation.income * 0.2 * dt;
                    if (nation.resources >= tributeAmount) {
                        nation.resources -= tributeAmount;
                        const overlord = nations[nation.tributePaying];
                        if (overlord && !overlord.capitulated) {
                            overlord.resources = Math.min(MAX_RESOURCES, overlord.resources + tributeAmount);
                        }
                    } else {
                        // Can't pay tribute - break tributary status
                        const overlord = nations[nation.tributePaying];
                        if (overlord) {
                            overlord.tributeReceiving = overlord.tributeReceiving.filter(id => id !== nation.id);
                            nation.diplomaticRelations[nation.tributePaying] = DIPLOMATIC_STANCE.NEUTRAL;
                            overlord.diplomaticRelations[nation.id] = DIPLOMATIC_STANCE.NEUTRAL;
                        }
                        nation.tributePaying = -1;
                    }
                }
                
                // Deficit attrition - units take damage when nation can't support them
                if (nation.resources < 0) {
                    nation.resources = 0;
                    // Apply attrition to units
                    nation.units.forEach(unit => {
                        unit.health -= DEFICIT_ATTRITION_RATE * dt;
                    });
                }
                
                // REBELLION SYSTEM - capitulated nations apply pressure to weak nodes
                if (nation.capitulated) {
                    if (!nation.rebellionTimer) nation.rebellionTimer = 0;
                    if (!nation.rebellionCooldown) nation.rebellionCooldown = 90.0; // 90 seconds before first attempt (was 30s)
                    
                    // Require minimum time dead before rebellions can start (resistance needs to organize)
                    const timeSinceCapitulation = (performance.now() / 1000) - (nation.capitulationTime || 0);
                    if (timeSinceCapitulation < 60.0) {
                        // Too soon - resistance hasn't had time to organize
                        return;
                    }
                    
                    // Find nations with highest resistance to target
                    let maxResistance = 0;
                    nations.forEach(n => {
                        const res = resistanceIntensity[n.id] || 0;
                        if (res > maxResistance) maxResistance = res;
                    });
                    
                    // Rebellion timer speeds up with global resistance (1.5x-3x faster in high resistance)
                    const rebellionSpeed = 1.0 + (maxResistance * 1.0); // 0 resistance = 1x, 1.5 resistance = 2.5x
                    nation.rebellionTimer += dt * rebellionSpeed;
                    
                    if (nation.rebellionTimer >= nation.rebellionCooldown) {
                        // Attempt rebellion - find weakest enemy node, preferring high-resistance nations
                        const allNodes = nodes.filter(n => n.owner >= 0 && n.owner !== nation.id);
                        if (allNodes.length > 0) {
                            let weakestNode = null;
                            let lowestStrength = Infinity;
                            
                            for (let node of allNodes) {
                                const nodeOwner = nations[node.owner];
                                if (!nodeOwner || nodeOwner.capitulated) continue;
                                
                                // Calculate node strength: defender count + proximity to capital
                                const defenders = nodeOwner.units.filter(u => 
                                    Math.hypot(u.x - node.x, u.y - node.y) < 100
                                ).length;
                                const capitalDist = nodeOwner.capital ? 
                                    Math.hypot(node.x - nodeOwner.capital.x, node.y - nodeOwner.capital.y) : 0;
                                const ownerResistance = resistanceIntensity[nodeOwner.id] || 0;
                                
                                // Strength reduced by resistance (high resistance = easier to flip)
                                const strength = (defenders * 10 + (capitalDist / 100)) * (1 - ownerResistance * 0.3);
                                
                                if (strength < lowestStrength && !node.isCapital) {
                                    lowestStrength = strength;
                                    weakestNode = node;
                                }
                            }
                            
                            // Threshold increases with max resistance (easier rebellions)
                            const rebellionThreshold = 50 + (maxResistance * 30); // 50-95 depending on resistance
                            if (weakestNode && lowestStrength < rebellionThreshold) {
                                // REBELLION SUCCESS - establish new capital!
                                weakestNode.owner = nation.id;
                                weakestNode.isCapital = true;
                                weakestNode.economicTier = 3;
                                weakestNode.resourceMultiplier = 2.5;
                                nation.capital = weakestNode;
                                nation.capitulated = false;
                                nation.resources = 50;
                                nation.rebellionTimer = 0;
                                
                                // Spawn initial rebellion force at the captured node
                                // Smaller force - resistance builds gradually, not massive instant army
                                const rebellionForceSize = Math.floor(8 + (maxResistance * 4)); // 8-14 units based on resistance (was 15-30)
                                for (let i = 0; i < rebellionForceSize; i++) {
                                    const angle = (i / rebellionForceSize) * Math.PI * 2;
                                    const spawnDist = 20 + Math.random() * 15;
                                    const unit = new Unit(
                                        weakestNode.x + Math.cos(angle) * spawnDist,
                                        weakestNode.y + Math.sin(angle) * spawnDist,
                                        nation.id
                                    );
                                    nation.units.push(unit);
                                }
                                
                                Audio.announce(`${nation.name} rebellion establishes new capital!`, 'high', nation.id);
                            } else {
                                // Failed - retry more frequently
                                nation.rebellionTimer = 0;
                                nation.rebellionCooldown = 45.0; // 45 seconds (was 90s)
                            }
                        }
                    }
                }
            });
            
            // Update
            nations.forEach(nation => {
                // CACHE NODE LISTS - calculate once per nation instead of per unit
                // This is a massive performance gain when there are many units
                nation.cachedMyNodes = nodes.filter(n => n.owner === nation.id);
                nation.cachedUncontrolledNodes = nodes.filter(n => n.owner !== nation.id);
                nation.cachedThreatenedNodes = nation.cachedMyNodes.filter(n => 
                    n.capturingNation >= 0 && n.capturingNation !== nation.id && n.captureProgress > 0
                );
                
                // Cache exposed nodes - check for nearby enemies using spatial grid
                // Nodes adjacent to mountains are considered SECURE and not exposed
                nation.cachedExposedNodes = [];
                for (let n of nation.cachedMyNodes) {
                    // Check if node is adjacent to mountains (natural defense)
                    let nearMountain = false;
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                        const checkX = n.x + Math.cos(angle) * 60;
                        const checkY = n.y + Math.sin(angle) * 60;
                        if (getTerrainType(checkX, checkY) === TERRAIN_TYPES.MOUNTAIN) {
                            nearMountain = true;
                            break;
                        }
                    }
                    
                    // If near mountain, it's automatically secured - skip enemy check
                    if (nearMountain) continue;
                    
                    const nearbyUnits = getNearbyUnits(n.x, n.y, 120, true);
                    const hasCloseEnemies = nearbyUnits.some(u => 
                        u.nation !== nation.id && Math.hypot(u.x - n.x, u.y - n.y) < 120
                    );
                    if (hasCloseEnemies) {
                        nation.cachedExposedNodes.push(n);
                    }
                }
                
                // ASSIGN NODE GUARDIANS - DISABLED
                // Guardian system was creating tight clustering rings around nodes
                // Units now naturally defend via objective forces and territory control
                /*
                if (!nation.lastGuardianAssignment) nation.lastGuardianAssignment = 0;
                nation.lastGuardianAssignment += dt;
                
                if (nation.lastGuardianAssignment >= 5.0) {
                    nation.lastGuardianAssignment = 0;
                    
                    // Clear previous guardian assignments
                    nation.units.forEach(u => {
                        if (u.role === 'nodeGuardian') {
                            u.role = null;
                            u.targetNode = null;
                        }
                    });
                    
                    // Find nearest unit to each friendly node (efficient O(N×M) instead of O(N²×M))
                    const myNodes = nodes.filter(n => n.owner === nation.id);
                    for (let node of myNodes) {
                        let closestUnit = null;
                        let closestDist = Infinity;
                        
                        for (let unit of nation.units) {
                            const dist = Math.hypot(unit.x - node.x, unit.y - node.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestUnit = unit;
                            }
                        }
                        
                        // Assign closest unit as node guardian if within range
                        if (closestUnit && closestDist < 35 && closestUnit.role !== 'nodeGuardian') {
                            closestUnit.role = 'nodeGuardian';
                            closestUnit.targetNode = node;
                        }
                    }
                }
                */
                nation.units.forEach(unit => unit.update(dt, allUnits, nodes));
                
                // Alliance pressure checking DISABLED for performance
                // This was O(n²) operation scanning all unit pairs
                // Trust now only degrades from diplomatic evaluation
                if (!nation.alliancePressure) nation.alliancePressure = {};
                
                // Degrade alliance trust based on accumulated pressure
                Object.keys(nation.alliancePressure || {}).forEach(allyId => {
                    const pressureTime = nation.alliancePressure[allyId];
                    if (pressureTime > 0) {
                        // Initialize trust if not set
                        if (!nation.allianceTrust[allyId]) {
                            nation.allianceTrust[allyId] = 100; // Start at full trust
                        }
                        
                        // Degrade trust based on pressure (1 trust per second of pressure)
                        nation.allianceTrust[allyId] -= pressureTime * 1.0;
                        
                        // If trust drops too low, break the alliance
                        if (nation.allianceTrust[allyId] <= 0) {
                            const ally = nations[allyId];
                            nation.diplomaticRelations[allyId] = DIPLOMATIC_STANCE.WAR;
                            ally.diplomaticRelations[nation.id] = DIPLOMATIC_STANCE.WAR;
                            nation.allianceTrust[allyId] = 0;
                        }
                    }
                });
                
                // Decay pressure accumulation (reset each frame)
                nation.alliancePressure = {};
                
                // Remove only dead units - track casualties for war exhaustion
                const deadUnits = nation.units.filter(unit => unit.health <= 0);
                if (deadUnits.length > 0) {
                    // Only count casualties if nation is alive (resistance deaths don't count)
                    if (!nation.capitulated) {
                        nation.totalCasualties += deadUnits.length;
                        nation.recentLosses.push({ time: Date.now(), count: deadUnits.length });
                    }
                    
                    // Play death sounds (limited to prevent spam)
                    const deathsToPlay = Math.min(deadUnits.length, 3); // Max 3 sounds
                    for (let i = 0; i < deathsToPlay; i++) {
                        if (Math.random() < 0.4) { // 40% chance per death
                            const unit = deadUnits[Math.floor(Math.random() * deadUnits.length)];
                            Audio.playDeath(unit.x, unit.y);
                        }
                    }
                    
                    // Clean old losses (older than 2 minutes)
                    const twoMinutesAgo = Date.now() - 120000;
                    nation.recentLosses = nation.recentLosses.filter(loss => loss.time > twoMinutesAgo);
                }
                nation.units = nation.units.filter(unit => unit.health > 0);
            });
            
            // Update influence grid every 5th frame for better performance
            if (frameCount % 5 === 0) {
                updateInfluenceGrid(dt * 5);
            }
            
            // Update battle ambience based on active combat
            const totalUnitsInCombat = nations.reduce((sum, n) => 
                sum + n.units.filter(u => u.inBattle).length, 0
            );
            const battleIntensity = Math.min(totalUnitsInCombat / 50, 1.0); // Max at 50 units
            Audio.updateAmbience(battleIntensity);
            
            // === STRATEGIC ANNOUNCEMENTS ===
            const nowTimestamp = Date.now();
            const timeSinceGameStart = nowTimestamp - announcerState.gameStartTime;
            
            // Dominance announcement (nation has most units OR most nodes)
            // Wait at least 90 seconds after game start to avoid interrupting intro
            // CRITICAL: Only include nations that have been properly spawned (have a capital)
            const activeNations = nations.filter(n => !n.capitulated && n.capital !== null);
            if (activeNations.length > 1 && 
                nowTimestamp - announcerState.lastDominanceAnnounce > 90000 &&
                timeSinceGameStart > 90000) {
                // Find nation with most units
                const mostUnitsNation = activeNations.reduce((max, n) => 
                    n.units.length > max.units.length ? n : max
                );
                
                // Find nation with most nodes
                const mostNodesNation = activeNations.reduce((max, n) => {
                    const maxNodes = nodes.filter(node => node.owner === max.id).length;
                    const nNodes = nodes.filter(node => node.owner === n.id).length;
                    return nNodes > maxNodes ? n : max;
                });
                
                // Announce if same nation leads in both, or has significant lead in one
                const mostNodes = nodes.filter(node => node.owner === mostNodesNation.id).length;
                const secondMostNodes = Math.max(...activeNations
                    .filter(n => n.id !== mostNodesNation.id)
                    .map(n => nodes.filter(node => node.owner === n.id).length)
                );
                
                const secondMostUnits = Math.max(...activeNations
                    .filter(n => n.id !== mostUnitsNation.id)
                    .map(n => n.units.length)
                );
                
                // Announce if leading in both OR has 50%+ more than second place
                if ((mostUnitsNation.id === mostNodesNation.id) || 
                    (mostNodes > secondMostNodes * 1.5) || 
                    (mostUnitsNation.units.length > secondMostUnits * 1.5)) {
                    
                    const dominant = mostUnitsNation.id === mostNodesNation.id ? mostUnitsNation : mostNodesNation;
                    Audio.announce(`${dominant.name} dominates the battlefield!`, 'high');
                    announcerState.lastDominanceAnnounce = nowTimestamp;
                }
            }
            
            // Comeback announcement (nation down to 1 node captures 5+)
            nations.forEach(nation => {
                if (!nation.lastNodeCount) nation.lastNodeCount = 0;
                const nodeCount = nodes.filter(n => n.owner === nation.id).length;
                if (nation.lastNodeCount === 1 && nodeCount >= 5 && nowTimestamp - announcerState.lastComeback > 120000) {
                    Audio.announce(`${nation.name} stages incredible comeback!`, 'high');
                    announcerState.lastComeback = nowTimestamp;
                }
                nation.lastNodeCount = nodeCount;
            });
            
            // === FLAVOR ANNOUNCEMENTS === (during quiet periods - PRIORITY 3)
            // Only announce flavor if no major announcement in last 25 seconds
            if (nowTimestamp - announcerState.lastAnnouncement > 25000 && 
                nowTimestamp - announcerState.lastFlavor > 30000 && 
                activeNations.length > 1) {
                
                const flavorTypes = [];
                
                // Check for heavy fighting (lots of units in battle)
                if (totalUnitsInCombat > 30) {
                    flavorTypes.push({ type: 'combat', count: totalUnitsInCombat });
                }
                
                // Check for force buildup (nation with MOST units, minimum 40)
                const massedNation = activeNations.reduce((best, n) => {
                    const bestCount = best ? best.units.length : 0;
                    return n.units.length > bestCount && n.units.length >= 40 ? n : best;
                }, null);
                if (massedNation) {
                    flavorTypes.push({ type: 'buildup', nation: massedNation, count: massedNation.units.length, priority: 6 });
                }
                
                // Check for low morale (nation with many fatigued units)
                const wearyNation = activeNations.find(n => {
                    const fatigued = n.units.filter(u => u.stamina < 30).length;
                    return fatigued > n.units.length * 0.5 && n.units.length > 10;
                });
                if (wearyNation) {
                    const fatigued = wearyNation.units.filter(u => u.stamina < 30).length;
                    flavorTypes.push({ type: 'weary', nation: wearyNation, count: fatigued });
                }
                
                // Check for defensive posture (nation with many units near nodes)
                const defensiveNation = activeNations.find(n => {
                    const myNodes = nodes.filter(node => node.owner === n.id);
                    if (myNodes.length === 0) return false;
                    const nearNodes = n.units.filter(u => 
                        myNodes.some(node => Math.hypot(u.x - node.x, u.y - node.y) < 60)
                    ).length;
                    return nearNodes > n.units.length * 0.6 && n.units.length > 15;
                });
                if (defensiveNation) {
                    const myNodes = nodes.filter(node => node.owner === defensiveNation.id);
                    flavorTypes.push({ type: 'defensive', nation: defensiveNation, nodes: myNodes.length });
                }
                
                // Check for expansion (nation that gained nodes recently) - verify actual gain
                const expandingNation = activeNations.reduce((best, n) => {
                    const currentNodes = nodes.filter(node => node.owner === n.id).length;
                    const gained = currentNodes - (n.lastNodeCount || 0);
                    const bestGained = best ? (nodes.filter(node => node.owner === best.id).length - (best.lastNodeCount || 0)) : 0;
                    return gained > bestGained && gained >= 3 && currentNodes >= 5 ? n : best;
                }, null);
                
                if (expandingNation) {
                    const currentNodes = nodes.filter(node => node.owner === expandingNation.id).length;
                    flavorTypes.push({ type: 'expansion', nation: expandingNation, nodes: currentNodes, priority: 7 });
                }
                
                // Check for stalemate (low casualties, no node changes)
                const totalCasualties = activeNations.reduce((sum, n) => sum + (n.casualtiesThisMinute || 0), 0);
                if (totalCasualties < 5 && totalUnitsInCombat < 15) {
                    flavorTypes.push({ type: 'stalemate' });
                }
                
                // Check for artillery barrage (multiple active artillery strikes)
                const activeArtillery = artillery.filter(a => a.lifetime < 0.3).length;
                if (activeArtillery >= 3) {
                    flavorTypes.push({ type: 'artillery', count: activeArtillery });
                }
                
                // Check for dominance (one nation has 60%+ of all nodes) - HIGHEST PRIORITY
                const dominantNation = activeNations.reduce((max, n) => {
                    const myNodes = nodes.filter(node => node.owner === n.id).length;
                    const maxNodes = max ? nodes.filter(node => node.owner === max.id).length : 0;
                    return myNodes > maxNodes ? n : max;
                }, null);
                
                if (dominantNation) {
                    const myNodes = nodes.filter(node => node.owner === dominantNation.id).length;
                    const percent = Math.floor((myNodes / nodes.length) * 100);
                    // Only announce dominance if actually dominant (60%+)
                    if (percent >= 60 && nodes.length >= 10) {
                        flavorTypes.push({ type: 'dominance', nation: dominantNation, percent, priority: 10 });
                    }
                }
                
                // Check for contested capital
                const contestedCapital = nodes.find(n => n.isCapital && n.capturingNation >= 0 && n.captureProgress > 0.3);
                if (contestedCapital) {
                    const defender = nations[contestedCapital.owner];
                    const attacker = nations[contestedCapital.capturingNation];
                    const progress = Math.floor(contestedCapital.captureProgress * 100);
                    flavorTypes.push({ type: 'capitalSiege', defender, attacker, progress });
                }
                
                // Check for resource shortage (nation with very low resources)
                const brokeNation = activeNations.find(n => n.resources < 50 && n.units.length < 10);
                if (brokeNation) {
                    flavorTypes.push({ type: 'poverty', nation: brokeNation, resources: Math.floor(brokeNation.resources) });
                }
                
                // Check for special node clusters (nation with MOST cryptic nodes, minimum 2)
                const crypticHolder = activeNations.reduce((best, n) => {
                    const cryptics = nodes.filter(node => node.owner === n.id && node.crypticName && node.crypticName !== 'Sanctum').length;
                    const bestCount = best ? nodes.filter(node => node.owner === best.id && node.crypticName && node.crypticName !== 'Sanctum').length : 0;
                    return cryptics > bestCount && cryptics >= 2 ? n : best;
                }, null);
                if (crypticHolder) {
                    // Count includes cryptic nodes AND capital (strategic positions)
                    const cryptics = nodes.filter(node => node.owner === crypticHolder.id && (node.crypticName || node.isCapital));
                    flavorTypes.push({ type: 'crypticPower', nation: crypticHolder, count: cryptics.length, priority: 5 });
                }
                
                // Pick highest priority flavor and announce (or random among same priority)
                if (flavorTypes.length > 0) {
                    // Sort by priority (highest first), then randomize within same priority
                    flavorTypes.sort((a, b) => (b.priority || 0) - (a.priority || 0));
                    const topPriority = flavorTypes[0].priority || 0;
                    const topTier = flavorTypes.filter(f => (f.priority || 0) === topPriority);
                    const chosen = topTier[Math.floor(Math.random() * topTier.length)];
                    
                    if (chosen.type === 'combat') {
                        const phrases = [
                            `Heavy fighting across the front, ${chosen.count} units engaged`,
                            `Intense combat rages on with ${chosen.count} combatants`,
                            `Battle intensifies, ${chosen.count} forces clashing`,
                            `Fierce fighting continues across multiple sectors`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'buildup') {
                        const phrases = [
                            `${chosen.nation.name} masses ${chosen.count} forces`,
                            `${chosen.nation.name} builds army to ${chosen.count} strong`,
                            `${chosen.nation.name} mobilizes ${chosen.count} troops`,
                            `${chosen.nation.name} amasses overwhelming force`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'weary') {
                        const phrases = [
                            `${chosen.nation.name}'s forces are exhausted, ${chosen.count} troops faltering`,
                            `${chosen.nation.name} shows signs of fatigue across the line`,
                            `${chosen.nation.name}'s troops are weary, morale crumbling`,
                            `Exhaustion plagues ${chosen.nation.name}'s army`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'defensive') {
                        const phrases = [
                            `${chosen.nation.name} fortifies ${chosen.nodes} positions`,
                            `${chosen.nation.name} digs in across ${chosen.nodes} strongholds`,
                            `${chosen.nation.name} strengthens defenses at all ${chosen.nodes} holdings`,
                            `${chosen.nation.name} adopts defensive posture`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'expansion') {
                        const phrases = [
                            `${chosen.nation.name} expands to ${chosen.nodes} territories`,
                            `${chosen.nation.name} pushes forward, now holds ${chosen.nodes} cities`,
                            `${chosen.nation.name} gains ground rapidly`,
                            `${chosen.nation.name} seizes ${chosen.nodes} positions`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'stalemate') {
                        const phrases = [
                            'Front lines stabilize',
                            'Fighting has ground to a stalemate',
                            'Neither side gains advantage',
                            'The battle reaches deadlock',
                            'Positions remain static'
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'artillery') {
                        const phrases = [
                            `Artillery barrage, ${chosen.count} strikes incoming`,
                            `Heavy bombardment underway`,
                            `${chosen.count} artillery shells rain down`,
                            'The earth shakes from artillery fire'
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'dominance') {
                        const phrases = [
                            `${chosen.nation.name} dominates with ${chosen.percent} percent control`,
                            `${chosen.nation.name} holds overwhelming majority`,
                            `${chosen.nation.name} commands the frontier`,
                            `${chosen.nation.name} approaches total conquest`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'capitalSiege') {
                        const phrases = [
                            `${chosen.attacker.name} threatens ${chosen.defender.name}'s capital, ${chosen.progress} percent`,
                            `${chosen.defender.name}'s capital under siege`,
                            `${chosen.attacker.name} breaches ${chosen.defender.name}'s capital defenses`,
                            `The capital falls to ${chosen.attacker.name}'s assault`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'poverty') {
                        const phrases = [
                            `${chosen.nation.name} struggles with depleted resources`,
                            `${chosen.nation.name}'s economy collapses`,
                            `${chosen.nation.name} faces resource crisis`,
                            `${chosen.nation.name} cannot sustain war effort`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    } else if (chosen.type === 'crypticPower') {
                        const phrases = [
                            `${chosen.nation.name} controls ${chosen.count} strategic positions`,
                            `${chosen.nation.name} holds ${chosen.count} fortified strongholds`,
                            `${chosen.nation.name} consolidates power at key locations`,
                            `${chosen.nation.name} secures ${chosen.count} vital positions`
                        ];
                        Audio.announce(phrases[Math.floor(Math.random() * phrases.length)], 'normal');
                    }
                    
                    announcerState.lastFlavor = nowTimestamp;
                }
            }
            
            // === NATION SHIT TALK / DRAMA === (during quiet periods - PRIORITY 2)
            // Only during quiet periods (15+ seconds since last announcement)
            if (nowTimestamp - announcerState.lastAnnouncement > 15000 && 
                nowTimestamp - announcerState.lastShitTalk > 20000 && 
                activeNations.length > 1) {
                
                // Pick a random active, NON-ELIMINATED nation to "speak"
                const eligibleSpeakers = activeNations.filter(n => !n.eliminated);
                if (eligibleSpeakers.length === 0) return; // No one left to talk
                
                const speaker = eligibleSpeakers[Math.floor(Math.random() * eligibleSpeakers.length)];
                
                // CRITICAL: Validate speaker is actually in this game
                if (!speaker || speaker.id >= nations.length || nations[speaker.id] !== speaker) {
                    console.log(`[TALK ERROR] Invalid speaker: ID ${speaker?.id}, Name: ${speaker?.name}`);
                    return; // Abort
                }
                
                const talkTypes = [];
                
                // Find enemies
                const enemies = activeNations.filter(n => 
                    speaker.diplomaticRelations[n.id] === DIPLOMATIC_STANCE.WAR
                );
                
                // Find allies
                const allies = activeNations.filter(n => 
                    speaker.diplomaticRelations[n.id] === DIPLOMATIC_STANCE.ALLIED && n.id !== speaker.id
                );
                
                // Find closest highest-threat neighbor (enemy node closest to speaker's capital)
                let closestThreat = null;
                let closestDistance = Infinity;
                
                if (enemies.length > 0 && speaker.capital) {
                    // Find the closest enemy node to speaker's capital
                    nodes.forEach(node => {
                        if (node.owner >= 0 && node.owner < nations.length && enemies.some(e => e.id === node.owner)) {
                            const nodeOwner = nations[node.owner];
                            if (!nodeOwner || nodeOwner.capitulated) return; // Skip invalid/dead nations
                            const distance = Math.hypot(node.x - speaker.capital.x, node.y - speaker.capital.y);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestThreat = nodeOwner;
                            }
                        }
                    });
                }
                
                // Find strongest rival
                const rivals = activeNations.filter(n => n.id !== speaker.id);
                const strongestRival = rivals.reduce((max, n) => 
                    n.units.length > (max?.units.length || 0) ? n : max, null
                );
                
                // Trash talk closest threat FIRST (highest priority)
                if (closestThreat) {
                    talkTypes.push({ type: 'trashtalk', target: closestThreat, priority: 10 });
                }
                
                // Don't trash talk other enemies - always focus on closest threat
                
                // Boast about strength (if strong)
                if (speaker.units.length >= 30 || nodes.filter(n => n.owner === speaker.id).length >= 8) {
                    talkTypes.push({ type: 'boast' });
                }
                
                // Accuse someone (if they have war crimes or captured our nodes recently)
                const warCriminals = activeNations.filter(n => 
                    n.id !== speaker.id && n.recentWarCrimes.length > 0
                );
                if (warCriminals.length > 0) {
                    const target = warCriminals[Math.floor(Math.random() * warCriminals.length)];
                    talkTypes.push({ type: 'accuse', target });
                }
                
                // Alliance drama (if allied)
                if (allies.length > 0) {
                    const ally = allies[Math.floor(Math.random() * allies.length)];
                    talkTypes.push({ type: 'alliance', target: ally });
                }
                
                // Intelligence report (always possible)
                if (strongestRival) {
                    talkTypes.push({ type: 'intelligence', target: strongestRival });
                }
                
                // Desperate plea (if losing badly)
                if (speaker.units.length < 10 && nodes.filter(n => n.owner === speaker.id).length < 3) {
                    talkTypes.push({ type: 'desperate' });
                }
                
                // Pick one and announce
                if (talkTypes.length > 0) {
                    const chosen = talkTypes[Math.floor(Math.random() * talkTypes.length)];
                    
                    // CRITICAL: Validate that target nation is actually in the game
                    if (chosen.target && (chosen.target.id >= nations.length || !nations[chosen.target.id] || nations[chosen.target.id].capitulated)) {
                        console.log(`[TALK SKIP] Invalid target nation ID ${chosen.target.id} (name: ${chosen.target?.name})`);
                        return; // Abort this announcement
                    }
                    
                    let message = '';
                    
                    if (chosen.type === 'trashtalk') {
                        const aggressive = [
                            `${chosen.target.name} will fall`,
                            `${chosen.target.name}'s defeat is inevitable`,
                            `We're crushing ${chosen.target.name}`,
                            `${chosen.target.name} stands no chance`,
                            `${chosen.target.name} is finished`,
                            `${chosen.target.name} bleeds like cowards`,
                            `${chosen.target.name}'s soldiers will flee in terror`,
                            `${chosen.target.name} will beg for mercy`,
                            `${chosen.target.name}'s cities will burn`,
                            `${chosen.target.name} are pathetic weaklings`,
                            `${chosen.target.name} fights like children`,
                            `${chosen.target.name}'s flag will be torn down`,
                            `${chosen.target.name} will know true fear`,
                            `${chosen.target.name}'s cowardice is legendary`,
                            `${chosen.target.name} disgrace the battlefield`
                        ];
                        message = aggressive[Math.floor(Math.random() * aggressive.length)];
                    } else if (chosen.type === 'boast') {
                        const boasts = [
                            `${speaker.name} forces holding strong positions`,
                            `${speaker.name} maintains operational readiness`,
                            `${speaker.name} defenses proven resilient`,
                            `${speaker.name} forces remain disciplined`,
                            `${speaker.name} tactical preparations continue`,
                            `${speaker.name} positions well-fortified`,
                            `${speaker.name} maintains strategic depth`,
                            `${speaker.name} forces tested and capable`,
                            `${speaker.name} prepared for sustained operations`,
                            `${speaker.name} defenses have held firm`,
                            `${speaker.name} forces demonstrate resolve`,
                            `${speaker.name} strategic position stable`,
                            `${speaker.name} remains vigilant and ready`
                        ];
                        message = boasts[Math.floor(Math.random() * boasts.length)];
                    } else if (chosen.type === 'accuse') {
                        const accusations = [
                            `${chosen.target.name} has no honor`,
                            `${chosen.target.name} commits atrocities`,
                            `${chosen.target.name}'s war crimes will not be forgotten`,
                            `${chosen.target.name} targets our cities`,
                            `The world sees ${chosen.target.name}'s true nature`,
                            `${chosen.target.name} are barbaric savages`,
                            `${chosen.target.name} slaughters the innocent`,
                            `${chosen.target.name}'s brutality knows no bounds`,
                            `${chosen.target.name} are war criminals`,
                            `${chosen.target.name} murders without mercy`,
                            `${chosen.target.name} disgraces all civilized nations`,
                            `${chosen.target.name}'s cruelty is unforgivable`,
                            `${chosen.target.name} commits crimes against peace`,
                            `${chosen.target.name} brought this war upon themselves`,
                            `${chosen.target.name} violates every code of war`,
                            `${chosen.target.name} will answer for their atrocities`,
                            `${chosen.target.name} are enemies of civilization`,
                            `${chosen.target.name}'s aggression will be their downfall`,
                            `${chosen.target.name} terrorizes the innocent`,
                            `${chosen.target.name}'s reign of terror must end`
                        ];
                        message = accusations[Math.floor(Math.random() * accusations.length)];
                    } else if (chosen.type === 'alliance') {
                        const allyTalk = [
                            `${speaker.name} confirms ${chosen.target.name} alliance status`,
                            `${speaker.name} and ${chosen.target.name} joint operations continuing`,
                            `${speaker.name} alliance with ${chosen.target.name} operationally sound`,
                            `${speaker.name} coordination with ${chosen.target.name} effective`,
                            `${speaker.name} confirms ${chosen.target.name} tactical cooperation`,
                            `${speaker.name} and ${chosen.target.name} forces synchronized`,
                            `${speaker.name} alliance with ${chosen.target.name} holding strong`
                        ];
                        message = allyTalk[Math.floor(Math.random() * allyTalk.length)];
                    } else if (chosen.type === 'intelligence') {
                        // Real intelligence with specific tactical details
                        const targetNodes = nodes.filter(n => n.owner === chosen.target.id);
                        const targetUnits = chosen.target.units.length;
                        const targetArtifacts = artifacts.filter(a => a.capturedBy === chosen.target.id);
                        const targetHasSuperweapon = superweapons.some(sw => sw.ownerNation === chosen.target.id);
                        const targetCrypticNodes = targetNodes.filter(n => n.crypticName);
                        
                        const intel = [];
                        
                        // Force composition intel
                        if (targetUnits > 40) {
                            intel.push(`${speaker.name} intelligence confirms ${chosen.target.name} commands ${targetUnits} combat units`);
                        } else if (targetUnits > 25) {
                            intel.push(`${speaker.name} reports ${chosen.target.name} fielding ${targetUnits} active combatants`);
                        } else {
                            intel.push(`${speaker.name} tracking ${chosen.target.name} force strength at ${targetUnits} units`);
                        }
                        
                        // Strategic asset intel
                        if (targetHasSuperweapon) {
                            intel.push(`${speaker.name} confirms ${chosen.target.name} superweapon deployment in sector`);
                            intel.push(`${speaker.name} warns ${chosen.target.name} experimental weapon now operational`);
                        }
                        
                        // Artifact intel
                        if (targetArtifacts.length >= 3) {
                            intel.push(`${speaker.name} intelligence reports ${chosen.target.name} secured ${targetArtifacts.length} strategic artifacts`);
                        } else if (targetArtifacts.length > 0) {
                            const artifactName = targetArtifacts[0].name;
                            intel.push(`${speaker.name} confirms ${chosen.target.name} possesses ${artifactName}`);
                        }
                        
                        // Cryptic node intel
                        if (targetCrypticNodes.length > 0) {
                            const crypticName = targetCrypticNodes[0].crypticName;
                            intel.push(`${speaker.name} intelligence identifies ${chosen.target.name} holding ${crypticName}`);
                            intel.push(`${speaker.name} reports ${chosen.target.name} fortified position at ${crypticName}`);
                        }
                        
                        // Territory intel
                        const targetNodeCount = targetNodes.length;
                        if (targetNodeCount >= 8) {
                            // Count cryptic nodes + capital as strategic positions
                            const strategicCount = targetNodes.filter(n => n.crypticName || n.isCapital).length;
                            intel.push(`${speaker.name} confirms ${chosen.target.name} controls ${strategicCount} strategic positions`);
                        } else if (targetNodeCount >= 5) {
                            intel.push(`${speaker.name} tracking ${chosen.target.name} expansion to ${targetNodeCount} nodes`);
                        }
                        
                        // Capital threat assessment
                        if (chosen.target.capital && speaker.capital) {
                            const distToCapital = Math.hypot(
                                chosen.target.capital.x - speaker.capital.x,
                                chosen.target.capital.y - speaker.capital.y
                            );
                            if (distToCapital < 600) {
                                intel.push(`${speaker.name} assesses ${chosen.target.name} core within strike range`);
                            }
                        }
                        
                        // Resource/economic intel
                        if (chosen.target.income > 50) {
                            intel.push(`${speaker.name} estimates ${chosen.target.name} resource production at high capacity`);
                        }
                        
                        message = intel.length > 0 
                            ? intel[Math.floor(Math.random() * intel.length)]
                            : `${speaker.name} monitoring ${chosen.target.name} activities`;
                    } else if (chosen.type === 'desperate') {
                        const desperate = [
                            `${speaker.name} will not surrender`,
                            `${speaker.name} forces fighting for survival`,
                            `${speaker.name} continues resistance operations`,
                            `${speaker.name} command maintains defensive posture`,
                            `${speaker.name} forces regrouping for counterattack`,
                            `${speaker.name} operating with nothing to lose`,
                            `${speaker.name} soldiers committed to last stand`,
                            `${speaker.name} will extract maximum cost`,
                            `${speaker.name} defiance will be remembered`,
                            `${speaker.name} rejects all terms`
                        ];
                        message = desperate[Math.floor(Math.random() * desperate.length)];
                    }
                    
                    if (message) {
                        // Final check: ensure speaker hasn't capitulated before announcing
                        if (!speaker.capitulated) {
                            Audio.announce(message, 'normal', speaker.id);
                            announcerState.lastShitTalk = nowTimestamp;
                        }
                    }
                }
            }
            
            } // End of !game.impactInProgress block
            
            } // End of !game.paused block
            
            // Draw (always render even when paused)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Show "Click to Start" message if paused
            if (game.paused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CLICK TO START', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '24px monospace';
                ctx.fillStyle = '#00ddff';
                ctx.fillText('Autonomous Frontier Combatant Units', canvas.width / 2, canvas.height / 2 + 60);
                ctx.textAlign = 'left';
            }
            
            // Scale world down to fit in window
            ctx.save();
            ctx.scale(1 / WORLD_SCALE, 1 / WORLD_SCALE);
            
            drawWorldMap();
            drawInfluenceGrid();
            drawBorders();
            
            // Draw artillery
            artillery.forEach(strike => strike.draw());
            
            // Craters are now baked into terrain rendering (see drawWorldMap)
            
            // Draw superweapons
            superweapons.forEach(weapon => weapon.draw());
            
            // Draw detonation blast effects - simple white hot expanding dome
            if (game.detonationEffects) {
                game.detonationEffects.forEach(effect => {
                    // ANGEL DEATH EFFECT: Blood splatter and neon genesis cross
                    if (effect.angelDeath || effect.bloodSplatters) {
                        ctx.save();
                        const progress = effect.timer / effect.duration;
                        
                        // Blood splatters
                        if (progress < 0.3) {
                            const splatterProgress = progress / 0.3;
                            ctx.globalAlpha = 0.9 - splatterProgress * 0.3;
                            effect.bloodSplatters.forEach(splatter => {
                                const x = effect.x + Math.cos(splatter.angle) * splatter.distance * splatterProgress;
                                const y = effect.y + Math.sin(splatter.angle) * splatter.distance * splatterProgress;
                                ctx.fillStyle = `rgba(180, 0, 0, ${splatter.alpha})`;
                                ctx.beginPath();
                                ctx.arc(x, y, splatter.size, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                        
                        // Deep red organic orb burst
                        if (progress < 0.2) {
                            const orbProgress = progress / 0.2;
                            effect.orbRadius = effect.maxOrbRadius * orbProgress;
                            ctx.globalAlpha = 0.9 - orbProgress * 0.7;
                            const orbGradient = ctx.createRadialGradient(
                                effect.x, effect.y, 0,
                                effect.x, effect.y, effect.orbRadius
                            );
                            orbGradient.addColorStop(0, 'rgba(255, 0, 0, 1.0)');
                            orbGradient.addColorStop(0.5, 'rgba(180, 0, 0, 0.9)');
                            orbGradient.addColorStop(1, 'rgba(120, 0, 0, 0)');
                            ctx.fillStyle = orbGradient;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.orbRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Neon genesis cross (appears after orb burst)
                        if (progress >= 0.15) {
                            const crossProgress = (progress - 0.15) / 0.85;
                            effect.crossHeight = effect.maxCrossHeight * Math.min(1, crossProgress * 2);
                            const crossAlpha = crossProgress < 0.1 ? crossProgress * 10 : (1.0 - (crossProgress - 0.1) / 0.9);
                            
                            ctx.globalAlpha = crossAlpha * 0.85;
                            ctx.strokeStyle = effect.color;
                            ctx.lineWidth = 3;
                            
                            // Vertical beam
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y - effect.crossHeight);
                            ctx.lineTo(effect.x, effect.y + effect.crossHeight);
                            ctx.stroke();
                            
                            // Horizontal beam (shorter)
                            const horizontalWidth = effect.crossHeight * 0.6;
                            ctx.beginPath();
                            ctx.moveTo(effect.x - horizontalWidth, effect.y);
                            ctx.lineTo(effect.x + horizontalWidth, effect.y);
                            ctx.stroke();
                            
                            // Glow effect
                            ctx.globalAlpha = crossAlpha * 0.4;
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y - effect.crossHeight);
                            ctx.lineTo(effect.x, effect.y + effect.crossHeight);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(effect.x - horizontalWidth, effect.y);
                            ctx.lineTo(effect.x + horizontalWidth, effect.y);
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                        return;
                    }
                    
                    // EVA PILOT EJECTION
                    if (effect.pilotEjection || effect.startX !== undefined) {
                        ctx.save();
                        const evaProgress = effect.timer / effect.duration;
                        
                        // Parabolic arc trajectory
                        const arcHeight = 40;
                        const parabola = -4 * arcHeight * evaProgress * (evaProgress - 1);
                        const currentX = effect.startX + (effect.x - effect.startX) * evaProgress;
                        const currentY = effect.startY + (effect.y - effect.startY) * evaProgress - parabola;
                        
                        // Fade out as it lands
                        ctx.globalAlpha = effect.alpha * (1.0 - evaProgress * 0.5);
                        
                        // Small pilot capsule/ejection seat
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Parachute if in later stages
                        if (evaProgress > 0.3) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(currentX, currentY - 3);
                            ctx.lineTo(currentX, currentY - 15);
                            ctx.stroke();
                            
                            // Parachute canopy
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                            ctx.beginPath();
                            ctx.arc(currentX, currentY - 15, 8, 0, Math.PI, true);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                        return;
                    }
                    
                    // STANDARD EXPLOSION EFFECTS
                    ctx.save();
                    
                    const progress = effect.timer / effect.duration;
                    
                    // Multi-stage rendering
                    if (progress < 0.1) {
                        // Initial flash - brilliant white
                        ctx.globalAlpha = effect.alpha * 0.9;
                        const flashGradient = ctx.createRadialGradient(
                            effect.x, effect.y, 0,
                            effect.x, effect.y, effect.radius
                        );
                        flashGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                        flashGradient.addColorStop(0.6, 'rgba(255, 255, 200, 0.95)');
                        flashGradient.addColorStop(1, 'rgba(255, 200, 150, 0)');
                        ctx.fillStyle = flashGradient;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (progress < 0.25) {
                        // Shockwave ring - expanding orange ring
                        ctx.globalAlpha = effect.alpha * 0.8;
                        
                        // Outer fireball
                        const fireGradient = ctx.createRadialGradient(
                            effect.x, effect.y, 0,
                            effect.x, effect.y, effect.radius
                        );
                        fireGradient.addColorStop(0, 'rgba(255, 255, 220, 1.0)');
                        fireGradient.addColorStop(0.4, 'rgba(255, 180, 80, 0.9)');
                        fireGradient.addColorStop(0.7, 'rgba(255, 100, 30, 0.6)');
                        fireGradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                        ctx.fillStyle = fireGradient;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Shockwave ring
                        const ringProgress = (progress - 0.1) / 0.15;
                        ctx.globalAlpha = (1.0 - ringProgress) * 0.7;
                        ctx.strokeStyle = 'rgba(255, 200, 100, 0.9)';
                        ctx.lineWidth = 8 - ringProgress * 6;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius * 0.95, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        // Fireball - roiling orange and red
                        ctx.globalAlpha = effect.alpha * 0.7;
                        
                        const fireProgress = (progress - 0.25) / 0.75;
                        const gradient = ctx.createRadialGradient(
                            effect.x, effect.y, 0,
                            effect.x, effect.y, effect.radius
                        );
                        
                        // Color shift from yellow-white to deep red as it fades
                        const coreRed = 255;
                        const coreGreen = Math.floor(200 - fireProgress * 150);
                        const coreBlue = Math.floor(100 - fireProgress * 100);
                        
                        gradient.addColorStop(0, `rgba(${coreRed}, ${coreGreen}, ${coreBlue}, 1.0)`);
                        gradient.addColorStop(0.4, 'rgba(255, 120, 40, 0.8)');
                        gradient.addColorStop(0.7, 'rgba(200, 60, 20, 0.5)');
                        gradient.addColorStop(0.9, 'rgba(120, 30, 10, 0.2)');
                        gradient.addColorStop(1, 'rgba(80, 20, 5, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add smoke ring at the edge
                        if (fireProgress > 0.3) {
                            ctx.globalAlpha = (1.0 - fireProgress) * 0.4;
                            ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                            ctx.lineWidth = 12;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.radius * 1.05, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw debris particles
                    if (effect.particles && progress > 0.1) {
                        const debrisAlpha = Math.min(1.0, (1.0 - progress) * 1.5);
                        ctx.globalAlpha = debrisAlpha * 0.8;
                        
                        effect.particles.forEach(p => {
                            const x = effect.x + Math.cos(p.angle) * p.distance;
                            const y = effect.y + Math.sin(p.angle) * p.distance;
                            
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate(p.rotation);
                            
                            // Hot debris - glowing orange to dark
                            const heatLevel = Math.max(0, 1.0 - p.distance / p.maxDistance);
                            const red = Math.floor(150 + heatLevel * 105);
                            const green = Math.floor(heatLevel * 80);
                            const blue = Math.floor(heatLevel * 20);
                            
                            ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, 1.0)`;
                            ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                            
                            ctx.restore();
                        });
                    }
                    
                    ctx.restore();
                });
            }
            
            // Draw cross spires (monuments to fallen units during impact)
            if (game.crossSpires.length > 0) {
                const now = Date.now();
                ctx.globalAlpha = 1.0;
                game.crossSpires.forEach(spire => {
                    const age = (now - spire.createdAt) / 1000;
                    const fadeStart = 2.0; // Start fading after 2 seconds
                    const fadeDuration = 1.0; // Fade over 1 second
                    
                    let alpha = 1.0;
                    if (age > fadeStart) {
                        alpha = Math.max(0, 1.0 - (age - fadeStart) / fadeDuration);
                    }
                    
                    if (alpha > 0) {
                        ctx.globalAlpha = alpha;
                        
                        const baseSize = spire.large ? 12 : 6;
                        const crossHeight = spire.large ? 20 : 10;
                        const crossWidth = spire.large ? 12 : 6;
                        const shadowOffset = spire.large ? 3 : 2;
                        
                        // Draw shadow (offset bottom-right)
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.fillRect(
                            spire.x - baseSize/2 + shadowOffset, 
                            spire.y - baseSize/2 + shadowOffset, 
                            baseSize, 
                            baseSize
                        );
                        
                        // Draw vertical shadow line
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = spire.large ? 3 : 2;
                        ctx.beginPath();
                        ctx.moveTo(spire.x + shadowOffset, spire.y - crossHeight + shadowOffset);
                        ctx.lineTo(spire.x + shadowOffset, spire.y + shadowOffset);
                        ctx.stroke();
                        
                        // Draw horizontal shadow line
                        ctx.beginPath();
                        ctx.moveTo(spire.x - crossWidth + shadowOffset, spire.y - crossHeight * 0.6 + shadowOffset);
                        ctx.lineTo(spire.x + crossWidth + shadowOffset, spire.y - crossHeight * 0.6 + shadowOffset);
                        ctx.stroke();
                        
                        // Draw base (at detonation point)
                        ctx.fillStyle = spire.color;
                        ctx.fillRect(spire.x - baseSize/2, spire.y - baseSize/2, baseSize, baseSize);
                        
                        // Draw cross with bottom at detonation point
                        // Vertical beam
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = spire.large ? 2.5 : 1.5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(spire.x, spire.y - crossHeight); // Top of cross
                        ctx.lineTo(spire.x, spire.y); // Bottom at detonation point
                        ctx.stroke();
                        
                        // Horizontal beam (positioned in upper third)
                        ctx.beginPath();
                        ctx.moveTo(spire.x - crossWidth, spire.y - crossHeight * 0.6);
                        ctx.lineTo(spire.x + crossWidth, spire.y - crossHeight * 0.6);
                        ctx.stroke();
                        
                        // Add white glow for 3D effect
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = spire.large ? 4 : 2.5;
                        ctx.beginPath();
                        ctx.moveTo(spire.x, spire.y - crossHeight);
                        ctx.lineTo(spire.x, spire.y);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw nodes
            nodes.forEach(node => node.draw());
            
            // Draw artifacts
            // Draw artifacts (only if spawned)
            artifacts.forEach(artifact => {
                // Check spawn delay
                if (!artifact.hasSpawned) {
                    if (!artifact.spawnTime) artifact.spawnTime = game.startTime ? (performance.now() - game.startTime) / 1000 : 0;
                    const gameTime = game.startTime ? (performance.now() - game.startTime) / 1000 : 0;
                    if (gameTime >= artifact.spawnDelay) {
                        artifact.hasSpawned = true;
                    } else {
                        return; // Not spawned yet, don't draw
                    }
                }
                artifact.draw();
            });
            
            // Draw artifact icons on capitals showing what each nation owns
            nations.forEach(nation => {
                if (nation.capitulated || !nation.capital) return;
                
                // Filter out archived studied plans from display
                const ownedArtifacts = artifacts.filter(a => 
                    a.capturedBy === nation.id && 
                    !(a.type === 'plans' && a.isStudied && a.storedAtNode) &&
                    !a.carrier  // Don't show if being carried
                );
                if (ownedArtifacts.length === 0) return;
                
                const capital = nation.capital;
                const iconSize = 8;
                const spacing = 12;
                const iconsPerRow = 4;
                const startY = capital.y - 50; // Above capital
                
                // Check which artifacts are unlocked (have their dependencies)
                const ownedTypes = ownedArtifacts.map(a => a.type);
                
                ownedArtifacts.forEach((artifact, index) => {
                    const row = Math.floor(index / iconsPerRow);
                    const col = index % iconsPerRow;
                    const x = capital.x - (iconsPerRow * spacing / 2) + col * spacing + spacing / 2;
                    const y = startY + row * spacing;
                    
                    // Check if this artifact is unlocked
                    const isUnlocked = !artifact.requires || ownedTypes.includes(artifact.requires);
                    
                    // Draw small icon background - brighter if unlocked
                    ctx.fillStyle = isUnlocked ? 'rgba(0, 200, 100, 0.4)' : 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(x - iconSize/2, y - iconSize/2, iconSize, iconSize);
                    
                    // Draw artifact icon
                    ctx.fillStyle = artifact.color;
                    ctx.globalAlpha = isUnlocked ? 1.0 : 0.5; // Dim if locked
                    
                    if (artifact.type === 'spear') {
                        ctx.fillRect(x - 2, y - 4, 1, 8);
                        ctx.beginPath();
                        ctx.moveTo(x, y - 5);
                        ctx.lineTo(x - 2, y - 3);
                        ctx.lineTo(x + 2, y - 3);
                        ctx.fill();
                    } else if (artifact.type === 'keycode' || artifact.type === 'key') {
                        ctx.beginPath();
                        ctx.arc(x, y - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(x - 1, y, 2, 4);
                    } else if (artifact.type === 'lab') {
                        ctx.fillRect(x - 3, y - 1, 6, 4);
                        ctx.fillRect(x - 1, y - 4, 2, 3);
                    } else if (artifact.type === 'safe') {
                        ctx.fillRect(x - 3, y - 3, 6, 6);
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'auth_code' || artifact.type === 'access_card') {
                        ctx.fillRect(x - 3, y - 2, 6, 4);
                    } else if (artifact.type === 'prototype') {
                        ctx.fillRect(x - 3, y - 3, 6, 6);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'reactor') {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(x - 1, y - 3, 2, 6);
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'blueprint') {
                        ctx.fillRect(x - 3, y - 3, 6, 6);
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(x - 2, y - 2, 4, 1);
                        ctx.fillRect(x - 2, y, 4, 1);
                        ctx.fillRect(x - 2, y + 2, 4, 1);
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'data') {
                        ctx.fillRect(x - 2, y - 3, 4, 6);
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(x - 1, y - 2, 2, 1);
                        ctx.fillRect(x - 1, y, 2, 1);
                        ctx.fillRect(x - 1, y + 2, 2, 1);
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'plans') {
                        ctx.fillRect(x - 3, y - 2, 6, 4);
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(x - 2, y - 1, 4, 2);
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = artifact.color;
                    } else if (artifact.type === 'weapon') {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(-1, -4, 2, 8);
                        ctx.restore();
                    }
                });
                
                ctx.globalAlpha = 1.0;
            });
            
            // Border visualization handled by drawBorders() using influence grid
            
            nations.forEach(nation => {
                nation.units.forEach(unit => unit.draw());
            });
            
            ctx.restore();
            
            // Impact warning overlay
            if (game.impactInProgress) {
                const pulse = Math.sin(game.impactTimer * 3) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 0, 0, ${0.2 + pulse * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`IMPACT EVENT ${game.impactCount}`, canvas.width / 2, canvas.height / 2 - 40);
                
                ctx.font = '24px monospace';
                if (game.impactTimer < 3.0) {
                    ctx.fillText('Converting all life...', canvas.width / 2, canvas.height / 2 + 20);
                } else if (game.impactTimer < 5.0) {
                    ctx.fillText('Preparing rebirth...', canvas.width / 2, canvas.height / 2 + 20);
                }
                ctx.textAlign = 'left';
            }
            
            // Minimal FPS display with game speed
            const flashIntensity = Math.max(0, speedChangeFlash);
            const speedColor = flashIntensity > 0 ? `rgba(255, 255, 0, ${0.3 + flashIntensity * 0.7})` : 'rgba(0, 0, 0, 0.5)';
            ctx.fillStyle = speedColor;
            ctx.fillRect(canvas.width - 120, 5, 115, 18);
            
            const textColor = flashIntensity > 0 ? '#ffff00' : '#00ff88';
            ctx.fillStyle = textColor;
            ctx.font = flashIntensity > 0 ? 'bold 13px monospace' : '12px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(`FPS: ${fps}  Speed: ${gameSpeed.toFixed(2)}x`, canvas.width - 8, 18);
            ctx.textAlign = 'left';
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start
        setTimeout(() => {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('fade-out');
                setTimeout(() => loadingScreen.remove(), 1000);
            }
            initAudioContext();
            console.log('✓ Frontier simulation online');
        }, 1500);
        
        gameLoop();
    </script>
</body>
</html>
